分析目录: /data/user/0/com.cscjapp.python/files/aarch64-linux-android/lib/python3.11/site-packages/kivy/
/
  分析文件: app.py
  类 App:
    ```
    Application class, see module documentation for more information.
    
    :Events:
        `on_start`:
            Fired when the application is being started (before the
            :func:`~kivy.base.runTouchApp` call.
        `on_stop`:
            Fired when the application stops.
        `on_pause`:
            Fired when the application is paused by the OS.
        `on_resume`:
            Fired when the application is resumed from pause by the OS. Beware:
            you have no guarantee that this event will be fired after the
            `on_pause` event has been called.
    
    .. versionchanged:: 1.7.0
        Parameter `kv_file` added.
    
    .. versionchanged:: 1.8.0
        Parameters `kv_file` and `kv_directory` are now properties of App.
    ```
    基类: Name(id='EventDispatcher', ctx=Load())
    函数 __init__(self: )
    函数 build(self: )
      ```
      Initializes the application; it will be called only once.
      If this method returns a widget (tree), it will be used as the root
      widget and added to the window.
      
      :return:
          None or a root :class:`~kivy.uix.widget.Widget` instance
          if no self.root exists.
      ```
    函数 build_config(self: , config: )
      ```
      .. versionadded:: 1.0.7
      
      This method is called before the application is initialized to
      construct your :class:`~kivy.config.ConfigParser` object. This
      is where you can put any default section / key / value for your
      config. If anything is set, the configuration will be
      automatically saved in the file returned by
      :meth:`get_application_config`.
      
      :Parameters:
          `config`: :class:`~kivy.config.ConfigParser`
              Use this to add default section / key / value items
      ```
    函数 build_settings(self: , settings: )
      ```
      .. versionadded:: 1.0.7
      
      This method is called when the user (or you) want to show the
      application settings. It is called once when the settings panel
      is first opened, after which the panel is cached. It may be
      called again if the cached settings panel is removed by
      :meth:`destroy_settings`.
      
      You can use this method to add settings panels and to
      customise the settings widget e.g. by changing the sidebar
      width. See the module documentation for full details.
      
      :Parameters:
          `settings`: :class:`~kivy.uix.settings.Settings`
              Settings instance for adding panels
      ```
    函数 load_kv(self: , filename: )
      ```
      This method is invoked the first time the app is being run if no
      widget tree has been constructed before for this app.
      This method then looks for a matching kv file in the same directory as
      the file that contains the application class.
      
      For example, say you have a file named main.py that contains::
      
          class ShowcaseApp(App):
              pass
      
      This method will search for a file named `showcase.kv` in
      the directory that contains main.py. The name of the kv file has to be
      the lowercase name of the class, without the 'App' postfix at the end
      if it exists.
      
      You can define rules and a root widget in your kv file::
      
          <ClassName>: # this is a rule
              ...
      
          ClassName: # this is a root widget
              ...
      
      There must be only one root widget. See the :doc:`api-kivy.lang`
      documentation for more information on how to create kv files. If your
      kv file contains a root widget, it will be used as self.root, the root
      widget for the application.
      
      .. note::
      
          This function is called from :meth:`run`, therefore, any widget
          whose styling is defined in this kv file and is created before
          :meth:`run` is called (e.g. in `__init__`), won't have its styling
          applied. Note that :meth:`build` is called after :attr:`load_kv`
          has been called.
      ```
    函数 get_application_name(self: )
      ```
      Return the name of the application.
              
      ```
    函数 get_application_icon(self: )
      ```
      Return the icon of the application.
              
      ```
    函数 get_application_config(self: , defaultpath: )
      ```
      Return the filename of your application configuration. Depending
      on the platform, the application file will be stored in
      different locations:
      
          - on iOS: <appdir>/Documents/.<appname>.ini
          - on Android: <user_data_dir>/.<appname>.ini
          - otherwise: <appdir>/<appname>.ini
      
      When you are distributing your application on Desktops, please
      note that if the application is meant to be installed
      system-wide, the user might not have write-access to the
      application directory. If you want to store user settings, you
      should overload this method and change the default behavior to
      save the configuration file in the user directory. ::
      
          class TestApp(App):
              def get_application_config(self):
                  return super(TestApp, self).get_application_config(
                      '~/.%(appname)s.ini')
      
      Some notes:
      
      - The tilda '~' will be expanded to the user directory.
      - %(appdir)s will be replaced with the application :attr:`directory`
      - %(appname)s will be replaced with the application :attr:`name`
      
      .. versionadded:: 1.0.7
      
      .. versionchanged:: 1.4.0
          Customized the defaultpath for iOS and Android platforms. Added a
          defaultpath parameter for desktop OS's (not applicable to iOS
          and Android.)
      
      .. versionchanged:: 1.11.0
          Changed the Android version to make use of the
          :attr:`~App.user_data_dir` and added a missing dot to the iOS
          config file name.
      ```
    函数 root_window(self: )
      ```
      .. versionadded:: 1.9.0
      
      Returns the root window instance used by :meth:`run`.
      ```
    函数 load_config(self: )
      ```
      (internal) This function is used for returning a ConfigParser with
      the application configuration. It's doing 3 things:
      
          #. Creating an instance of a ConfigParser
          #. Loading the default configuration by calling
             :meth:`build_config`, then
          #. If it exists, it loads the application configuration file,
             otherwise it creates one.
      
      :return:
          :class:`~kivy.config.ConfigParser` instance
      ```
    函数 directory(self: )
      ```
      .. versionadded:: 1.0.7
      
      Return the directory where the application lives.
      ```
    函数 _get_user_data_dir(self: )
    函数 user_data_dir(self: )
      ```
      .. versionadded:: 1.7.0
      
      Returns the path to the directory in the users file system which the
      application can use to store additional data.
      
      Different platforms have different conventions with regards to where
      the user can store data such as preferences, saved games and settings.
      This function implements these conventions. The <app_name> directory
      is created when the property is called, unless it already exists.
      
      On iOS, `~/Documents/<app_name>` is returned (which is inside the
      app's sandbox).
      
      On Windows, `%APPDATA%/<app_name>` is returned.
      
      On OS X, `~/Library/Application Support/<app_name>` is returned.
      
      On Linux, `$XDG_CONFIG_HOME/<app_name>` is returned.
      
      On Android, `Context.GetFilesDir
      <https://developer.android.com/reference/android/content/Context.html#getFilesDir()>`_ is returned.
      
      .. versionchanged:: 1.11.0
      
          On Android, this function previously returned
          `/sdcard/<app_name>`. This folder became read-only by default
          in Android API 26 and the user_data_dir has therefore been moved
          to a writeable location.
      ```
    函数 name(self: )
      ```
      .. versionadded:: 1.0.7
      
      Return the name of the application based on the class name.
      ```
    函数 _run_prepare(self: )
    函数 run(self: )
      ```
      Launches the app in standalone mode.
              
      ```
    函数 stop(self: )
      ```
      Stop the application.
      
      If you use this method, the whole application will stop by issuing
      a call to :func:`~kivy.base.stopTouchApp`.
      Except on Android, set Android state to stop, Kivy state then follows.
      ```
    函数 _stop(self: )
    函数 pause(self: )
      ```
      Pause the application.
      
      On Android set OS state to pause, Kivy app state follows.
      No functionality on other OS.
      .. versionadded:: 2.2.0
      ```
    函数 on_start(self: )
      ```
      Event handler for the `on_start` event which is fired after
      initialization (after build() has been called) but before the
      application has started running.
      ```
    函数 on_stop(self: )
      ```
      Event handler for the `on_stop` event which is fired when the
      application has finished running (i.e. the window is about to be
      closed).
      ```
    函数 on_pause(self: )
      ```
      Event handler called when Pause mode is requested. You should
      return True if your app can go into Pause mode, otherwise
      return False and your application will be stopped.
      
      You cannot control when the application is going to go into this mode.
      It's determined by the Operating System and mostly used for mobile
      devices (android/ios) and for resizing.
      
      The default return value is True.
      
      .. versionadded:: 1.1.0
      .. versionchanged:: 1.10.0
          The default return value is now True.
      ```
    函数 on_resume(self: )
      ```
      Event handler called when your application is resuming from
      the Pause mode.
      
      .. versionadded:: 1.1.0
      
      .. warning::
      
          When resuming, the OpenGL Context might have been damaged / freed.
          This is where you can reconstruct some of your OpenGL state
          e.g. FBO content.
      ```
    函数 get_running_app()
      ```
      Return the currently running application instance.
      
      .. versionadded:: 1.1.0
      ```
    函数 on_config_change(self: , config: , section: , key: , value: )
      ```
      Event handler fired when a configuration token has been changed by
      the settings page.
      
      .. versionchanged:: 1.10.1
         Added corresponding ``on_config_change`` event.
      ```
    函数 open_settings(self: )
      ```
      Open the application settings panel. It will be created the very
      first time, or recreated if the previously cached panel has been
      removed by :meth:`destroy_settings`. The settings panel will be
      displayed with the
      :meth:`display_settings` method, which by default adds the
      settings panel to the Window attached to your application. You
      should override that method if you want to display the
      settings panel differently.
      
      :return:
          True if the settings has been opened.
      ```
    函数 display_settings(self: , settings: )
      ```
      .. versionadded:: 1.8.0
      
      Display the settings panel. By default, the panel is drawn directly
      on top of the window. You can define other behaviour by overriding
      this method, such as adding it to a ScreenManager or Popup.
      
      You should return True if the display is successful, otherwise False.
      
      :Parameters:
          `settings`: :class:`~kivy.uix.settings.Settings`
              You can modify this object in order to modify the settings
              display.
      ```
    函数 close_settings(self: )
      ```
      Close the previously opened settings panel.
      
      :return:
          True if the settings has been closed.
      ```
    函数 create_settings(self: )
      ```
      Create the settings panel. This method will normally
      be called only one time per
      application life-time and the result is cached internally,
      but it may be called again if the cached panel is removed
      by :meth:`destroy_settings`.
      
      By default, it will build a settings panel according to
      :attr:`settings_cls`, call :meth:`build_settings`, add a Kivy panel if
      :attr:`use_kivy_settings` is True, and bind to
      on_close/on_config_change.
      
      If you want to plug your own way of doing settings, without the Kivy
      panel or close/config change events, this is the method you want to
      overload.
      
      .. versionadded:: 1.8.0
      ```
    函数 destroy_settings(self: )
      ```
      .. versionadded:: 1.8.0
      
      Dereferences the current settings panel if one
      exists. This means that when :meth:`App.open_settings` is next
      run, a new panel will be created and displayed. It doesn't
      affect any of the contents of the panel, but lets you (for
      instance) refresh the settings panel layout if you have
      changed the settings widget in response to a screen size
      change.
      
      If you have modified :meth:`~App.open_settings` or
      :meth:`~App.display_settings`, you should be careful to
      correctly detect if the previous settings widget has been
      destroyed.
      ```
    函数 _on_config_change(self: )
    函数 _install_settings_keys(self: , window: )
    函数 _on_keyboard_settings(self: , window: )
    函数 on_title(self: , instance: , title: )
    函数 on_icon(self: , instance: , icon: )
  分析文件: compat.py
  函数 _isclose(a: , b: , rel_tol: , abs_tol: )
    ```
    Measures whether two floats are "close" to each other. Identical to
    https://docs.python.org/3.6/library/math.html#math.isclose, for older
    versions of python.
    ```
  分析文件: animation.py
  类 Animation:
    ```
    Create an animation definition that can be used to animate a Widget.
    
    :Parameters:
        `duration` or `d`: float, defaults to 1.
            Duration of the animation, in seconds.
        `transition` or `t`: str or func
            Transition function for animate properties. It can be the name of a
            method from :class:`AnimationTransition`.
        `step` or `s`: float
            Step in milliseconds of the animation. Defaults to 0, which means
            the animation is updated for every frame.
    
            To update the animation less often, set the step value to a float.
            For example, if you want to animate at 30 FPS, use s=1/30.
    
    :Events:
        `on_start`: animation, widget
            Fired when the animation is started on a widget.
        `on_complete`: animation, widget
            Fired when the animation is completed or stopped on a widget.
        `on_progress`: animation, widget, progression
            Fired when the progression of the animation is changing.
    
    .. versionchanged:: 1.4.0
        Added s/step parameter.
    
    .. versionchanged:: 1.10.0
        The default value of the step parameter was changed from 1/60. to 0.
    ```
    基类: Name(id='EventDispatcher', ctx=Load())
    函数 __init__(self: )
    函数 duration(self: )
      ```
      Return the duration of the animation.
              
      ```
    函数 transition(self: )
      ```
      Return the transition of the animation.
              
      ```
    函数 animated_properties(self: )
      ```
      Return the properties used to animate.
              
      ```
    函数 stop_all(widget: )
      ```
      Stop all animations that concern a specific widget / list of
      properties.
      
      Example::
      
          anim = Animation(x=50)
          anim.start(widget)
      
          # and later
          Animation.stop_all(widget, 'x')
      ```
    函数 cancel_all(widget: )
      ```
      Cancel all animations that concern a specific widget / list of
      properties. See :attr:`cancel`.
      
      Example::
      
          anim = Animation(x=50)
          anim.start(widget)
      
          # and later
          Animation.cancel_all(widget, 'x')
      
      .. versionadded:: 1.4.0
      
      .. versionchanged:: 2.1.0
          If the parameter ``widget`` is None, all animated widgets will be
          the target and cancelled. If ``largs`` is also given, animation of
          these properties will be canceled for all animated widgets.
      ```
    函数 start(self: , widget: )
      ```
      Start the animation on a widget.
              
      ```
    函数 stop(self: , widget: )
      ```
      Stop the animation previously applied to a widget, triggering the
      `on_complete` event.
      ```
    函数 cancel(self: , widget: )
      ```
      Cancel the animation previously applied to a widget. Same
      effect as :attr:`stop`, except the `on_complete` event will
      *not* be triggered!
      
      .. versionadded:: 1.4.0
      ```
    函数 stop_property(self: , widget: , prop: )
      ```
      Even if an animation is running, remove a property. It will not be
      animated further. If it was the only/last property being animated,
      the animation will be stopped (see :attr:`stop`).
      ```
    函数 cancel_property(self: , widget: , prop: )
      ```
      Even if an animation is running, remove a property. It will not be
      animated further. If it was the only/last property being animated,
      the animation will be canceled (see :attr:`cancel`)
      
      .. versionadded:: 1.4.0
      ```
    函数 have_properties_to_animate(self: , widget: )
      ```
      Return True if a widget still has properties to animate.
      
      .. versionadded:: 1.8.0
      ```
    函数 _register(self: )
    函数 _unregister(self: )
    函数 _initialize(self: , widget: )
    函数 _clock_install(self: )
    函数 _clock_uninstall(self: )
    函数 _update(self: , dt: )
    函数 _calculate(self: , a: , b: , t: )
    函数 on_start(self: , widget: )
    函数 on_progress(self: , widget: , progress: )
    函数 on_complete(self: , widget: )
    函数 __add__(self: , animation: )
    函数 __and__(self: , animation: )
  类 CompoundAnimation:
    基类: Name(id='Animation', ctx=Load())
  类 Sequence:
    基类: Name(id='CompoundAnimation', ctx=Load())
    函数 on_anim1_complete(self: , instance: , widget: )
    函数 on_anim1_progress(self: , instance: , widget: , progress: )
    函数 on_anim2_complete(self: , instance: , widget: )
      ```
      Repeating logic used with boolean variable "repeat".
      
      .. versionadded:: 1.7.1
      ```
    函数 on_anim2_progress(self: , instance: , widget: , progress: )
  类 Parallel:
    基类: Name(id='CompoundAnimation', ctx=Load())
    函数 on_anim_complete(self: , instance: , widget: )
  类 AnimationTransition:
    ```
    Collection of animation functions to be used with the Animation object.
    Easing Functions ported to Kivy from the Clutter Project
    https://developer.gnome.org/clutter/stable/ClutterAlpha.html
    
    The `progress` parameter in each animation function is in the range 0-1.
    ```
    函数 linear(progress: )
      ```
      .. image:: images/anim_linear.png
      ```
    函数 in_quad(progress: )
      ```
      .. image:: images/anim_in_quad.png
              
      ```
    函数 out_quad(progress: )
      ```
      .. image:: images/anim_out_quad.png
              
      ```
    函数 in_out_quad(progress: )
      ```
      .. image:: images/anim_in_out_quad.png
              
      ```
    函数 in_cubic(progress: )
      ```
      .. image:: images/anim_in_cubic.png
              
      ```
    函数 out_cubic(progress: )
      ```
      .. image:: images/anim_out_cubic.png
              
      ```
    函数 in_out_cubic(progress: )
      ```
      .. image:: images/anim_in_out_cubic.png
              
      ```
    函数 in_quart(progress: )
      ```
      .. image:: images/anim_in_quart.png
              
      ```
    函数 out_quart(progress: )
      ```
      .. image:: images/anim_out_quart.png
              
      ```
    函数 in_out_quart(progress: )
      ```
      .. image:: images/anim_in_out_quart.png
              
      ```
    函数 in_quint(progress: )
      ```
      .. image:: images/anim_in_quint.png
              
      ```
    函数 out_quint(progress: )
      ```
      .. image:: images/anim_out_quint.png
              
      ```
    函数 in_out_quint(progress: )
      ```
      .. image:: images/anim_in_out_quint.png
              
      ```
    函数 in_sine(progress: )
      ```
      .. image:: images/anim_in_sine.png
              
      ```
    函数 out_sine(progress: )
      ```
      .. image:: images/anim_out_sine.png
              
      ```
    函数 in_out_sine(progress: )
      ```
      .. image:: images/anim_in_out_sine.png
              
      ```
    函数 in_expo(progress: )
      ```
      .. image:: images/anim_in_expo.png
              
      ```
    函数 out_expo(progress: )
      ```
      .. image:: images/anim_out_expo.png
              
      ```
    函数 in_out_expo(progress: )
      ```
      .. image:: images/anim_in_out_expo.png
              
      ```
    函数 in_circ(progress: )
      ```
      .. image:: images/anim_in_circ.png
              
      ```
    函数 out_circ(progress: )
      ```
      .. image:: images/anim_out_circ.png
              
      ```
    函数 in_out_circ(progress: )
      ```
      .. image:: images/anim_in_out_circ.png
              
      ```
    函数 in_elastic(progress: )
      ```
      .. image:: images/anim_in_elastic.png
              
      ```
    函数 out_elastic(progress: )
      ```
      .. image:: images/anim_out_elastic.png
              
      ```
    函数 in_out_elastic(progress: )
      ```
      .. image:: images/anim_in_out_elastic.png
              
      ```
    函数 in_back(progress: )
      ```
      .. image:: images/anim_in_back.png
              
      ```
    函数 out_back(progress: )
      ```
      .. image:: images/anim_out_back.png
              
      ```
    函数 in_out_back(progress: )
      ```
      .. image:: images/anim_in_out_back.png
              
      ```
    函数 _out_bounce_internal(t: , d: )
    函数 _in_bounce_internal(t: , d: )
    函数 in_bounce(progress: )
      ```
      .. image:: images/anim_in_bounce.png
              
      ```
    函数 out_bounce(progress: )
      ```
      .. image:: images/anim_out_bounce.png
              
      ```
    函数 in_out_bounce(progress: )
      ```
      .. image:: images/anim_in_out_bounce.png
              
      ```
  分析文件: parser.py
  类 ColorException:
    基类: Name(id='Exception', ctx=Load())
  函数 parse_filename(filename: )
    ```
    Parse a filename and search for it using `resource_find()`.
    If found, the resource path is returned, otherwise return the unmodified
    filename (as specified by the caller).
    ```
  函数 color_error(text: )
  函数 parse_color(text: )
    ```
    Parse a string to a kivy color. Supported formats:
    
        * rgb(r, g, b)
        * rgba(r, g, b, a)
        * rgb
        * rgba
        * rrggbb
        * rrggbbaa
    
    For hexadecimal values, you case also use:
    
        * #rgb
        * #rgba
        * #rrggbb
        * #rrggbbaa
    ```
  函数 parse_bool(text: )
    ```
    Parse a string to a boolean, ignoring case. "true"/"1" is True,
    "false"/"0" is False. Anything else throws an exception.
    ```
  函数 parse_string(text: )
    ```
    Parse a string to a string (removing single and double quotes).
    ```
  函数 parse_int2(text: )
    ```
    Parse a string to a list of exactly 2 integers.
    
    >>> print(parse_int2("12 54"))
    12, 54
    ```
  函数 parse_float4(text: )
    ```
    Parse a string to a list of exactly 4 floats.
    
    >>> parse_float4('54 87. 35 0')
    54, 87., 35, 0
    ```
  core/
    image/
      分析文件: img_sdl2.py
      类 ImageLoaderSDL2:
        ```
        Image loader based on SDL2_image
        ```
        基类: Name(id='ImageLoaderBase', ctx=Load())
        函数 _ensure_ext(self: )
        函数 extensions()
          ```
          Return accepted extensions for this loader
          ```
        函数 can_save(fmt: , is_bytesio: )
        函数 can_load_memory()
        函数 load(self: , filename: )
        函数 save(filename: , width: , height: , pixelfmt: , pixels: , flipped: , imagefmt: )
      分析文件: img_pil.py
      类 ImageLoaderPIL:
        ```
        Image loader based on the PIL library.
        
        .. versionadded:: 1.0.8
        
        Support for GIF animation added.
        
        Gif animation has a lot of issues(transparency/color depths... etc).
        In order to keep it simple, what is implemented here is what is
        natively supported by the PIL library.
        
        As a general rule, try to use gifs that have no transparency.
        Gif's with transparency will work but be prepared for some
        artifacts until transparency support is improved.
        ```
        基类: Name(id='ImageLoaderBase', ctx=Load())
        函数 can_save(fmt: , is_bytesio: )
        函数 can_load_memory()
        函数 extensions()
          ```
          Return accepted extensions for this loader
          ```
        函数 _img_correct(self: , _img_tmp: )
          ```
          Convert image to the correct format and orientation.
                  
          ```
        函数 _img_read(self: , im: )
          ```
          Read images from an animated file.
                  
          ```
        函数 load(self: , filename: )
        函数 save(filename: , width: , height: , pixelfmt: , pixels: , flipped: , imagefmt: )
      分析文件: img_pygame.py
      类 ImageLoaderPygame:
        ```
        Image loader based on the PIL library
        ```
        基类: Name(id='ImageLoaderBase', ctx=Load())
        函数 __init__(self: )
        函数 extensions()
          ```
          Return accepted extensions for this loader
          ```
        函数 can_save(fmt: , is_bytesio: )
        函数 can_load_memory()
        函数 load(self: , filename: )
        函数 save(filename: , width: , height: , pixelfmt: , pixels: , flipped: , imagefmt: )
      分析文件: img_dds.py
      类 ImageLoaderDDS:
        基类: Name(id='ImageLoaderBase', ctx=Load())
        函数 extensions()
        函数 load(self: , filename: )
      分析文件: img_ffpyplayer.py
      函数 _log_callback(message: , level: )
      类 ImageLoaderFFPy:
        ```
        Image loader based on the ffpyplayer library.
        
        .. versionadded:: 1.9.0
        
        .. note:
            This provider may support more formats than what is listed in
            :meth:`extensions`.
        ```
        基类: Name(id='ImageLoaderBase', ctx=Load())
        函数 extensions()
          ```
          Return accepted extensions for this loader
          ```
        函数 load(self: , filename: )
      分析文件: img_tex.py
      类 ImageLoaderTex:
        基类: Name(id='ImageLoaderBase', ctx=Load())
        函数 extensions()
        函数 load(self: , filename: )
      分析文件: __init__.py
      类 ImageData:
        ```
        Container for images and mipmap images.
        The container will always have at least the mipmap level 0.
        ```
        基类: Name(id='object', ctx=Load())
        函数 __init__(self: , width: , height: , fmt: , data: , source: , flip_vertical: , source_image: , rowlength: )
        函数 release_data(self: )
        函数 width(self: )
          ```
          Image width in pixels.
          (If the image is mipmapped, it will use the level 0)
          ```
        函数 height(self: )
          ```
          Image height in pixels.
          (If the image is mipmapped, it will use the level 0)
          ```
        函数 data(self: )
          ```
          Image data.
          (If the image is mipmapped, it will use the level 0)
          ```
        函数 rowlength(self: )
          ```
          Image rowlength.
          (If the image is mipmapped, it will use the level 0)
          
          .. versionadded:: 1.9.0
          ```
        函数 size(self: )
          ```
          Image (width, height) in pixels.
          (If the image is mipmapped, it will use the level 0)
          ```
        函数 have_mipmap(self: )
        函数 __repr__(self: )
        函数 add_mipmap(self: , level: , width: , height: , data: , rowlength: )
          ```
          Add a image for a specific mipmap level.
          
          .. versionadded:: 1.0.7
          ```
        函数 get_mipmap(self: , level: )
          ```
          Get the mipmap image at a specific level if it exists
          
          .. versionadded:: 1.0.7
          ```
        函数 iterate_mipmaps(self: )
          ```
          Iterate over all mipmap images available.
          
          .. versionadded:: 1.0.7
          ```
      类 ImageLoaderBase:
        ```
        Base to implement an image loader.
        ```
        基类: Name(id='object', ctx=Load())
        函数 load(self: , filename: )
          ```
          Load an image
          ```
        函数 can_save(fmt: , is_bytesio: )
          ```
          Indicate if the loader can save the Image object
          
          .. versionchanged:: 1.11.0
              Parameter `fmt` and `is_bytesio` added
          ```
        函数 can_load_memory()
          ```
          Indicate if the loader can load an image by passing data
                  
          ```
        函数 save()
        函数 populate(self: )
        函数 texture(self: )
          ```
          Get the image texture (created on the first call)
                  
          ```
        函数 textures(self: )
          ```
          Get the textures list (for mipmapped image or animated image)
          
          .. versionadded:: 1.0.8
          ```
        函数 nocache(self: )
          ```
          Indicate if the texture will not be stored in the cache
          
          .. versionadded:: 1.6.0
          ```
      类 ImageLoader:
        基类: Name(id='object', ctx=Load())
        函数 zip_loader(filename: )
          ```
          Read images from an zip file.
          
          .. versionadded:: 1.0.8
          
          Returns an Image with a list of type ImageData stored in Image._data
          ```
        函数 register(defcls: )
      类 Image:
        ```
        Load an image and store the size and texture.
        
        .. versionchanged:: 1.0.7
        
            `mipmap` attribute has been added. The `texture_mipmap` and
            `texture_rectangle` have been deleted.
        
        .. versionchanged:: 1.0.8
        
            An Image widget can change its texture. A new event 'on_texture' has
            been introduced. New methods for handling sequenced animation have been
            added.
        
        :Parameters:
            `arg`: can be a string (str), Texture, BytesIO or Image object
                A string path to the image file or data URI to be loaded; or a
                Texture object, which will be wrapped in an Image object; or a
                BytesIO object containing raw image data; or an already existing
                image object, in which case, a real copy of the given image object
                will be returned.
            `keep_data`: bool, defaults to False
                Keep the image data when the texture is created.
            `mipmap`: bool, defaults to False
                Create mipmap for the texture.
            `anim_delay`: float, defaults to .25
                Delay in seconds between each animation frame. Lower values means
                faster animation.
            `ext`: str, only with BytesIO `arg`
                File extension to use in determining how to load raw image data.
            `filename`: str, only with BytesIO `arg`
                Filename to use in the image cache for raw image data.
        ```
        基类: Name(id='EventDispatcher', ctx=Load())
        函数 remove_from_cache(self: )
          ```
          Remove the Image from cache. This facilitates re-loading of
          images from disk in case the image content has changed.
          
          .. versionadded:: 1.3.0
          
          Usage::
          
              im = CoreImage('1.jpg')
              # -- do something --
              im.remove_from_cache()
              im = CoreImage('1.jpg')
              # this time image will be re-loaded from disk
          ```
        函数 _anim(self: )
        函数 anim_reset(self: , allow_anim: )
          ```
          Reset an animation if available.
          
          .. versionadded:: 1.0.8
          
          :Parameters:
              `allow_anim`: bool
                  Indicate whether the animation should restart playing or not.
          
          Usage::
          
              # start/reset animation
              image.anim_reset(True)
          
              # or stop the animation
              image.anim_reset(False)
          
          You can change the animation speed whilst it is playing::
          
              # Set to 20 FPS
              image.anim_delay = 1 / 20.
          ```
        函数 _get_anim_delay(self: )
        函数 _set_anim_delay(self: , x: )
        函数 anim_available(self: )
          ```
          Return True if this Image instance has animation available.
          
          .. versionadded:: 1.0.8
          ```
        函数 anim_index(self: )
          ```
          Return the index number of the image currently in the texture.
          
          .. versionadded:: 1.0.8
          ```
        函数 _img_iterate(self: )
        函数 on_texture(self: )
          ```
          This event is fired when the texture reference or content has
             changed. It is normally used for sequenced images.
          
          .. versionadded:: 1.0.8
          ```
        函数 _get_image(self: )
        函数 _set_image(self: , image: )
        函数 _get_filename(self: )
        函数 _set_filename(self: , value: )
        函数 load_memory(self: , data: , ext: , filename: )
          ```
          (internal) Method to load an image from raw data.
                  
          ```
        函数 _find_format_from_filename(self: , filename: )
        函数 read_pixel(self: , x: , y: )
          ```
          For a given local x/y position, return the pixel color at that
          position.
          
          .. warning::
              This function can only be used with images loaded with the
              keep_data=True keyword. For example::
          
                  m = Image.load('image.png', keep_data=True)
                  color = m.read_pixel(150, 150)
          
          :Parameters:
              `x`: int
                  Local x coordinate of the pixel in question.
              `y`: int
                  Local y coordinate of the pixel in question.
          ```
    text/
      分析文件: text_pygame.py
      类 LabelPygame:
        基类: Name(id='LabelBase', ctx=Load())
        函数 __init__(self: )
        函数 _get_font_id(self: )
        函数 _get_font(self: )
        函数 get_ascent(self: )
        函数 get_descent(self: )
        函数 get_extents(self: , text: )
        函数 get_cached_extents(self: )
        函数 _render_begin(self: )
        函数 _render_text(self: , text: , x: , y: )
        函数 _render_end(self: )
      分析文件: text_pango.py
      类 LabelPango:
        基类: Name(id='LabelBase', ctx=Load())
        函数 __init__(self: )
        函数 _render_begin(self: )
        函数 _render_text(self: , text: , x: , y: )
        函数 _render_end(self: )
      类 PangoFontContextManager:
        基类: Name(id='FontContextManagerBase', ctx=Load())
        函数 add_font(font_context: , filename: , autocreate: , family: )
      分析文件: text_pil.py
      类 LabelPIL:
        基类: Name(id='LabelBase', ctx=Load())
        函数 _select_font(self: )
        函数 get_extents(self: , text: )
        函数 get_cached_extents(self: )
        函数 _render_begin(self: )
        函数 _render_text(self: , text: , x: , y: )
        函数 _render_end(self: )
      分析文件: markup.py
      类 MarkupLabel:
        ```
        Markup text label.
        
        See module documentation for more information.
        ```
        基类: Name(id='MarkupLabelBase', ctx=Load())
        函数 __init__(self: )
        函数 refs(self: )
          ```
          Get the bounding box of all the ``[ref=...]``::
          
          { 'refA': ((x1, y1, x2, y2), (x1, y1, x2, y2)), ... }
          ```
        函数 anchors(self: )
          ```
          Get the position of all the ``[anchor=...]``::
          
          { 'anchorA': (x, y), 'anchorB': (x, y), ... }
          ```
        函数 markup(self: )
          ```
          Return the text with all the markup split::
          
          >>> MarkupLabel('[b]Hello world[/b]').markup
          >>> ('[b]', 'Hello world', '[/b]')
          ```
        函数 _push_style(self: , k: )
        函数 _pop_style(self: , k: )
        函数 render(self: , real: )
        函数 _pre_render(self: )
        函数 render_lines(self: , lines: , options: , render_text: , y: , size: )
        函数 shorten_post(self: , lines: , w: , h: , margin: )
          ```
          Shortens the text to a single line according to the label options.
          
          This function operates on a text that has already been laid out because
          for markup, parts of text can have different size and options.
          
          If :attr:`text_size` [0] is None, the lines are returned unchanged.
          Otherwise, the lines are converted to a single line fitting within the
          constrained width, :attr:`text_size` [0].
          
          :params:
          
              `lines`: list of `LayoutLine` instances describing the text.
              `w`: int, the width of the text in lines, including padding.
              `h`: int, the height of the text in lines, including padding.
              `margin` int, the additional space left on the sides. This is in
              addition to :attr:`padding_x`.
          
          :returns:
              3-tuple of (xw, h, lines), where w, and h is similar to the input
              and contains the resulting width / height of the text, including
              padding. lines, is a list containing a single `LayoutLine`, which
              contains the words for the line.
          ```
      函数 n(line: , c: )
        ```
        A function similar to text.find, except it's an iterator that
        returns successive occurrences of string c in list line. line is
        not a string, but a list of LayoutWord instances that we walk
        from left to right returning the indices of c in the words as we
        encounter them. Note that the options can be different among the
        words.
        
        :returns:
            3-tuple: the index of the word in line, the index of the
            occurrence in word, and the extents (width) of the combined
            words until this occurrence, not including the occurrence char.
            If no more are found it returns (-1, -1, total_w) where total_w
            is the full width of all the words.
        ```
      函数 p(line: , c: )
        ```
        Similar to the `n` function, except it returns occurrences of c
        from right to left in the list, line, similar to rfind.
        ```
      函数 n_restricted(line: , uw: , c: )
        ```
        Similar to the function `n`, except it only returns the first
        occurrence and it's not an iterator. Furthermore, if the first
        occurrence doesn't fit within width uw, it returns the index of
        whatever amount of text will still fit in uw.
        
        :returns:
            similar to the function `n`, except it's a 4-tuple, with the
            last element a boolean, indicating if we had to clip the text
            to fit in uw (True) or if the whole text until the first
            occurrence fitted in uw (False).
        ```
      函数 p_restricted(line: , uw: , c: )
        ```
        Similar to `n_restricted`, except it returns the first
        occurrence starting from the right, like `p`.
        ```
      分析文件: text_sdl2.py
      类 LabelSDL2:
        基类: Name(id='LabelBase', ctx=Load())
        函数 _get_font_id(self: )
        函数 get_extents(self: , text: )
        函数 get_descent(self: )
        函数 get_ascent(self: )
        函数 _render_begin(self: )
        函数 _render_text(self: , text: , x: , y: )
        函数 _render_end(self: )
      分析文件: __init__.py
      类 LabelBase:
        ```
        Core text label.
        This is the abstract class used by different backends to render text.
        
        .. warning::
            The core text label can't be changed at runtime. You must recreate one.
        
        :Parameters:
            `font_size`: int, defaults to 12
                Font size of the text
            `font_context`: str, defaults to None
                Context for the specified font (see :class:`kivy.uix.label.Label`
                for details). `None` will autocreate an isolated context named
                after the resolved font file.
            `font_name`: str, defaults to DEFAULT_FONT
                Font name of the text
            `font_family`: str, defaults to None
                Font family name to request for drawing, this can only be used
                with `font_context`.
            `bold`: bool, defaults to False
                Activate "bold" text style
            `italic`: bool, defaults to False
                Activate "italic" text style
            `text_size`: tuple, defaults to (None, None)
                Add constraint to render the text (inside a bounding box).
                If no size is given, the label size will be set to the text size.
            `padding`: int|float or list|tuple, defaults to [0, 0, 0, 0].
                Padding of the text in the format [padding_left, padding_top,
                padding_right, padding_bottom].
                ``padding`` should be int|float or a list|tuple with 1, 2 or 4
                elements.
            `padding_x`: float, defaults to 0.0
                Left/right padding
            `padding_y`: float, defaults to 0.0
                Top/bottom padding
            `halign`: str, defaults to "left"
                Horizontal text alignment inside the bounding box
            `valign`: str, defaults to "bottom"
                Vertical text alignment inside the bounding box
            `shorten`: bool, defaults to False
                Indicate whether the label should attempt to shorten its textual
                contents as much as possible if a `size` is given.
                Setting this to True without an appropriately set size will lead to
                unexpected results.
            `shorten_from`: str, defaults to `center`
                The side from which we should shorten the text from, can be left,
                right, or center. E.g. if left, the ellipsis will appear towards
                the left side and it will display as much text starting from the
                right as possible.
            `split_str`: string, defaults to `' '` (space)
                The string to use to split the words by when shortening. If empty,
                we can split after every character filling up the line as much as
                possible.
            `max_lines`: int, defaults to 0 (unlimited)
                If set, this indicate how maximum line are allowed to render the
                text. Works only if a limitation on text_size is set.
            `mipmap`: bool, defaults to False
                Create a mipmap for the texture
            `strip`: bool, defaults to False
                Whether each row of text has its leading and trailing spaces
                stripped. If `halign` is `justify` it is implicitly True.
            `strip_reflow`: bool, defaults to True
                Whether text that has been reflowed into a second line should
                be stripped, even if `strip` is False. This is only in effect when
                `size_hint_x` is not None, because otherwise lines are never
                split.
            `unicode_errors`: str, defaults to `'replace'`
                How to handle unicode decode errors. Can be `'strict'`, `'replace'`
                or `'ignore'`.
            `outline_width`: int, defaults to None
                Width in pixels for the outline.
            `outline_color`: tuple, defaults to (0, 0, 0)
                Color of the outline.
            `font_features`: str, defaults to None
                OpenType font features in CSS format (Pango only)
            `base_direction`: str, defaults to None (auto)
                Text direction, one of `None`, `'ltr'`, `'rtl'`, `'weak_ltr'`,
                or `'weak_rtl'` (Pango only)
            `text_language`: str, defaults to None (user locale)
                RFC-3066 format language tag as a string (Pango only)
        
        .. deprecated:: 2.2.0
            `padding_x` and `padding_y` have been deprecated. Please use `padding`
            instead.
        
        .. versionchanged:: 2.2.0
            `padding` is now a list and defaults to [0, 0, 0, 0]. `padding` accepts
            int|float or a list|tuple with 1, 2 or 4 elements.
        
        .. versionchanged:: 1.10.1
            `font_context`, `font_family`, `font_features`, `base_direction`
            and `text_language` were added.
        
        .. versionchanged:: 1.10.0
            `outline_width` and `outline_color` were added.
        
        .. versionchanged:: 1.9.0
            `strip`, `strip_reflow`, `shorten_from`, `split_str`, and
            `unicode_errors` were added.
        
        .. versionchanged:: 1.9.0
            `padding_x` and `padding_y` has been fixed to work as expected.
            In the past, the text was padded by the negative of their values.
        
        .. versionchanged:: 1.8.0
            `max_lines` parameters has been added.
        
        .. versionchanged:: 1.0.8
            `size` have been deprecated and replaced with `text_size`.
        
        .. versionchanged:: 1.0.7
            The `valign` is now respected. This wasn't the case previously
            so you might have an issue in your application if you have not
            considered this.
        ```
        基类: Name(id='object', ctx=Load())
        函数 __init__(self: , text: , font_size: , font_name: , bold: , italic: , underline: , strikethrough: , font_family: , halign: , valign: , shorten: , text_size: , mipmap: , color: , line_height: , strip: , strip_reflow: , shorten_from: , split_str: , unicode_errors: , font_hinting: , font_kerning: , font_blended: , outline_width: , outline_color: , font_context: , font_features: , base_direction: , font_direction: , font_script_name: , text_language: )
        函数 _migrate_deprecated_padding_xy(self: )
        函数 register(name: , fn_regular: , fn_italic: , fn_bold: , fn_bolditalic: )
          ```
          Register an alias for a Font.
          
          .. versionadded:: 1.1.0
          
          If you're using a ttf directly, you might not be able to use the
          bold/italic properties of
          the ttf version. If the font is delivered in multiple files
          (one regular, one italic and one bold), then you need to register these
          files and use the alias instead.
          
          All the fn_regular/fn_italic/fn_bold parameters are resolved with
          :func:`kivy.resources.resource_find`. If fn_italic/fn_bold are None,
          fn_regular will be used instead.
          ```
        函数 resolve_font_name(self: )
        函数 get_system_fonts_dir()
          ```
          Return the directories used by the system for fonts.
                  
          ```
        函数 get_extents(self: , text: )
          ```
          Return a tuple (width, height) indicating the size of the specified
          text
          ```
        函数 get_cached_extents(self: )
          ```
          Returns a cached version of the :meth:`get_extents` function.
          
          ::
          
              >>> func = self._get_cached_extents()
              >>> func
              <built-in method size of pygame.font.Font object at 0x01E45650>
              >>> func('a line')
              (36, 18)
          
          .. warning::
          
              This method returns a size measuring function that is valid
              for the font settings used at the time :meth:`get_cached_extents`
              was called. Any change in the font settings will render the
              returned function incorrect. You should only use this if you know
              what you're doing.
          
          .. versionadded:: 1.9.0
          ```
        函数 _render_begin(self: )
        函数 _render_text(self: , text: , x: , y: )
        函数 _render_end(self: )
        函数 shorten(self: , text: , margin: )
          ```
          Shortens the text to fit into a single line by the width specified
          by :attr:`text_size` [0]. If :attr:`text_size` [0] is None, it returns
          text text unchanged.
          
          :attr:`split_str` and :attr:`shorten_from` determines how the text is
          shortened.
          
          :params:
          
              `text` str, the text to be shortened.
              `margin` int, the amount of space to leave between the margins
              and the text. This is in addition to :attr:`padding_x`.
          
          :returns:
              the text shortened to fit into a single line.
          ```
        函数 _default_line_options(self: , lines: )
        函数 clear_texture(self: )
        函数 find_base_direction(text: )
          ```
          Searches a string the first character that has a strong direction,
          according to the Unicode bidirectional algorithm. Returns `None` if
          the base direction cannot be determined, or one of `'ltr'` or `'rtl'`.
          
          .. versionadded: 1.10.1
          
          .. note:: This feature requires the Pango text provider.
          ```
        函数 render_lines(self: , lines: , options: , render_text: , y: , size: )
        函数 _render_real(self: )
        函数 render(self: , real: )
          ```
          Return a tuple (width, height) to create the image
          with the user constraints. (width, height) includes the padding.
          ```
        函数 _texture_refresh(self: )
        函数 _texture_fill(self: , texture: )
        函数 refresh(self: )
          ```
          Force re-rendering of the text
                  
          ```
        函数 _get_text(self: )
        函数 _set_text(self: , text: )
        函数 texture_1px(self: )
        函数 size(self: )
        函数 width(self: )
        函数 height(self: )
        函数 content_width(self: )
          ```
          Return the content width; i.e. the width of the text without
          any padding.
          ```
        函数 content_height(self: )
          ```
          Return the content height; i.e. the height of the text without
          any padding.
          ```
        函数 content_size(self: )
          ```
          Return the content size (width, height)
          ```
        函数 fontid(self: )
          ```
          Return a unique id for all font parameters
          ```
        函数 _get_text_size(self: )
        函数 _set_text_size(self: , x: )
      类 FontContextManagerBase:
        基类: Name(id='object', ctx=Load())
        函数 create(font_context: )
          ```
          Create a font context, you must specify a unique name (string).
          Returns `True` on success and `False` on failure.
          
          If `font_context` starts with one of the reserved words `'system://'`,
          `'directory://'`, `'fontconfig://'` or `'systemconfig://'`, the context
          is setup accordingly (exact results of this depends on your platform,
          environment and configuration).
          
          * `'system://'` loads the default system's FontConfig configuration
            and all fonts (usually including user fonts).
          * `directory://` contexts preload a directory of font files (specified
            in the context name), `systemconfig://` loads the system's FontConfig
            configuration (but no fonts), and `fontconfig://` loads FontConfig
            configuration file (specified in the context name!). These are for
            advanced users only, check the source code and FontConfig
            documentation for details.
          * Fonts automatically loaded to an isolated context (ie when no
            font context was specified) start with `'isolated://'`. This has
            no special effect, and only serves to help you identify them in
            the results returned from :meth:`list`.
          * Any other string is a context that will only draw with the font
            file(s) you explicitly add to it.
          
          .. versionadded:: 1.11.0
          
          .. note::
              Font contexts are created automatically by specifying a name in the
              `font_context` property of :class:`kivy.uix.label.Label` or
              :class:`kivy.uix.textinput.TextInput`. They are also auto-created
              by :meth:`add_font` by default, so you normally don't need to
              call this directly.
          
          .. note:: This feature requires the Pango text provider.
          ```
        函数 exists(font_context: )
          ```
          Returns True if a font context with the given name exists.
          
          .. versionadded:: 1.11.0
          
          .. note:: This feature requires the Pango text provider.
          ```
        函数 destroy(font_context: )
          ```
          Destroy a named font context (if it exists)
          
          .. versionadded:: 1.11.0
          
          .. note:: This feature requires the Pango text provider.
          ```
        函数 list()
          ```
          Returns a list of `bytes` objects, each representing a cached font
          context name. Note that entries that start with `isolated://` were
          autocreated by loading a font file with no font_context specified.
          
          .. versionadded:: 1.11.0
          
          .. note:: This feature requires the Pango text provider.
          ```
        函数 list_families(font_context: )
          ```
          Returns a list of `bytes` objects, each representing a font family
          name that is available in the given `font_context`.
          
          .. versionadded:: 1.11.0
          
          .. note::
              Pango adds static "Serif", "Sans" and "Monospace" to the list in
              current versions, even if only a single custom font file is added
              to the context.
          
          .. note:: This feature requires the Pango text provider.
          ```
        函数 list_custom(font_context: )
          ```
          Returns a dictionary representing all the custom-loaded fonts in
          the context. The key is a `bytes` object representing the full path
          to the font file, the value is a `bytes` object representing the font
          family name used to request drawing with the font.
          
          .. versionadded:: 1.11.0
          
          .. note:: This feature requires the Pango text provider.
          ```
        函数 add_font(font_context: , filename: , autocreate: , family: )
          ```
          Add a font file to a named font context. If `autocreate` is true,
          the context will be created if it does not exist (this is the
          default). You can specify the `family` argument (string) to skip
          auto-detecting the font family name.
          
          .. warning::
          
              The `family` argument is slated for removal if the underlying
              implementation can be fixed, It is offered as a way to optimize
              startup time for deployed applications (it avoids opening the
              file with FreeType2 to determine its family name). To use this,
              first load the font file without specifying `family`, and
              hardcode the returned (autodetected) `family` value in your font
              context initialization.
          
          .. versionadded:: 1.11.0
          
          .. note:: This feature requires the Pango text provider.
          ```
    spelling/
      分析文件: spelling_osxappkit.py
      类 SpellingOSXAppKit:
        ```
        Spelling backend based on OSX's spelling features provided by AppKit.
        ```
        基类: Name(id='SpellingBase', ctx=Load())
        函数 __init__(self: , language: )
        函数 select_language(self: , language: )
        函数 list_languages(self: )
        函数 check(self: , word: )
        函数 suggest(self: , fragment: )
      分析文件: spelling_enchant.py
      类 SpellingEnchant:
        ```
        Spelling backend based on the enchant library.
        ```
        基类: Name(id='SpellingBase', ctx=Load())
        函数 __init__(self: , language: )
        函数 select_language(self: , language: )
        函数 list_languages(self: )
        函数 check(self: , word: )
        函数 suggest(self: , fragment: )
      分析文件: __init__.py
      类 NoSuchLangError:
        ```
        Exception to be raised when a specific language could not be found.
        ```
        基类: Name(id='Exception', ctx=Load())
      类 NoLanguageSelectedError:
        ```
        Exception to be raised when a language-using method is called but no
        language was selected prior to the call.
        ```
        基类: Name(id='Exception', ctx=Load())
      类 SpellingBase:
        ```
        Base class for all spelling providers.
        Supports some abstract methods for checking words and getting suggestions.
        ```
        基类: Name(id='object', ctx=Load())
        函数 __init__(self: , language: )
          ```
          If a `language` identifier (such as 'en_US') is provided and a matching
          language exists, it is selected. If an identifier is provided and no
          matching language exists, a NoSuchLangError exception is raised by
          self.select_language().
          If no `language` identifier is provided, we just fall back to the first
          one that is available.
          
          :Parameters:
              `language`: str, defaults to None
                  If provided, indicates the language to be used. This needs
                  to be a language identifier understood by select_language(),
                  i.e. one of the options returned by list_languages().
                  If nothing is provided, the first available language is used.
                  If no language is available, NoLanguageSelectedError is raised.
          ```
        函数 select_language(self: , language: )
          ```
          From the set of registered languages, select the first language
          for `language`.
          
          :Parameters:
              `language`: str
                  Language identifier. Needs to be one of the options returned by
                  list_languages(). Sets the language used for spell checking and
                  word suggestions.
          ```
        函数 list_languages(self: )
          ```
          Return a list of all supported languages.
          E.g. ['en', 'en_GB', 'en_US', 'de', ...]
          ```
        函数 check(self: , word: )
          ```
          If `word` is a valid word in `self._language` (the currently active
          language), returns True. If the word shouldn't be checked, returns
          None (e.g. for ''). If it is not a valid word in `self._language`,
          return False.
          
          :Parameters:
              `word`: str
                  The word to check.
          ```
        函数 suggest(self: , fragment: )
          ```
          For a given `fragment` (i.e. part of a word or a word by itself),
          provide corrections (`fragment` may be misspelled) or completions
          as a list of strings.
          
          :Parameters:
              `fragment`: str
                  The word fragment to get suggestions/corrections for.
                  E.g. 'foo' might become 'of', 'food' or 'foot'.
          ```
    video/
      分析文件: video_gstplayer.py
      函数 _on_gstplayer_buffer(video: , width: , height: , data: )
      函数 _on_gstplayer_message(mtype: , message: )
      类 VideoGstplayer:
        基类: Name(id='VideoBase', ctx=Load())
        函数 __init__(self: )
        函数 _on_gst_eos_sync(self: )
        函数 load(self: )
        函数 unload(self: )
        函数 stop(self: )
        函数 pause(self: )
        函数 play(self: )
        函数 seek(self: , percent: , precise: )
        函数 _get_position(self: )
        函数 _get_duration(self: )
        函数 _set_volume(self: , value: )
        函数 _update(self: , dt: )
        函数 _update_texture(self: , buf: )
        函数 _get_uri(self: )
      分析文件: video_null.py
      类 VideoNull:
        ```
        VideoBase implementation when there is no provider.
            
        ```
        基类: Name(id='VideoBase', ctx=Load())
      分析文件: video_ffpyplayer.py
      函数 _log_callback(message: , level: )
      类 VideoFFPy:
        基类: Name(id='VideoBase', ctx=Load())
        函数 __init__(self: )
        函数 _is_stream(self: )
        函数 __del__(self: )
        函数 _wakeup_thread(self: )
        函数 _wait_for_wakeup(self: , timeout: )
        函数 _player_callback(self: , selector: , value: )
        函数 _get_position(self: )
        函数 _set_position(self: , pos: )
        函数 _set_volume(self: , volume: )
        函数 _get_duration(self: )
        函数 _do_eos(self: )
        函数 _finish_setup(self: )
        函数 _redraw(self: )
        函数 _next_frame_run(self: , ffplayer: )
        函数 seek(self: , percent: , precise: )
        函数 stop(self: )
        函数 pause(self: )
        函数 play(self: )
        函数 load(self: )
        函数 unload(self: )
      函数 close()
      分析文件: video_ffmpeg.py
      类 VideoFFMpeg:
        基类: Name(id='VideoBase', ctx=Load())
        函数 __init__(self: )
        函数 unload(self: )
        函数 load(self: )
        函数 play(self: )
        函数 stop(self: )
        函数 seek(self: , percent: , precise: )
        函数 _do_eos(self: )
        函数 _update(self: , dt: )
        函数 _get_duration(self: )
        函数 _get_position(self: )
        函数 _set_volume(self: , value: )
      分析文件: __init__.py
      类 VideoBase:
        ```
        VideoBase, a class used to implement a video reader.
        
        :Parameters:
            `filename`: str
                Filename of the video. Can be a file or an URI.
            `eos`: str, defaults to 'pause'
                Action to take when EOS is hit. Can be one of 'pause', 'stop' or
                'loop'.
        
                .. versionchanged:: 1.4.0
                    added 'pause'
        
            `async`: bool, defaults to True
                Load the video asynchronously (may be not supported by all
                providers).
            `autoplay`: bool, defaults to False
                Auto play the video on init.
        
        :Events:
            `on_eos`
                Fired when EOS is hit.
            `on_load`
                Fired when the video is loaded and the texture is available.
            `on_frame`
                Fired when a new frame is written to the texture.
        ```
        基类: Name(id='EventDispatcher', ctx=Load())
        函数 __init__(self: )
        函数 __del__(self: )
        函数 on_eos(self: )
        函数 on_load(self: )
        函数 on_frame(self: )
        函数 _get_filename(self: )
        函数 _set_filename(self: , filename: )
        函数 _get_position(self: )
        函数 _set_position(self: , pos: )
        函数 _get_volume(self: )
        函数 _set_volume(self: , volume: )
        函数 _get_duration(self: )
        函数 _get_texture(self: )
        函数 _get_state(self: )
        函数 _do_eos(self: )
          ```
          .. versionchanged:: 1.4.0
              Now dispatches the `on_eos` event.
          ```
        函数 _update(self: , dt: )
          ```
          Update the video content to texture.
                  
          ```
        函数 seek(self: , percent: , precise: )
          ```
          Move to position as percentage (strictly, a proportion from
          0 - 1) of the duration
          ```
        函数 stop(self: )
          ```
          Stop the video playing
          ```
        函数 pause(self: )
          ```
          Pause the video
          
          .. versionadded:: 1.4.0
          ```
        函数 play(self: )
          ```
          Play the video
          ```
        函数 load(self: )
          ```
          Load the video from the current filename
          ```
        函数 unload(self: )
          ```
          Unload the actual video
          ```
    clipboard/
      分析文件: clipboard_gtk3.py
      类 ClipboardGtk3:
        基类: Name(id='ClipboardBase', ctx=Load())
        函数 init(self: )
        函数 get(self: , mimetype: )
        函数 put(self: , data: , mimetype: )
        函数 get_types(self: )
      分析文件: clipboard_android.py
      类 ClipboardAndroid:
        基类: Name(id='ClipboardBase', ctx=Load())
        函数 __init__(self: )
        函数 get(self: , mimetype: )
        函数 put(self: , data: , mimetype: )
        函数 get_types(self: )
        函数 _initialize_clipboard(self: )
        函数 _get_clipboard(f: )
        函数 _get(self: , mimetype: )
        函数 _set(self: , data: , mimetype: )
      函数 called()
      分析文件: clipboard_dummy.py
      类 ClipboardDummy:
        基类: Name(id='ClipboardBase', ctx=Load())
        函数 __init__(self: )
        函数 get(self: , mimetype: )
        函数 put(self: , data: , mimetype: )
        函数 get_types(self: )
      分析文件: clipboard_xclip.py
      类 ClipboardXclip:
        基类: Name(id='ClipboardExternalBase', ctx=Load())
        函数 _clip(inout: , selection: )
      分析文件: clipboard_sdl2.py
      类 ClipboardSDL2:
        基类: Name(id='ClipboardBase', ctx=Load())
        函数 get(self: , mimetype: )
        函数 _ensure_clipboard(self: )
        函数 put(self: , data: , mimetype: )
        函数 get_types(self: )
      分析文件: clipboard_winctypes.py
      类 ClipboardWindows:
        基类: Name(id='ClipboardBase', ctx=Load())
        函数 get(self: , mimetype: )
        函数 put(self: , text: , mimetype: )
        函数 get_types(self: )
      分析文件: clipboard_xsel.py
      类 ClipboardXsel:
        基类: Name(id='ClipboardExternalBase', ctx=Load())
        函数 _clip(inout: , selection: )
      分析文件: clipboard_dbusklipper.py
      类 ClipboardDbusKlipper:
        基类: Name(id='ClipboardBase', ctx=Load())
        函数 init(self: )
        函数 get(self: , mimetype: )
        函数 put(self: , data: , mimetype: )
        函数 get_types(self: )
      分析文件: _clipboard_ext.py
      类 ClipboardExternalBase:
        基类: Name(id='ClipboardBase', ctx=Load())
        函数 _clip(inout: , selection: )
        函数 get(self: , mimetype: )
        函数 put(self: , data: , mimetype: )
        函数 get_cutbuffer(self: )
        函数 set_cutbuffer(self: , data: )
        函数 get_types(self: )
      分析文件: clipboard_nspaste.py
      类 ClipboardNSPaste:
        基类: Name(id='ClipboardBase', ctx=Load())
        函数 __init__(self: )
        函数 get(self: , mimetype: )
        函数 put(self: , data: , mimetype: )
        函数 get_types(self: )
      分析文件: clipboard_pygame.py
      类 ClipboardPygame:
        基类: Name(id='ClipboardBase', ctx=Load())
        函数 __init__(self: )
        函数 init(self: )
        函数 get(self: , mimetype: )
        函数 put(self: , data: , mimetype: )
        函数 get_types(self: )
      分析文件: __init__.py
      类 ClipboardBase:
        基类: Name(id='object', ctx=Load())
        函数 get(self: , mimetype: )
          ```
          Get the current data in clipboard, using the mimetype if possible.
          You not use this method directly. Use :meth:`paste` instead.
          ```
        函数 put(self: , data: , mimetype: )
          ```
          Put data on the clipboard, and attach a mimetype.
          You should not use this method directly. Use :meth:`copy` instead.
          ```
        函数 get_types(self: )
          ```
          Return a list of supported mimetypes
                  
          ```
        函数 _ensure_clipboard(self: )
          ```
          Ensure that the clipboard has been properly initialised.
                  
          ```
        函数 copy(self: , data: )
          ```
          Copy the value provided in argument `data` into current clipboard.
          If data is not of type string it will be converted to string.
          
          .. versionadded:: 1.9.0
          ```
        函数 paste(self: )
          ```
          Get text from the system clipboard and return it a usable string.
          
          .. versionadded:: 1.9.0
          ```
        函数 _copy(self: , data: )
        函数 _paste(self: )
    camera/
      分析文件: camera_opencv.py
      类 CameraOpenCV:
        ```
        Implementation of CameraBase using OpenCV
        ```
        基类: Name(id='CameraBase', ctx=Load())
        函数 __init__(self: )
        函数 init_camera(self: )
        函数 _update(self: , dt: )
        函数 start(self: )
        函数 stop(self: )
      类 Hg:
        ```
        On OSX, not only are the import names different,
        but the API also differs.
        There is no module called 'highgui' but the names are
        directly available in the 'cv' module.
        Some of them even have a different names.
        
        Therefore we use this proxy object.
        ```
        基类: Name(id='object', ctx=Load())
        函数 __getattr__(self: , attr: )
      分析文件: camera_android.py
      类 PreviewCallback:
        ```
        Interface used to get back the preview frame of the Android Camera
        ```
        基类: Name(id='PythonJavaClass', ctx=Load())
        函数 __init__(self: , callback: )
        函数 onPreviewFrame(self: , data: , camera: )
      类 CameraAndroid:
        ```
        Implementation of CameraBase using Android API
        ```
        基类: Name(id='CameraBase', ctx=Load())
        函数 __del__(self: )
        函数 init_camera(self: )
        函数 _release_camera(self: )
        函数 _on_preview_frame(self: , data: , camera: )
        函数 _refresh_fbo(self: )
        函数 start(self: )
        函数 stop(self: )
        函数 _update(self: , dt: )
        函数 _copy_to_gpu(self: )
          ```
          A dummy placeholder (the image is already in GPU) to be consistent
          with other providers.
          ```
        函数 grab_frame(self: )
          ```
          Grab current frame (thread-safe, minimal overhead)
          ```
        函数 decode_frame(self: , buf: )
          ```
          Decode image data from grabbed frame.
          
          This method depends on OpenCV and NumPy - however it is only used for
          fetching the current frame as a NumPy array, and not required when
          this :class:`CameraAndroid` provider is simply used by a
          :class:`~kivy.uix.camera.Camera` widget.
          ```
        函数 read_frame(self: )
          ```
          Grab and decode frame in one call
          ```
        函数 get_camera_count()
          ```
          Get the number of available cameras.
          ```
      分析文件: camera_picamera.py
      类 CameraPiCamera:
        ```
        Implementation of CameraBase using PiCamera
            
        ```
        基类: Name(id='CameraBase', ctx=Load())
        函数 __init__(self: )
        函数 init_camera(self: )
        函数 raw_buffer_size(self: )
          ```
          Round buffer size up to 32x16 blocks.
          
          See https://picamera.readthedocs.io/en/release-1.13/recipes2.html#capturing-to-a-numpy-array
          ```
        函数 _update(self: , dt: )
        函数 start(self: )
        函数 stop(self: )
      分析文件: camera_gi.py
      类 _MapInfo:
        基类: Name(id='Structure', ctx=Load())
      函数 _on_cameragi_unref(obj: )
      类 CameraGi:
        ```
        Implementation of CameraBase using GStreamer
        
        :Parameters:
            `video_src`: str, default is 'v4l2src'
                Other tested options are: 'dc1394src' for firewire
                dc camera (e.g. firefly MV). Any gstreamer video source
                should potentially work.
                Theoretically a longer string using "!" can be used
                describing the first part of a gstreamer pipeline.
        ```
        基类: Name(id='CameraBase', ctx=Load())
        函数 __init__(self: )
        函数 init_camera(self: )
        函数 _gst_new_sample(self: )
        函数 start(self: )
        函数 stop(self: )
        函数 unload(self: )
        函数 _update(self: , dt: )
      函数 camera_gi_clean()
      分析文件: __init__.py
      类 CameraBase:
        ```
        Abstract Camera Widget class.
        
        Concrete camera classes must implement initialization and
        frame capturing to a buffer that can be uploaded to the gpu.
        
        :Parameters:
            `index`: int
                Source index of the camera.
            `size`: tuple (int, int)
                Size at which the image is drawn. If no size is specified,
                it defaults to the resolution of the camera image.
            `resolution`: tuple (int, int)
                Resolution to try to request from the camera.
                Used in the gstreamer pipeline by forcing the appsink caps
                to this resolution. If the camera doesn't support the resolution,
                a negotiation error might be thrown.
        
        :Events:
            `on_load`
                Fired when the camera is loaded and the texture has become
                available.
            `on_texture`
                Fired each time the camera texture is updated.
        ```
        基类: Name(id='EventDispatcher', ctx=Load())
        函数 __init__(self: )
        函数 _set_resolution(self: , res: )
        函数 _get_resolution(self: )
        函数 _set_index(self: , x: )
        函数 _get_index(self: )
        函数 _get_texture(self: )
        函数 init_camera(self: )
          ```
          Initialise the camera (internal)
          ```
        函数 start(self: )
          ```
          Start the camera acquire
          ```
        函数 stop(self: )
          ```
          Release the camera
          ```
        函数 _update(self: , dt: )
          ```
          Update the camera (internal)
          ```
        函数 _copy_to_gpu(self: )
          ```
          Copy the the buffer into the texture
          ```
        函数 on_texture(self: )
        函数 on_load(self: )
    gl/
      分析文件: __init__.py
      函数 msgbox(message: )
      函数 init_gl(allowed: , ignored: )
      函数 print_gl_version()
    audio/
      分析文件: audio_gstplayer.py
      函数 _on_gstplayer_message(mtype: , message: )
      类 SoundGstplayer:
        基类: Name(id='Sound', ctx=Load())
        函数 extensions()
        函数 __init__(self: )
        函数 _on_gst_eos_sync(self: )
        函数 _on_gst_eos(self: )
        函数 load(self: )
        函数 play(self: )
        函数 stop(self: )
        函数 unload(self: )
        函数 seek(self: , position: )
        函数 get_pos(self: )
        函数 _get_length(self: )
        函数 on_volume(self: , instance: , volume: )
        函数 _get_uri(self: )
      分析文件: audio_pygame.py
      类 SoundPygame:
        基类: Name(id='Sound', ctx=Load())
        函数 extensions()
        函数 __init__(self: )
        函数 _check_play(self: , dt: )
        函数 play(self: )
        函数 stop(self: )
        函数 load(self: )
        函数 unload(self: )
        函数 seek(self: , position: )
        函数 get_pos(self: )
        函数 on_volume(self: , instance: , volume: )
        函数 _get_length(self: )
      函数 do_loop(dt: )
      分析文件: audio_android.py
      类 OnCompletionListener:
        基类: Name(id='PythonJavaClass', ctx=Load())
        函数 __init__(self: , callback: )
        函数 onCompletion(self: , mp: )
      类 SoundAndroidPlayer:
        基类: Name(id='Sound', ctx=Load())
        函数 extensions()
        函数 load(self: )
        函数 unload(self: )
        函数 play(self: )
        函数 stop(self: )
        函数 seek(self: , position: )
        函数 get_pos(self: )
        函数 on_volume(self: , instance: , volume: )
        函数 _completion_callback(self: )
        函数 _get_length(self: )
        函数 on_loop(self: , instance: , loop: )
      分析文件: audio_ffpyplayer.py
      函数 _log_callback(message: , level: )
      类 SoundFFPy:
        基类: Name(id='Sound', ctx=Load())
        函数 extensions()
        函数 __init__(self: )
        函数 __del__(self: )
        函数 _player_callback(self: , selector: , value: )
        函数 load(self: )
        函数 unload(self: )
        函数 play(self: )
        函数 stop(self: )
        函数 seek(self: , position: )
        函数 get_pos(self: )
        函数 on_volume(self: , instance: , volume: )
        函数 _get_length(self: )
        函数 _do_eos(self: )
      函数 close()
      分析文件: audio_avplayer.py
      类 SoundAvplayer:
        基类: Name(id='Sound', ctx=Load())
        函数 extensions()
        函数 __init__(self: )
        函数 load(self: )
        函数 unload(self: )
        函数 play(self: )
        函数 stop(self: )
        函数 seek(self: , position: )
        函数 get_pos(self: )
        函数 on_volume(self: , instance: , volume: )
        函数 _get_length(self: )
      分析文件: __init__.py
      类 SoundLoader:
        ```
        Load a sound, using the best loader for the given file type.
            
        ```
        函数 register(classobj: )
          ```
          Register a new class to load the sound.
          ```
        函数 load(filename: )
          ```
          Load a sound, and return a Sound() instance.
          ```
      类 Sound:
        ```
        Represents a sound to play. This class is abstract, and cannot be used
        directly.
        
        Use SoundLoader to load a sound.
        
        :Events:
            `on_play`: None
                Fired when the sound is played.
            `on_stop`: None
                Fired when the sound is stopped.
        ```
        基类: Name(id='EventDispatcher', ctx=Load())
        函数 _get_status(self: )
        函数 _get_filename(self: )
        函数 on_source(self: , instance: , filename: )
        函数 get_pos(self: )
          ```
          Returns the current position of the audio file.
          Returns 0 if not playing.
          
          .. versionadded:: 1.4.1
          ```
        函数 _get_length(self: )
        函数 unload(self: )
          ```
          Unload the file from memory.
          ```
        函数 play(self: )
          ```
          Play the file.
          ```
        函数 stop(self: )
          ```
          Stop playback.
          ```
        函数 seek(self: , position: )
          ```
          Go to the <position> (in seconds).
          
          .. note::
              Most sound providers cannot seek when the audio is stopped.
              Play then seek.
          ```
        函数 on_play(self: )
        函数 on_stop(self: )
    window/
      分析文件: window_sdl2.py
      类 SDL2MotionEvent:
        基类: Name(id='MotionEvent', ctx=Load())
        函数 __init__(self: )
        函数 depack(self: , args: )
      类 SDL2MotionEventProvider:
        基类: Name(id='MotionEventProvider', ctx=Load())
        函数 update(self: , dispatch_fn: )
      类 WindowSDL:
        基类: Name(id='WindowBase', ctx=Load())
        函数 get_window_info(self: )
        函数 _set_minimum_size(self: )
        函数 _set_always_on_top(self: )
        函数 _set_allow_screensaver(self: )
        函数 _event_filter(self: , action: )
        函数 create_window(self: )
        函数 _update_density_and_dpi(self: )
        函数 close(self: )
        函数 maximize(self: )
        函数 minimize(self: )
        函数 restore(self: )
        函数 hide(self: )
        函数 show(self: )
        函数 raise_window(self: )
        函数 toggle_fullscreen(self: )
        函数 set_title(self: , title: )
        函数 set_icon(self: , filename: )
        函数 screenshot(self: )
        函数 flip(self: )
        函数 set_system_cursor(self: , cursor_name: )
        函数 _get_window_pos(self: )
        函数 _set_window_pos(self: , x: , y: )
        函数 _is_shaped(self: )
        函数 _set_shape(self: , shape_image: , mode: , cutoff: , color_key: )
        函数 _get_shaped_mode(self: )
        函数 _set_shaped_mode(self: , value: )
        函数 _set_cursor_state(self: , value: )
        函数 _fix_mouse_pos(self: , x: , y: )
        函数 mainloop(self: )
        函数 _dispatch_drop_event(self: , action: , args: )
        函数 _collide_and_dispatch_cursor_enter(self: , x: , y: )
        函数 _do_resize(self: , dt: )
        函数 do_pause(self: )
        函数 _update_modifiers(self: , mods: , key: )
        函数 request_keyboard(self: , callback: , target: , input_type: , keyboard_suggestions: )
        函数 release_keyboard(self: )
        函数 _check_keyboard_shown(self: , dt: )
        函数 map_key(self: , original_key: , new_key: )
        函数 unmap_key(self: , key: )
        函数 grab_mouse(self: )
        函数 ungrab_mouse(self: )
        函数 set_custom_titlebar(self: , titlebar_widget: )
      类 _WindowsSysDPIWatch:
        函数 start(self: )
        函数 stop(self: )
        函数 _wnd_proc(self: , hwnd: , msg: , wParam: , lParam: )
      函数 clock_callback()
      分析文件: window_egl_rpi.py
      类 WindowEglRpi:
        基类: Name(id='WindowBase', ctx=Load())
        函数 create_window(self: )
        函数 _create_window(self: , w: , h: )
        函数 _create_egl_context(self: , win: , flags: )
        函数 close(self: )
        函数 flip(self: )
      分析文件: window_pygame.py
      类 WindowPygame:
        基类: Name(id='WindowBase', ctx=Load())
        函数 __init__(self: )
        函数 create_window(self: )
        函数 close(self: )
        函数 on_title(self: , instance: , value: )
        函数 set_icon(self: , filename: )
        函数 _set_icon_standard(self: , filename: )
        函数 _set_icon_win(self: , filename: )
        函数 _set_cursor_state(self: , value: )
        函数 screenshot(self: )
        函数 flip(self: )
        函数 toggle_fullscreen(self: )
        函数 mainloop(self: )
        函数 _pygame_set_mode(self: , size: )
        函数 _pygame_update_modifiers(self: , mods: )
        函数 request_keyboard(self: , callback: , target: , input_type: , keyboard_suggestions: )
        函数 release_keyboard(self: )
      分析文件: __init__.py
      类 Keyboard:
        ```
        Keyboard interface that is returned by
        :meth:`WindowBase.request_keyboard`. When you request a keyboard,
        you'll get an instance of this class. Whatever the keyboard input is
        (system or virtual keyboard), you'll receive events through this
        instance.
        
        :Events:
            `on_key_down`: keycode, text, modifiers
                Fired when a new key is pressed down
            `on_key_up`: keycode
                Fired when a key is released (up)
        
        Here is an example of how to request a Keyboard in accordance with the
        current configuration:
        
        .. include:: ../../examples/widgets/keyboardlistener.py
            :literal:
        ```
        基类: Name(id='EventDispatcher', ctx=Load())
        函数 __init__(self: )
        函数 on_key_down(self: , keycode: , text: , modifiers: )
        函数 on_key_up(self: , keycode: )
        函数 on_textinput(self: , text: )
        函数 release(self: )
          ```
          Call this method to release the current keyboard.
          This will ensure that the keyboard is no longer attached to your
          callback.
          ```
        函数 _on_window_textinput(self: , instance: , text: )
        函数 _on_window_key_down(self: , instance: , keycode: , scancode: , text: , modifiers: )
        函数 _on_window_key_up(self: , instance: , keycode: )
        函数 _on_vkeyboard_key_down(self: , instance: , keycode: , text: , modifiers: )
        函数 _on_vkeyboard_key_up(self: , instance: , keycode: , text: , modifiers: )
        函数 _on_vkeyboard_textinput(self: , instance: , text: )
        函数 string_to_keycode(self: , value: )
          ```
          Convert a string to a keycode number according to the
          :attr:`Keyboard.keycodes`. If the value is not found in the
          keycodes, it will return -1.
          ```
        函数 keycode_to_string(self: , value: )
          ```
          Convert a keycode number to a string according to the
          :attr:`Keyboard.keycodes`. If the value is not found in the
          keycodes, it will return ''.
          ```
      类 WindowBase:
        ```
        WindowBase is an abstract window widget for any window implementation.
        
        :Parameters:
            `borderless`: str, one of ('0', '1')
                Set the window border state. Check the
                :mod:`~kivy.config` documentation for a
                more detailed explanation on the values.
            `custom_titlebar`: str, one of ('0', '1')
                Set to `'1'` to uses a custom titlebar
            `fullscreen`: str, one of ('0', '1', 'auto', 'fake')
                Make the window fullscreen. Check the
                :mod:`~kivy.config` documentation for a
                more detailed explanation on the values.
            `width`: int
                Width of the window.
            `height`: int
                Height of the window.
            `minimum_width`: int
                Minimum width of the window (only works for sdl2 window provider).
            `minimum_height`: int
                Minimum height of the window (only works for sdl2 window provider).
            `always_on_top`: bool
                When enabled, the window will be brought to the front and will keep
                the window above the rest. If disabled, it will restore the default
                behavior. Only works for the sdl2 window provider.
            `allow_screensaver`: bool
                Allow the device to show a screen saver, or to go to sleep
                on mobile devices. Defaults to True. Only works for sdl2 window
                provider.
        
        :Events:
            `on_motion`: etype, motionevent
                Fired when a new :class:`~kivy.input.motionevent.MotionEvent` is
                dispatched
            `on_touch_down`:
                Fired when a new touch event is initiated.
            `on_touch_move`:
                Fired when an existing touch event changes location.
            `on_touch_up`:
                Fired when an existing touch event is terminated.
            `on_draw`:
                Fired when the :class:`Window` is being drawn.
            `on_flip`:
                Fired when the :class:`Window` GL surface is being flipped.
            `on_rotate`: rotation
                Fired when the :class:`Window` is being rotated.
            `on_close`:
                Fired when the :class:`Window` is closed.
            `on_request_close`:
                Fired when the event loop wants to close the window, or if the
                escape key is pressed and `exit_on_escape` is `True`. If a function
                bound to this event returns `True`, the window will not be closed.
                If the the event is triggered because of the keyboard escape key,
                the keyword argument `source` is dispatched along with a value of
                `keyboard` to the bound functions.
        
                .. versionadded:: 1.9.0
        
            `on_cursor_enter`:
                Fired when the cursor enters the window.
        
                .. versionadded:: 1.9.1
        
            `on_cursor_leave`:
                Fired when the cursor leaves the window.
        
                .. versionadded:: 1.9.1
        
            `on_minimize`:
                Fired when the window is minimized.
        
                .. versionadded:: 1.10.0
        
            `on_maximize`:
                Fired when the window is maximized.
        
                .. versionadded:: 1.10.0
        
            `on_restore`:
                Fired when the window is restored.
        
                .. versionadded:: 1.10.0
        
            `on_hide`:
                Fired when the window is hidden.
        
                .. versionadded:: 1.10.0
        
            `on_show`:
                Fired when when the window is shown.
        
                .. versionadded:: 1.10.0
        
            `on_keyboard`: key, scancode, codepoint, modifier
                Fired when the keyboard is used for input.
        
                .. versionchanged:: 1.3.0
                    The *unicode* parameter has been deprecated in favor of
                    codepoint, and will be removed completely in future versions.
        
            `on_key_down`: key, scancode, codepoint, modifier
                Fired when a key pressed.
        
                .. versionchanged:: 1.3.0
                    The *unicode* parameter has been deprecated in favor of
                    codepoint, and will be removed completely in future versions.
        
            `on_key_up`: key, scancode, codepoint
                Fired when a key is released.
        
                .. versionchanged:: 1.3.0
                    The *unicode* parameter has be deprecated in favor of
                    codepoint, and will be removed completely in future versions.
        
            `on_drop_begin`: x, y, *args
                Fired when text(s) or file(s) drop on the application is about to
                begin.
        
                .. versionadded:: 2.1.0
        
            `on_drop_file`: filename (bytes), x, y, *args
                Fired when a file is dropped on the application.
        
                .. versionadded:: 1.2.0
        
                .. versionchanged:: 2.1.0
                    Renamed from `on_dropfile` to `on_drop_file`.
        
            `on_drop_text`: text (bytes), x, y, *args
                Fired when a text is dropped on the application.
        
                .. versionadded:: 2.1.0
        
            `on_drop_end`: x, y, *args
                Fired when text(s) or file(s) drop on the application has ended.
        
                .. versionadded:: 2.1.0
        
            `on_memorywarning`:
                Fired when the platform have memory issue (iOS / Android mostly)
                You can listen to this one, and clean whatever you can.
        
                .. versionadded:: 1.9.0
        
            `on_textedit(self, text)`:
                Fired when inputting with IME.
                The string inputting with IME is set as the parameter of
                this event.
        
                .. versionadded:: 1.10.1
        ```
        基类: Name(id='EventDispatcher', ctx=Load())
        函数 _get_modifiers(self: )
        函数 _get_size(self: )
        函数 _set_size(self: , size: )
        函数 _get_width(self: )
        函数 _get_height(self: )
          ```
          Rotated window height
          ```
        函数 _get_center(self: )
        函数 _get_rotation(self: )
        函数 _set_rotation(self: , x: )
        函数 _free_kanimation(self: )
        函数 _animate_content(self: )
          ```
          Animate content to IME height.
                  
          ```
        函数 _upd_kbd_height(self: )
        函数 _get_ios_kheight(self: )
        函数 _get_android_kheight(self: )
        函数 _get_kivy_vkheight(self: )
        函数 _get_kheight(self: )
        函数 _set_system_size(self: , size: )
        函数 _get_system_size(self: )
        函数 _get_effective_size(self: )
          ```
          On density=1 and non-ios / non-Windows displays,
          return :attr:`system_size`, else return scaled / rotated :attr:`size`.
          
          Used by MouseMotionEvent.update_graphics() and WindowBase.on_motion().
          ```
        函数 _get_focus(self: )
        函数 _set_cursor_state(self: , value: )
        函数 set_system_cursor(self: , cursor_name: )
          ```
          Set type of a mouse cursor in the Window.
          
          It can be one of 'arrow', 'ibeam', 'wait', 'crosshair', 'wait_arrow',
          'size_nwse', 'size_nesw', 'size_we', 'size_ns', 'size_all', 'no', or
          'hand'.
          
          On some platforms there might not be a specific cursor supported and
          such an option falls back to one of the substitutable alternatives:
          
          +------------+-----------+------------+-----------+---------------+
          |            | Windows   | MacOS      | Linux X11 | Linux Wayland |
          +============+===========+============+===========+===============+
          | arrow      | arrow     | arrow      | arrow     | arrow         |
          +------------+-----------+------------+-----------+---------------+
          | ibeam      | ibeam     | ibeam      | ibeam     | ibeam         |
          +------------+-----------+------------+-----------+---------------+
          | wait       | wait      | arrow      | wait      | wait          |
          +------------+-----------+------------+-----------+---------------+
          | crosshair  | crosshair | crosshair  | crosshair | hand          |
          +------------+-----------+------------+-----------+---------------+
          | wait_arrow | arrow     | arrow      | wait      | wait          |
          +------------+-----------+------------+-----------+---------------+
          | size_nwse  | size_nwse | size_all   | size_all  | hand          |
          +------------+-----------+------------+-----------+---------------+
          | size_nesw  | size_nesw | size_all   | size_all  | hand          |
          +------------+-----------+------------+-----------+---------------+
          | size_we    | size_we   | size_we    | size_we   | hand          |
          +------------+-----------+------------+-----------+---------------+
          | size_ns    | size_ns   | size_ns    | size_ns   | hand          |
          +------------+-----------+------------+-----------+---------------+
          | size_all   | size_all  | size_all   | size_all  | hand          |
          +------------+-----------+------------+-----------+---------------+
          | no         | no        | no         | no        | ibeam         |
          +------------+-----------+------------+-----------+---------------+
          | hand       | hand      | hand       | hand      | hand          |
          +------------+-----------+------------+-----------+---------------+
          
          .. versionadded:: 1.10.1
          
          .. note::
              This feature requires the SDL2 window provider and is currently
              only supported on desktop platforms.
          ```
        函数 _get_window_pos(self: )
        函数 _set_window_pos(self: , x: , y: )
        函数 _get_left(self: )
        函数 _set_left(self: , value: )
        函数 _get_top(self: )
        函数 _set_top(self: , value: )
        函数 __self__(self: )
        函数 __new__(cls: )
        函数 _reset_metrics_dpi(self: )
        函数 _bind_create_window(self: )
        函数 _unbind_create_window(self: )
        函数 register(self: )
        函数 register_event_manager(self: , manager: )
          ```
          Register and start an event manager to handle events declared in
          :attr:`~kivy.eventmanager.EventManagerBase.type_ids` attribute.
          
          .. versionadded:: 2.1.0
          
          .. warning::
              This is an experimental method and it remains so until this warning
              is present as it can be changed or removed in the next versions of
              Kivy.
          ```
        函数 unregister_event_manager(self: , manager: )
          ```
          Unregister and stop an event manager previously registered with
          :meth:`register_event_manager`.
          
          .. versionadded:: 2.1.0
          
          .. warning::
              This is an experimental method and it remains so until this warning
              is present as it can be changed or removed in the next versions of
              Kivy.
          ```
        函数 mainloop(self: )
          ```
          Called by the EventLoop every frame after it idles.
                  
          ```
        函数 toggle_fullscreen(self: )
          ```
          Toggle between fullscreen and windowed mode.
          
          .. deprecated:: 1.9.0
              Use :attr:`fullscreen` instead.
          ```
        函数 maximize(self: )
          ```
          Maximizes the window. This method should be used on desktop
          platforms only.
          
          .. versionadded:: 1.9.0
          
          .. note::
              This feature requires the SDL2 window provider and is currently
              only supported on desktop platforms.
          ```
        函数 minimize(self: )
          ```
          Minimizes the window. This method should be used on desktop
          platforms only.
          
          .. versionadded:: 1.9.0
          
          .. note::
              This feature requires the SDL2 window provider and is currently
              only supported on desktop platforms.
          ```
        函数 restore(self: )
          ```
          Restores the size and position of a maximized or minimized window.
          This method should be used on desktop platforms only.
          
          .. versionadded:: 1.9.0
          
          .. note::
              This feature requires the SDL2 window provider and is currently
              only supported on desktop platforms.
          ```
        函数 hide(self: )
          ```
          Hides the window. This method should be used on desktop
          platforms only.
          
          .. versionadded:: 1.9.0
          
          .. note::
              This feature requires the SDL2 window provider and is currently
              only supported on desktop platforms.
          ```
        函数 show(self: )
          ```
          Shows the window. This method should be used on desktop
          platforms only.
          
          .. versionadded:: 1.9.0
          
          .. note::
              This feature requires the SDL2 window provider and is currently
              only supported on desktop platforms.
          ```
        函数 raise_window(self: )
          ```
          Raise the window. This method should be used on desktop
          platforms only.
          
          .. versionadded:: 1.9.1
          
          .. note::
              This feature requires the SDL2 window provider and is currently
              only supported on desktop platforms.
          ```
        函数 close(self: )
          ```
          Close the window
          ```
        函数 set_custom_titlebar(self: , widget: )
          ```
          Sets a Widget as a titlebar
          
              :widget: The widget you want to set as the titlebar
          
          .. versionadded:: 2.1.0
          
          This function returns `True` on successfully setting the custom titlebar,
          else false
          
          How to use this feature
          
          ::
          
              1. first set Window.custom_titlebar to True
              2. then call Window.set_custom_titlebar with the widget/layout you want to set as titlebar as the argument # noqa: E501
          
          If you want a child of the widget to receive touch events, in
          that child define a property `draggable` and set it to False
          
          If you set the property `draggable` on a layout,
          all the child in the layout will receive touch events
          
          If you want to override default behaviour, add function `in_drag_area(x,y)`
          to the widget
          
          The function is call with two args x,y which are mouse.x, and mouse.y
          the function should return
          
          | `True` if that point should be used to drag the window
          | `False` if you want to receive the touch event at the point
          
          .. note::
              If you use :meth:`in_drag_area` property `draggable`
              will not be checked
          
          .. note::
              This feature requires the SDL2 window provider and is currently
              only supported on desktop platforms.
          
          .. warning::
              :mod:`~kivy.core.window.WindowBase.custom_titlebar` must be set to True
              for the widget to be successfully set as a titlebar
          ```
        函数 on_shape_image(self: , instance: , value: )
        函数 on_shape_cutoff(self: , instance: , value: )
        函数 _get_shaped(self: )
        函数 _get_shape_mode(self: )
        函数 _set_shape_mode(self: , value: )
        函数 on_shape_color_key(self: , instance: , value: )
        函数 get_gl_backend_name(self: )
          ```
          Returns the gl backend that will or is used with this window.
          ```
        函数 initialize_gl(self: )
        函数 create_window(self: )
          ```
          Will create the main window and configure it.
          
          .. warning::
              This method is called automatically at runtime. If you call it, it
              will recreate a RenderContext and Canvas. This means you'll have a
              new graphics tree, and the old one will be unusable.
          
              This method exist to permit the creation of a new OpenGL context
              AFTER closing the first one. (Like using runTouchApp() and
              stopTouchApp()).
          
              This method has only been tested in a unittest environment and
              is not suitable for Applications.
          
              Again, don't use this method unless you know exactly what you are
              doing!
          ```
        函数 on_flip(self: )
          ```
          Flip between buffers (event)
          ```
        函数 flip(self: )
          ```
          Flip between buffers
          ```
        函数 _update_childsize(self: , instance: , value: )
        函数 add_widget(self: , widget: , canvas: )
          ```
          Add a widget to a window
          ```
        函数 remove_widget(self: , widget: )
          ```
          Remove a widget from a window
                  
          ```
        函数 clear(self: )
          ```
          Clear the window with the background color
          ```
        函数 set_title(self: , title: )
          ```
          Set the window title.
          
          .. versionadded:: 1.0.5
          ```
        函数 set_icon(self: , filename: )
          ```
          Set the icon of the window.
          
          .. versionadded:: 1.0.5
          ```
        函数 to_widget(self: , x: , y: , initial: , relative: )
        函数 to_window(self: , x: , y: , initial: , relative: )
        函数 to_normalized_pos(self: , x: , y: )
          ```
          Transforms absolute coordinates to normalized (0-1) coordinates
          using :attr:`system_size`.
          
          .. versionadded:: 2.1.0
          ```
        函数 transform_motion_event_2d(self: , me: , widget: )
          ```
          Transforms the motion event `me` to this window size and then if
          `widget` is passed transforms `me` to `widget`'s local coordinates.
          
          :raises:
              `AttributeError`: If widget's ancestor is ``None``.
          
          .. note::
              Unless it's a specific case, call
              :meth:`~kivy.input.motionevent.MotionEvent.push` before and
              :meth:`~kivy.input.motionevent.MotionEvent.pop` after this method's
              call to preserve previous values of `me`'s attributes.
          
          .. versionadded:: 2.1.0
          ```
        函数 _apply_transform(self: , m: )
        函数 get_window_matrix(self: , x: , y: )
        函数 get_root_window(self: )
        函数 get_parent_window(self: )
        函数 get_parent_layout(self: )
        函数 on_draw(self: )
        函数 on_motion(self: , etype: , me: )
          ```
          Event called when a motion event is received.
          
          :Parameters:
              `etype`: str
                  One of "begin", "update" or "end".
              `me`: :class:`~kivy.input.motionevent.MotionEvent`
                  The motion event currently dispatched.
          
          .. versionchanged:: 2.1.0
              Event managers get to handle the touch event first and if none of
              them accepts the event (by returning `True`) then window will
              dispatch `me` through "on_touch_down", "on_touch_move",
              "on_touch_up" events depending on the `etype`. All non-touch events
              will go only through managers.
          ```
        函数 on_touch_down(self: , touch: )
          ```
          Event called when a touch down event is initiated.
          
          .. versionchanged:: 1.9.0
              The touch `pos` is now transformed to window coordinates before
              this method is called. Before, the touch `pos` coordinate would be
              `(0, 0)` when this method was called.
          ```
        函数 on_touch_move(self: , touch: )
          ```
          Event called when a touch event moves (changes location).
          
          .. versionchanged:: 1.9.0
              The touch `pos` is now transformed to window coordinates before
              this method is called. Before, the touch `pos` coordinate would be
              `(0, 0)` when this method was called.
          ```
        函数 on_touch_up(self: , touch: )
          ```
          Event called when a touch event is released (terminated).
          
          .. versionchanged:: 1.9.0
              The touch `pos` is now transformed to window coordinates before
              this method is called. Before, the touch `pos` coordinate would be
              `(0, 0)` when this method was called.
          ```
        函数 on_pre_resize(self: , width: , height: )
        函数 on_resize(self: , width: , height: )
          ```
          Event called when the window is resized.
          ```
        函数 on_move(self: )
        函数 update_viewport(self: )
        函数 update_childsize(self: , childs: )
        函数 screenshot(self: , name: )
          ```
          Save the actual displayed image to a file.
                  
          ```
        函数 on_rotate(self: , rotation: )
          ```
          Event called when the screen has been rotated.
                  
          ```
        函数 on_close(self: )
          ```
          Event called when the window is closed.
          ```
        函数 on_minimize(self: )
          ```
          Event called when the window is minimized.
          
          .. versionadded:: 1.10.0
          
          .. note::
              This feature requires the SDL2 window provider.
          ```
        函数 on_maximize(self: )
          ```
          Event called when the window is maximized.
          
          .. versionadded:: 1.10.0
          
          .. note::
              This feature requires the SDL2 window provider.
          ```
        函数 on_restore(self: )
          ```
          Event called when the window is restored.
          
          .. versionadded:: 1.10.0
          
          .. note::
              This feature requires the SDL2 window provider.
          ```
        函数 on_hide(self: )
          ```
          Event called when the window is hidden.
          
          .. versionadded:: 1.10.0
          
          .. note::
              This feature requires the SDL2 window provider.
          ```
        函数 on_show(self: )
          ```
          Event called when the window is shown.
          
          .. versionadded:: 1.10.0
          
          .. note::
              This feature requires the SDL2 window provider.
          ```
        函数 on_request_close(self: )
          ```
          Event called before we close the window. If a bound function returns
          `True`, the window will not be closed. If the the event is triggered
          because of the keyboard escape key, the keyword argument `source` is
          dispatched along with a value of `keyboard` to the bound functions.
          
          .. warning::
              When the bound function returns True the window will not be closed,
              so use with care because the user would not be able to close the
              program, even if the red X is clicked.
          ```
        函数 on_cursor_enter(self: )
          ```
          Event called when the cursor enters the window.
          
          .. versionadded:: 1.9.1
          
          .. note::
              This feature requires the SDL2 window provider.
          ```
        函数 on_cursor_leave(self: )
          ```
          Event called when the cursor leaves the window.
          
          .. versionadded:: 1.9.1
          
          .. note::
              This feature requires the SDL2 window provider.
          ```
        函数 on_mouse_down(self: , x: , y: , button: , modifiers: )
          ```
          Event called when the mouse is used (pressed/released).
          ```
        函数 on_mouse_move(self: , x: , y: , modifiers: )
          ```
          Event called when the mouse is moved with buttons pressed.
          ```
        函数 on_mouse_up(self: , x: , y: , button: , modifiers: )
          ```
          Event called when the mouse is moved with buttons pressed.
          ```
        函数 on_joy_axis(self: , stickid: , axisid: , value: )
          ```
          Event called when a joystick has a stick or other axis moved.
          
          .. versionadded:: 1.9.0
          ```
        函数 on_joy_hat(self: , stickid: , hatid: , value: )
          ```
          Event called when a joystick has a hat/dpad moved.
          
          .. versionadded:: 1.9.0
          ```
        函数 on_joy_ball(self: , stickid: , ballid: , xvalue: , yvalue: )
          ```
          Event called when a joystick has a ball moved.
          
          .. versionadded:: 1.9.0
          ```
        函数 on_joy_button_down(self: , stickid: , buttonid: )
          ```
          Event called when a joystick has a button pressed.
          
          .. versionadded:: 1.9.0
          ```
        函数 on_joy_button_up(self: , stickid: , buttonid: )
          ```
          Event called when a joystick has a button released.
          
          .. versionadded:: 1.9.0
          ```
        函数 on_keyboard(self: , key: , scancode: , codepoint: , modifier: )
          ```
          Event called when keyboard is used.
          
          .. warning::
              Some providers may omit `scancode`, `codepoint` and/or `modifier`.
          ```
        函数 on_drop_begin(self: , x: , y: )
          ```
          Event called when a text or a file drop on the application is about
          to begin. It will be followed-up by a single or a multiple
          `on_drop_text` or `on_drop_file` events ending with an `on_drop_end`
          event.
          
          Arguments `x` and `y` are the mouse cursor position at the time of the
          drop and you should only rely on them if the drop originated from the
          mouse.
          
          :Parameters:
              `x`: `int`
                  Cursor x position, relative to the window :attr:`left`, at the
                  time of the drop.
              `y`: `int`
                  Cursor y position, relative to the window :attr:`top`, at the
                  time of the drop.
              `*args`: `tuple`
                  Additional arguments.
          
          .. note::
              This event works with sdl2 window provider.
          
          .. versionadded:: 2.1.0
          ```
        函数 on_drop_file(self: , filename: , x: , y: )
          ```
          Event called when a file is dropped on the application.
          
          Arguments `x` and `y` are the mouse cursor position at the time of the
          drop and you should only rely on them if the drop originated from the
          mouse.
          
          :Parameters:
              `filename`: `bytes`
                  Absolute path to a dropped file.
              `x`: `int`
                  Cursor x position, relative to the window :attr:`left`, at the
                  time of the drop.
              `y`: `int`
                  Cursor y position, relative to the window :attr:`top`, at the
                  time of the drop.
              `*args`: `tuple`
                  Additional arguments.
          
          .. warning::
              This event currently works with sdl2 window provider, on pygame
              window provider and OS X with a patched version of pygame.
              This event is left in place for further evolution
              (ios, android etc.)
          
          .. note::
              On Windows it is possible to drop a file on the window title bar
              or on its edges and for that case :attr:`mouse_pos` won't be
              updated as the mouse cursor is not within the window.
          
          .. note::
              This event doesn't work for apps with elevated permissions,
              because the OS API calls are filtered. Check issue
              `#4999 <https://github.com/kivy/kivy/issues/4999>`_ for
              pointers to workarounds.
          
          .. versionadded:: 1.2.0
          
          .. versionchanged:: 2.1.0
              Renamed from `on_dropfile` to `on_drop_file`.
          ```
        函数 on_dropfile(self: , filename: )
        函数 on_drop_text(self: , text: , x: , y: )
          ```
          Event called when a text is dropped on the application.
          
          Arguments `x` and `y` are the mouse cursor position at the time of the
          drop and you should only rely on them if the drop originated from the
          mouse.
          
          :Parameters:
              `text`: `bytes`
                  Text which is dropped.
              `x`: `int`
                  Cursor x position, relative to the window :attr:`left`, at the
                  time of the drop.
              `y`: `int`
                  Cursor y position, relative to the window :attr:`top`, at the
                  time of the drop.
              `*args`: `tuple`
                  Additional arguments.
          
          .. note::
              This event works with sdl2 window provider on x11 window.
          
          .. note::
              On Windows it is possible to drop a text on the window title bar
              or on its edges and for that case :attr:`mouse_pos` won't be
              updated as the mouse cursor is not within the window.
          
          .. versionadded:: 2.1.0
          ```
        函数 on_drop_end(self: , x: , y: )
          ```
          Event called when a text or a file drop on the application has
          ended.
          
          Arguments `x` and `y` are the mouse cursor position at the time of the
          drop and you should only rely on them if the drop originated from the
          mouse.
          
          :Parameters:
              `x`: `int`
                  Cursor x position, relative to the window :attr:`left`, at the
                  time of the drop.
              `y`: `int`
                  Cursor y position, relative to the window :attr:`top`, at the
                  time of the drop.
              `*args`: `tuple`
                  Additional arguments.
          
          .. note::
              This event works with sdl2 window provider.
          
          .. versionadded:: 2.1.0
          ```
        函数 on_memorywarning(self: )
          ```
          Event called when the platform have memory issue.
          Your goal is to clear the cache in your app as much as you can,
          release unused widgets, do garbage collection etc.
          
          Currently, this event is fired only from the SDL2 provider, for
          iOS and Android.
          
          .. versionadded:: 1.9.0
          ```
        函数 on_textedit(self: , text: )
          ```
          Event called when inputting with IME.
          The string inputting with IME is set as the parameter of
          this event.
          
          .. versionadded:: 1.10.1
          ```
        函数 configure_keyboards(self: )
        函数 set_vkeyboard_class(self: , cls: )
          ```
          .. versionadded:: 1.0.8
          
          Set the VKeyboard class to use. If set to `None`, it will use the
          :class:`kivy.uix.vkeyboard.VKeyboard`.
          ```
        函数 release_all_keyboards(self: )
          ```
          .. versionadded:: 1.0.8
          
          This will ensure that no virtual keyboard / system keyboard is
          requested. All instances will be closed.
          ```
        函数 request_keyboard(self: , callback: , target: , input_type: , keyboard_suggestions: )
          ```
          .. versionadded:: 1.0.4
          
          Internal widget method to request the keyboard. This method is rarely
          required by the end-user as it is handled automatically by the
          :class:`~kivy.uix.textinput.TextInput`. We expose it in case you want
          to handle the keyboard manually for unique input scenarios.
          
          A widget can request the keyboard, indicating a callback to call
          when the keyboard is released (or taken by another widget).
          
          :Parameters:
              `callback`: func
                  Callback that will be called when the keyboard is
                  closed. This can be because somebody else requested the
                  keyboard or the user closed it.
              `target`: Widget
                  Attach the keyboard to the specified `target`. This should be
                  the widget that requested the keyboard. Ensure you have a
                  different target attached to each keyboard if you're working in
                  a multi user mode.
          
                  .. versionadded:: 1.0.8
          
              `input_type`: string
                  Choose the type of soft keyboard to request. Can be one of
                  'null', 'text', 'number', 'url', 'mail', 'datetime', 'tel',
                  'address'.
          
                  .. note::
          
                      `input_type` is currently only honored on Android.
          
                  .. versionadded:: 1.8.0
          
                  .. versionchanged:: 2.1.0
                      Added `null` to soft keyboard types.
          
              `keyboard_suggestions`: bool
                  If True provides auto suggestions on top of keyboard.
                  This will only work if input_type is set to `text`, `url`,
                  `mail` or `address`.
          
                  .. versionadded:: 2.1.0
          
          :Return:
              An instance of :class:`Keyboard` containing the callback, target,
              and if the configuration allows it, a
              :class:`~kivy.uix.vkeyboard.VKeyboard` instance attached as a
              *.widget* property.
          
          .. note::
          
              The behavior of this function is heavily influenced by the current
              `keyboard_mode`. Please see the Config's
              :ref:`configuration tokens <configuration-tokens>` section for
              more information.
          ```
        函数 release_keyboard(self: , target: )
          ```
          .. versionadded:: 1.0.4
          
          Internal method for the widget to release the real-keyboard. Check
          :meth:`request_keyboard` to understand how it works.
          ```
        函数 grab_mouse(self: )
          ```
          Grab mouse - so won't leave window
          
          .. versionadded:: 1.10.0
          
          .. note::
              This feature requires the SDL2 window provider.
          ```
        函数 ungrab_mouse(self: )
          ```
          Ungrab mouse
          
          .. versionadded:: 1.10.0
          
          .. note::
              This feature requires the SDL2 window provider.
          ```
      函数 __exit(section: , name: , value: )
    分析文件: __init__.py
    类 CoreCriticalException:
      基类: Name(id='Exception', ctx=Load())
    函数 core_select_lib(category: , llist: , create_instance: , base: , basemodule: )
    函数 core_register_libs(category: , libs: , base: )
    函数 handle_win_lib_import_error(category: , provider: , mod_name: )
  分析文件: _version.py
  分析文件: multistroke.py
  类 MultistrokeError:
    基类: Name(id='Exception', ctx=Load())
  类 Recognizer:
    ```
    :class:`Recognizer` provides a gesture database with matching
    facilities.
    
    :Events:
        `on_search_start`
            Fired when a new search is started using this Recognizer.
    
        `on_search_complete`
            Fired when a running search ends, for whatever reason.
            (use :data:`ProgressTracker.status` to find out)
    
    :Properties:
        `db`
            A :class:`ListProperty` that contains the available
            :class:`MultistrokeGesture` objects.
    
            :attr:`db` is a
            :class:`~kivy.properties.ListProperty` and defaults to []
    ```
    基类: Name(id='EventDispatcher', ctx=Load())
    函数 __init__(self: )
    函数 filter(self: )
      ```
      :meth:`filter` returns a subset of objects in :attr:`self.db`,
      according to given criteria. This is used by many other methods of
      the :class:`Recognizer`; the arguments below can for example be
      used when calling :meth:`Recognizer.recognize` or
      :meth:`Recognizer.export_gesture`. You normally don't need to call
      this directly.
      
      :Arguments:
      
          `name`
              Limits the returned list to gestures where
              :attr:`MultistrokeGesture.name` matches given regular
              expression(s). If re.match(name, MultistrokeGesture.name)
              tests true, the gesture is included in the returned list.
              Can be a string or an array of strings ::
      
                  gdb = Recognizer()
      
                  # Will match all names that start with a capital N
                  # (ie Next, New, N, Nebraska etc, but not "n" or "next")
                  gdb.filter(name='N')
      
                  # exactly 'N'
                  gdb.filter(name='N$')
      
                  # Nebraska, teletubbies, France, fraggle, N, n, etc
                  gdb.filter(name=['[Nn]', '(?i)T', '(?i)F'])
      
          `priority`
              Limits the returned list to gestures with certain
              :attr:`MultistrokeGesture.priority` values. If specified as an
              integer, only gestures with a lower priority are returned. If
              specified as a list (min/max) ::
      
                  # Max priority 50
                  gdb.filter(priority=50)
      
                  # Max priority 50 (same result as above)
                  gdb.filter(priority=[0, 50])
      
                  # Min priority 50, max 100
                  gdb.filter(priority=[50, 100])
      
              When this option is used, :attr:`Recognizer.db` is
              automatically sorted according to priority, incurring extra
              cost. You can use `force_priority_sort` to override this
              behavior if your gestures are already sorted according to
              priority.
      
          `orientation_sensitive`
              Limits the returned list to gestures that are
              orientation sensitive (True), gestures that are not orientation
              sensitive (False) or None (ignore template sensitivity, this is
              the default).
      
          `numstrokes`
              Limits the returned list to gestures that have the specified
              number of strokes (in :attr:`MultistrokeGesture.strokes`).
              Can be a single integer or a list of integers.
      
          `numpoints`
              Limits the returned list to gestures that have specific
              :attr:`MultistrokeGesture.numpoints` values. This is provided
              for flexibility, do not use it unless you understand what it
              does. Can be a single integer or a list of integers.
      
          `force_priority_sort`
              Can be used to override the default sort behavior. Normally
              :class:`MultistrokeGesture` objects are returned in priority
              order if the `priority` option is used. Setting this to True
              will return gestures sorted in priority order, False will
              return in the order gestures were added. None means decide
              automatically (the default).
      
              .. Note ::
                  For improved performance, you can load your gesture
                  database in priority order and set this to False when
                  calling :meth:`Recognizer.recognize`
      
          `db`
              Can be set if you want to filter a different list of objects
              than :attr:`Recognizer.db`. You probably don't want to do this;
              it is used internally by :meth:`import_gesture`.
      ```
    函数 add_gesture(self: , name: , strokes: )
      ```
      Add a new gesture to the database. This will instantiate a new
      :class:`MultistrokeGesture` with `strokes` and append it to self.db.
      
      .. Note ::
          If you already have instantiated a :class:`MultistrokeGesture`
          object and wish to add it, append it to :attr:`Recognizer.db`
          manually.
      ```
    函数 parse_gesture(self: , data: )
      ```
      Parse data formatted by export_gesture(). Returns a list of
      :class:`MultistrokeGesture` objects. This is used internally by
      :meth:`import_gesture`, you normally don't need to call this
      directly.
      ```
    函数 export_gesture(self: , filename: )
      ```
      Export a list of :class:`MultistrokeGesture` objects. Outputs a
      base64-encoded string that can be decoded to a Python list with
      the :meth:`parse_gesture` function or imported directly to
      :attr:`self.db` using :meth:`Recognizer.import_gesture`. If
      `filename` is specified, the output is written to disk, otherwise
      returned.
      
      This method accepts optional :meth:`Recognizer.filter` arguments.
      ```
    函数 import_gesture(self: , data: , filename: )
      ```
      Import a list of gestures as formatted by :meth:`export_gesture`.
      One of `data` or `filename` must be specified.
      
      This method accepts optional :meth:`Recognizer.filter` arguments,
      if none are specified then all gestures in specified data are
      imported.
      ```
    函数 transfer_gesture(self: , tgt: )
      ```
      Transfers :class:`MultistrokeGesture` objects from
      :attr:`Recognizer.db` to another :class:`Recognizer` instance `tgt`.
      
      This method accepts optional :meth:`Recognizer.filter` arguments.
      ```
    函数 prepare_templates(self: )
      ```
      This method is used to prepare :class:`UnistrokeTemplate` objects
      within the gestures in self.db. This is useful if you want to minimize
      punishment of lazy resampling by preparing all vectors in advance. If
      you do this before a call to :meth:`Recognizer.export_gesture`, you
      will have the vectors computed when you load the data later.
      
      This method accepts optional :meth:`Recognizer.filter` arguments.
      
      `force_numpoints`, if specified, will prepare all templates to the
      given number of points (instead of each template's preferred n; ie
      :data:`UnistrokeTemplate.numpoints`). You normally don't want to
      do this.
      ```
    函数 recognize(self: , strokes: , goodscore: , timeout: , delay: )
      ```
      Search for gestures matching `strokes`. Returns a
      :class:`ProgressTracker` instance.
      
      This method accepts optional :meth:`Recognizer.filter` arguments.
      
      :Arguments:
      
          `strokes`
              A list of stroke paths (list of lists of
              :class:`~kivy.vector.Vector` objects) that will be matched
              against gestures in the database. Can also be a
              :class:`Candidate` instance.
      
              .. Warning ::
      
                  If you manually supply a :class:`Candidate` that has a
                  skip-flag, make sure that the correct filter arguments
                  are set. Otherwise the system will attempt to load vectors
                  that have not been computed. For example, if you set
                  `skip_bounded` and do not set `orientation_sensitive` to
                  False, it will raise an exception if an
                  orientation_sensitive :class:`UnistrokeTemplate`
                  is encountered.
      
          `goodscore`
              If this is set (between 0.0 - 1.0) and a gesture score is
              equal to or higher than the specified value, the search is
              immediately halted and the on_search_complete event is
              fired (+ the on_complete event of the associated
              :class:`ProgressTracker` instance). Default is None (disabled).
      
          `timeout`
              Specifies a timeout (in seconds) for when the search is
              aborted and the results returned. This option applies only
              when `max_gpf` is not 0. Default value is 0, meaning all
              gestures in the database will be tested, no matter how long
              it takes.
      
          `max_gpf`
              Specifies the maximum number of :class:`MultistrokeGesture`
              objects that can be processed per frame. When exceeded, will
              cause the search to halt and resume work in the next frame.
              Setting to 0 will complete the search immediately (and block
              the UI).
      
              .. Warning ::
      
                  This does not limit the number of
                  :class:`UnistrokeTemplate` objects matched! If a single
                  gesture has a million templates, they will all be
                  processed in a single frame with max_gpf=1!
      
          `delay`
              Sets an optional delay between each run of the recognizer
              loop. Normally, a run is scheduled for the next frame until
              the tasklist is exhausted. If you set this, there will be an
              additional delay between each run (specified in seconds).
              Default is 0, resume in the next frame.
      
          `force_numpoints`
              forces all templates (and candidate) to be prepared to a
              certain number of points. This can be useful for example if
              you are evaluating templates for optimal n (do not use this
              unless you understand what it does).
      ```
    函数 _candidate(self: , strokes: )
    函数 on_search_start(self: , result: )
    函数 on_search_complete(self: , result: )
  类 ProgressTracker:
    ```
    Represents an ongoing (or completed) search operation. Instantiated and
    returned by the :meth:`Recognizer.recognize` method when it is called. The
    `results` attribute is a dictionary that is  updated as the recognition
    operation progresses.
    
    .. Note ::
        You do not need to instantiate this class.
    
    :Arguments:
        `candidate`
            :class:`Candidate` object to be evaluated
        `tasks`
            Total number of gestures in tasklist (to test against)
    
    :Events:
        `on_progress`
            Fired for every gesture that is processed
        `on_result`
            Fired when a new result is added, and it is the first match
            for the `name` so far, or a consecutive match with better score.
        `on_complete`
            Fired when the search is completed, for whatever reason.
            (use `ProgressTracker.status` to find out)
    
    :Attributes:
        `results`
            A dictionary of all results (so far). The key is the name of the
            gesture (ie :attr:`UnistrokeTemplate.name` usually inherited from
            :class:`MultistrokeGesture`). Each item in the dictionary is a
            dict with the following entries:
    
                `name`
                    Name of the matched template (redundant)
                `score`
                    Computed score from 1.0 (perfect match) to 0.0
                `dist`
                    Cosine distance from candidate to template (low=closer)
                `gesture`
                    The :class:`MultistrokeGesture` object that was matched
                `best_template`
                    Index of the best matching template (in
                    :attr:`MultistrokeGesture.templates`)
                `template_results`
                    List of distances for all templates. The list index
                    corresponds to a :class:`UnistrokeTemplate` index in
                    gesture.templates.
    
        `status`
            `search`
                Currently working
            `stop`
                Was stopped by the user (:meth:`stop` called)
            `timeout`
                A timeout occurred (specified as `timeout=` to recognize())
            `goodscore`
                The search was stopped early because a gesture with a high
                enough score was found (specified as `goodscore=` to
                recognize())
            `complete`
                The search is complete (all gestures matching filters were
                tested)
    ```
    基类: Name(id='EventDispatcher', ctx=Load())
    函数 progress(self: )
      ```
      Returns the progress as a float, 0 is 0% done, 1 is 100%. This
      is a Python property.
      ```
    函数 best(self: )
      ```
      Return the best match found by recognize() so far. It returns a
      dictionary with three keys, 'name', 'dist' and 'score' representing
      the template's name, distance (from candidate path) and the
      computed score value. This is a Python property.
      ```
    函数 stop(self: )
      ```
      Raises a stop flag that is checked by the search process. It will
      be stopped on the next clock tick (if it is still running).
      ```
    函数 _add_result(self: , gesture: , dist: , tpl: , res: )
    函数 on_complete(self: )
    函数 on_progress(self: )
    函数 on_result(self: , result: )
  类 MultistrokeGesture:
    ```
    :class:`MultistrokeGesture` represents a gesture. It maintains a set of
    `strokes` and generates unistroke (ie :class:`UnistrokeTemplate`)
    permutations that are used for evaluating candidates against this gesture
    later.
    
    :Arguments:
        `name`
            Identifies the name of the gesture - it is returned to you in the
            results of a :meth:`Recognizer.recognize` search. You can have any
            number of MultistrokeGesture objects with the same name; many
            definitions of one gesture. The same name is given to all the
            generated unistroke permutations. Required, no default.
        `strokes`
            A list of paths that represents the gesture. A path is a list of
            Vector objects::
    
                gesture = MultistrokeGesture('my_gesture', strokes=[
                  [Vector(x1, y1), Vector(x2, y2), ...... ], # stroke 1
                  [Vector(), Vector(), Vector(), Vector() ]  # stroke 2
                  #, [stroke 3], [stroke 4], ...
                ])
    
            For template matching purposes, all the strokes are combined to a
            single list (unistroke). You should still specify the strokes
            individually, and set `stroke_sensitive` True (whenever possible).
    
            Once you do this, unistroke permutations are immediately generated
            and stored in `self.templates` for later, unless you set the
            `permute` flag to False.
        `priority`
            Determines when :func:`Recognizer.recognize` will attempt to match
            this template, lower priorities are evaluated first (only if
            a priority `filter` is used). You should use lower priority on
            gestures that are more likely to match. For example, set user
            templates at lower number than generic templates. Default is 100.
        `numpoints`
            Determines the number of points this gesture should be resampled to
            (for matching purposes). The default is 16.
        `stroke_sensitive`
            Determines if the number of strokes (paths) in this gesture is
            required to be the same in the candidate (user input) gesture
            during matching. If this is False, candidates will always be
            evaluated, disregarding the number of strokes. Default is True.
        `orientation_sensitive`
            Determines if this gesture is orientation sensitive. If True,
            aligns the indicative orientation with the one of eight base
            orientations that requires least rotation. Default is True.
        `angle_similarity`
            This is used by the :func:`Recognizer.recognize` function when a
            candidate is evaluated against this gesture. If the angles between
            them are too far off, the template is considered a non-match.
            Default is 30.0 (degrees)
        `permute`
            If False, do not use Heap Permute algorithm to generate different
            stroke orders when instantiated. If you set this to False, a
            single UnistrokeTemplate built from `strokes` is used.
    ```
    基类: Name(id='object', ctx=Load())
    函数 angle_similarity_threshold(self: )
    函数 add_stroke(self: , stroke: , permute: )
      ```
      Add a stroke to the self.strokes list. If `permute` is True, the
      :meth:`permute` method is called to generate new unistroke templates
      ```
    函数 get_distance(self: , cand: , tpl: , numpoints: )
      ```
      Compute the distance from this Candidate to a UnistrokeTemplate.
      Returns the Cosine distance between the stroke paths.
      
      `numpoints` will prepare both the UnistrokeTemplate and Candidate path
      to n points (when necessary), you probably don't want to do this.
      ```
    函数 match_candidate(self: , cand: )
      ```
      Match a given candidate against this MultistrokeGesture object. Will
      test against all templates and report results as a list of four
      items:
      
          `index 0`
              Best matching template's index (in self.templates)
          `index 1`
              Computed distance from the template to the candidate path
          `index 2`
              List of distances for all templates. The list index
              corresponds to a :class:`UnistrokeTemplate` index in
              self.templates.
          `index 3`
              Counter for the number of performed matching operations, ie
              templates matched against the candidate
      ```
    函数 permute(self: )
      ```
      Generate all possible unistroke permutations from self.strokes and
      save the resulting list of UnistrokeTemplate objects in self.templates.
      
      Quote from http://faculty.washington.edu/wobbrock/pubs/gi-10.2.pdf ::
      
          We use Heap Permute [16] (p. 179) to generate all stroke orders
          in a multistroke gesture. Then, to generate stroke directions for
          each order, we treat each component stroke as a dichotomous
          [0,1] variable. There are 2^N combinations for N strokes, so we
          convert the decimal values 0 to 2^N-1, inclusive, to binary
          representations and regard each bit as indicating forward (0) or
          reverse (1). This algorithm is often used to generate truth tables
          in propositional logic.
      
      See section 4.1: "$N Algorithm" of the linked paper for details.
      
      .. Warning ::
      
          Using heap permute for gestures with more than 3 strokes
          can result in very large number of templates (a 9-stroke
          gesture = 38 million templates). If you are dealing with
          these types of gestures, you should manually compose
          all the desired stroke orders.
      ```
    函数 _heap_permute(self: , n: )
    函数 _make_unistrokes(self: )
  类 UnistrokeTemplate:
    ```
    Represents a (uni)stroke path as a list of Vectors. Normally, this class
    is instantiated by MultistrokeGesture and not by the programmer directly.
    However, it is possible to manually compose UnistrokeTemplate objects.
    
    :Arguments:
        `name`
            Identifies the name of the gesture. This is normally inherited from
            the parent MultistrokeGesture object when a template is generated.
        `points`
            A list of points that represents a unistroke path. This is normally
            one of the possible stroke order permutations from a
            MultistrokeGesture.
        `numpoints`
            The number of points this template should (ideally) be resampled to
            before the matching process. The default is 16, but you can use a
            template-specific settings if that improves results.
        `orientation_sensitive`
            Determines if this template is orientation sensitive (True) or
            fully rotation invariant (False). The default is True.
    
    .. Note::
        You will get an exception if you set a skip-flag and then attempt to
        retrieve those vectors.
    ```
    基类: Name(id='object', ctx=Load())
    函数 add_point(self: , p: )
      ```
      Add a point to the unistroke/path. This invalidates all previously
      computed vectors.
      ```
    函数 _get_db_key(self: , key: , numpoints: )
    函数 get_start_unit_vector(self: , numpoints: )
    函数 get_vector(self: , numpoints: )
    函数 get_points(self: , numpoints: )
    函数 prepare(self: , numpoints: )
      ```
      This function prepares the UnistrokeTemplate for matching given a
      target number of points (for resample). 16 is optimal.
      ```
  类 Candidate:
    ```
    Represents a set of unistroke paths of user input, ie data to be matched
    against a :class:`UnistrokeTemplate` object using the Protractor algorithm.
    By default, data is precomputed to match both rotation bounded and fully
    invariant :class:`UnistrokeTemplate` objects.
    
    :Arguments:
        `strokes`
            See :data:`MultistrokeGesture.strokes` for format example. The
            Candidate strokes are simply combined to a unistroke in the order
            given. The idea is that this will match one of the unistroke
            permutations in `MultistrokeGesture.templates`.
        `numpoints`
            The Candidate's default N; this is only for a fallback, it is not
            normally used since n is driven by the UnistrokeTemplate we are
            being compared to.
        `skip_bounded`
            If True, do not generate/store rotation bounded vectors
        `skip_invariant`
            If True, do not generate/store rotation invariant vectors
    
    Note that you WILL get errors if you set a skip-flag and then attempt to
    retrieve the data.
    ```
    基类: Name(id='object', ctx=Load())
    函数 get_protractor_vector(self: , numpoints: , orientation_sens: )
      ```
      (Internal use only) Return vector for comparing to a
      UnistrokeTemplate with Protractor
      ```
    函数 get_angle_similarity(self: , tpl: )
      ```
      (Internal use only) Compute the angle similarity between this
      Candidate and a UnistrokeTemplate object. Returns a number that
      represents the angle similarity (lower is more similar).
      ```
  函数 resample(points: , n: )
  函数 indicative_angle(points: )
  函数 rotate_by(points: , radians: )
  函数 scale_dim(points: , size: , oneDratio: )
  函数 translate_to(points: , pt: )
  函数 vectorize(points: , use_bounded_rotation_invariance: )
  函数 centroid(points: )
  函数 bounding_box(points: )
  函数 path_length(points: )
  函数 distance(p1: , p2: )
  函数 start_unit_vector(points: , index: )
  函数 _recognize_tick(dt: )
  函数 result_hack(dt: )
  函数 _dispatch()
  分析文件: interactive.py
  函数 safeWait(dt: )
  函数 unwrap(ob: )
  类 SafeMembrane:
    ```
    This help is for a proxy object. Did you want help on the proxy's referent
    instead? Try using help(<instance>._ref)
    
    The SafeMembrane is a threadsafe proxy that also returns attributes as new
    thread-safe objects
    and makes thread-safe method calls, preventing thread-unsafe objects
    from leaking into the user's environment.
    ```
    基类: Name(id='object', ctx=Load())
    函数 __init__(self: , ob: )
    函数 safeIn(self: )
      ```
      Provides a thread-safe entry point for interactive launching.
      ```
    函数 safeOut(self: )
      ```
      Provides a thread-safe exit point for interactive launching.
      ```
    函数 isMethod(self: , fn: )
    函数 __repr__(self: )
    函数 __call__(self: )
    函数 __getattribute__(self: , attr: , oga: )
    函数 __getattr__(self: , attr: , oga: )
    函数 __setattr__(self: , attr: , val: , osa: )
    函数 __delattr__(self: , attr: , oda: )
    函数 __bool__(self: )
    函数 __getitem__(self: , arg: )
    函数 __setitem__(self: , arg: , val: )
    函数 __delitem__(self: , arg: )
    函数 __getslice__(self: , i: , j: )
    函数 __setslice__(self: , i: , j: , val: )
    函数 __delslice__(self: , i: , j: )
    函数 __enter__(self: )
    函数 __exit__(self: )
  类 InteractiveLauncher:
    ```
    Proxy to an application instance that launches it in a thread and
    then returns and acts as a proxy to the application in the thread.
    ```
    基类: Name(id='SafeMembrane', ctx=Load())
    函数 run(self: )
    函数 stop(self: )
  函数 startApp(app: )
  分析文件: gesture.py
  类 GestureDatabase:
    ```
    Class to handle a gesture database.
    ```
    基类: Name(id='object', ctx=Load())
    函数 __init__(self: )
    函数 add_gesture(self: , gesture: )
      ```
      Add a new gesture to the database.
      ```
    函数 find(self: , gesture: , minscore: , rotation_invariant: )
      ```
      Find a matching gesture in the database.
      ```
    函数 gesture_to_str(self: , gesture: )
      ```
      Convert a gesture into a unique string.
      ```
    函数 str_to_gesture(self: , data: )
      ```
      Convert a unique string to a gesture.
      ```
  类 GesturePoint:
    函数 scale(self: , factor: )
      ```
      Scales the point by the given factor.
      ```
    函数 __repr__(self: )
  类 GestureStroke:
    ```
    Gestures can be made up of multiple strokes.
    ```
    函数 max_x(self: )
    函数 min_x(self: )
    函数 max_y(self: )
    函数 min_y(self: )
    函数 add_point(self: , x: , y: )
      ```
      add_point(x=x_pos, y=y_pos)
      Adds a point to the stroke.
      ```
    函数 scale_stroke(self: , scale_factor: )
      ```
      scale_stroke(scale_factor=float)
      Scales the stroke down by scale_factor.
      ```
    函数 points_distance(self: , point1: , point2: )
      ```
      points_distance(point1=GesturePoint, point2=GesturePoint)
      Returns the distance between two GesturePoints.
      ```
    函数 stroke_length(self: , point_list: )
      ```
      Finds the length of the stroke. If a point list is given,
      finds the length of that list.
      ```
    函数 normalize_stroke(self: , sample_points: )
      ```
      Normalizes strokes so that every stroke has a standard number of
      points. Returns True if stroke is normalized, False if it can't be
      normalized. sample_points controls the resolution of the stroke.
      ```
    函数 center_stroke(self: , offset_x: , offset_y: )
      ```
      Centers the stroke by offsetting the points.
      ```
  类 Gesture:
    ```
    A python implementation of a gesture recognition algorithm by
    Oleg Dopertchouk: http://www.gamedev.net/reference/articles/article2039.asp
    
    Implemented by Jeiel Aranal (chemikhazi@gmail.com),
    released into the public domain.
    ```
    函数 _scale_gesture(self: )
      ```
      Scales down the gesture to a unit of 1.
      ```
    函数 _center_gesture(self: )
      ```
      Centers the Gesture.points of the gesture.
      ```
    函数 add_stroke(self: , point_list: )
      ```
      Adds a stroke to the gesture and returns the Stroke instance.
      Optional point_list argument is a list of the mouse points for
      the stroke.
      ```
    函数 normalize(self: , stroke_samples: )
      ```
      Runs the gesture normalization algorithm and calculates the dot
      product with self.
      ```
    函数 get_rigid_rotation(self: , dstpts: )
      ```
      Extract the rotation to apply to a group of points to minimize the
      distance to a second group of points. The two groups of points are
      assumed to be centered. This is a simple version that just picks
      an angle based on the first point of the gesture.
      ```
    函数 dot_product(self: , comparison_gesture: )
      ```
      Calculates the dot product of the gesture with another gesture.
      ```
    函数 rotate(self: , angle: )
    函数 get_score(self: , comparison_gesture: , rotation_invariant: )
      ```
      Returns the matching score of the gesture against another gesture.
              
      ```
    函数 __eq__(self: , comparison_gesture: )
      ```
      Allows easy comparisons between gesture instances.
      ```
    函数 __ne__(self: , comparison_gesture: )
    函数 __lt__(self: , comparison_gesture: )
    函数 __gt__(self: , comparison_gesture: )
    函数 __le__(self: , comparison_gesture: )
    函数 __ge__(self: , comparison_gesture: )
  分析文件: atlas.py
  类 Atlas:
    ```
    Manage texture atlas. See module documentation for more information.
        
    ```
    基类: Name(id='EventDispatcher', ctx=Load())
    函数 _get_filename(self: )
    函数 __init__(self: , filename: )
    函数 __getitem__(self: , key: )
    函数 _load(self: )
    函数 create(outname: , filenames: , size: , padding: , use_path: )
      ```
      This method can be used to create an atlas manually from a set of
      images.
      
      :Parameters:
          `outname`: str
              Basename to use for ``.atlas`` creation and ``-<idx>.png``
              associated images.
          `filenames`: list
              List of filenames to put in the atlas.
          `size`: int or list (width, height)
              Size of the atlas image. If the size is not large enough to
              fit all of the source images, more atlas images will created
              as required.
          `padding`: int, defaults to 2
              Padding to put around each image.
      
              Be careful. If you're using a padding < 2, you might have
              issues with the borders of the images. Because of the OpenGL
              linearization, it might use the pixels of the adjacent image.
      
              If you're using a padding >= 2, we'll automatically generate a
              "border" of 1px around your image. If you look at
              the result, don't be scared if the image inside is not
              exactly the same as yours :).
      
          `use_path`: bool, defaults to False
              If True, the relative path of the source png
              file names will be included in the atlas ids rather
              that just in the file names. Leading dots and slashes will be
              excluded and all other slashes in the path will be replaced
              with underscores. For example, if `use_path` is False
              (the default) and the file name is
              ``../data/tiles/green_grass.png``, the id will be
              ``green_grass``. If `use_path` is True, it will be
              ``data_tiles_green_grass``.
      
          .. versionchanged:: 1.8.0
              Parameter use_path added
      ```
  tools/
    分析文件: report.py
    函数 title(t: )
    函数 send_report(dict_report: )
    函数 testimport(libname: )
    分析文件: changelog_parser.py
    函数 write_special_section(fh: , items: , header: )
    函数 process_changelog(filename_in: , filename_out: )
    precommit_hooks/
    packaging/
      分析文件: cython_cfg.py
      函数 get_cython_versions(setup_cfg: )
      函数 get_cython_msg()
      pyinstaller_hooks/
        分析文件: hook-kivy.py
        分析文件: __main__.py
        分析文件: pyi_rth_kivy.py
        分析文件: __init__.py
        函数 runtime_hooks()
          ```
          Returns a list with the runtime hooks for kivy. It can be used with
          ``runtime_hooks=runtime_hooks()`` in the spec file. Pyinstaller comes
          preinstalled with this hook.
          ```
        函数 hookspath()
          ```
          Returns a list with the directory that contains the alternate (not
          the default included with pyinstaller) pyinstaller hook for kivy,
          ``kivy/tools/packaging/pyinstaller_hooks/kivy-hook.py``. It is
          typically used with ``hookspath=hookspath()`` in the spec
          file.
          
          The default pyinstaller hook returns all the core providers used using
          :func:`get_deps_minimal` to add to its list of hidden imports. This
          alternate hook only included the essential modules and leaves the core
          providers to be included additionally with :func:`get_deps_minimal`
          or :func:`get_deps_all`.
          ```
        函数 get_hooks()
          ```
          Returns the dict for the spec ``hookspath`` and ``runtime_hooks``
          values.
          ```
        函数 get_deps_minimal(exclude_ignored: )
          ```
          Returns Kivy hidden modules as well as excluded modules to be used
          with ``Analysis``.
          
          The function takes core modules as keyword arguments and their value
          indicates which of the providers to include/exclude from the compiled app.
          
          The possible keyword names are ``audio, camera, clipboard, image, spelling,
          text, video, and window``. Their values can be:
          
              ``True``: Include current provider
                  The providers imported when the core module is
                  loaded on this system are added to hidden imports. This is the
                  default if the keyword name is not specified.
              ``None``: Exclude
                  Don't return this core module at all.
              ``A string or list of strings``: Providers to include
                  Each string is the name of a provider for this module to be
                  included.
          
          For example, ``get_deps_minimal(video=None, window=True,
          audio=['gstplayer', 'ffpyplayer'], spelling='enchant')`` will exclude all
          the video providers, will include the gstreamer and ffpyplayer providers
          for audio, will include the enchant provider for spelling, and will use the
          current default provider for ``window``.
          
          ``exclude_ignored``, if ``True`` (the default), if the value for a core
          library is ``None``, then if ``exclude_ignored`` is True, not only will the
          library not be included in the hiddenimports but it'll also added to the
          excluded imports to prevent it being included accidentally by pyinstaller.
          
          :returns:
          
              A dict with three keys, ``hiddenimports``, ``excludes``, and
              ``binaries``. Their values are a list of the corresponding modules to
              include/exclude. This can be passed directly to `Analysis`` with
              e.g. ::
          
                  a = Analysis(['..\kivy\examples\demo\touchtracer\main.py'],
                              ...
                               hookspath=hookspath(),
                               runtime_hooks=[],
                               win_no_prefer_redirects=False,
                               win_private_assemblies=False,
                               cipher=block_cipher,
                               **get_deps_minimal(video=None, audio=None))
          ```
        函数 get_deps_all()
          ```
          Similar to :func:`get_deps_minimal`, but this returns all the
          kivy modules that can indirectly imported. Which includes all
          the possible kivy providers.
          
          This can be used to get a list of all the possible providers
          which can then manually be included/excluded by commenting out elements
          in the list instead of passing on all the items. See module description.
          
          :returns:
          
              A dict with three keys, ``hiddenimports``, ``excludes``, and
              ``binaries``. Their values are a list of the corresponding modules to
              include/exclude. This can be passed directly to `Analysis`` with
              e.g. ::
          
                  a = Analysis(['..\kivy\examples\demo\touchtracer\main.py'],
                              ...
                               **get_deps_all())
          ```
        函数 get_factory_modules()
          ```
          Returns a list of all the modules registered in the kivy factory.
              
          ```
        函数 add_dep_paths()
          ```
          Should be called by the hook. It adds the paths with the binary
          dependencies to the system path so that pyinstaller can find the binaries
          during its crawling stage.
          ```
        函数 _find_gst_plugin_path()
          ```
          Returns a list of directories to search for GStreamer plugins.
              
          ```
        函数 _find_gst_binaries()
          ```
          Returns a list of GStreamer plugins and libraries to pass as the
          ``binaries`` argument of ``Analysis``.
          ```
      分析文件: __init__.py
      分析文件: factory.py
      类 FactoryBuild:
        基类: Name(id='Command', ctx=Load())
        函数 initialize_options(self: )
        函数 finalize_options(self: )
        函数 run(self: )
    分析文件: texturecompress.py
    类 Tool:
      基类: Name(id='object', ctx=Load())
      函数 __init__(self: , options: )
      函数 tex_fn(self: )
      函数 compress(self: )
      函数 nearest_pow2(self: , v: )
      函数 runcmd(self: , cmd: )
      函数 write_tex(self: , data: , fmt: , image_size: , texture_size: , mipmap: , formatinfo: )
      函数 run()
    类 Etc1Tool:
      基类: Name(id='Tool', ctx=Load())
      函数 locate_etc1tool(self: )
    类 PvrtcTool:
      基类: Name(id='Tool', ctx=Load())
      函数 locate_texturetool(self: )
    分析文件: generate-icons.py
    类 Converter:
      基类: Name(id='object', ctx=Load())
      函数 run(self: )
      函数 convert_to(self: , source: , icon_fn: , size: )
      函数 ensure_quality(self: , image: , force: )
      函数 iterate(self: )
    theming/
      defaulttheme/
    image-testsuite/
      分析文件: gimp28-testsuite.py
      函数 v0_pattern_pixel(char: , alpha: , fmt: )
      函数 v0_filename(w: , h: , pat: , alpha: , fmtinfo: , testname: , ext: )
      函数 save_image(dirname: , img: , lyr: , w: , h: , pat: , alpha: , v0_fmtinfo: , testname: , ext: )
      函数 draw_pattern(lyr: , pat: , alpha: , direction: , pixelgetter: )
      函数 make_images(testname: , pattern: , alpha: , layertype_in: , extensions: , dirname: )
      函数 makepatterns(allow: , include: , exclude: )
      函数 plugin_main(dirname: , do_opaque: , do_binary: , do_alpha: )
      函数 filename(fmtinfo_in: )
      函数 savepath(fn: )
    分析文件: kviewer.py
    类 KvHandler:
      基类: Name(id='FileSystemEventHandler', ctx=Load())
      函数 __init__(self: , callback: , target: )
      函数 on_any_event(self: , event: )
    类 KvViewerApp:
      基类: Name(id='App', ctx=Load())
      函数 build(self: )
      函数 update(self: )
    gles_compat/
      分析文件: subset_gles.py
      函数 add_defines_to_set(header: )
      函数 extract_common_symbols(symbols1: , symbols2: , already_extracted: )
    分析文件: stub-gl-debug.py
    函数 replace(s: )
    分析文件: coverage.py
    类 CoverageKVParser:
      基类: Name(id='Parser', ctx=Load())
      函数 execute_directives(self: )
      函数 get_coverage_lines(self: )
    函数 walk_parser_rules(parser_rule: )
    函数 walk_parser_rules_properties(parser_rule: )
    函数 walk_parser(parser: )
    类 KivyCoveragePlugin:
      基类: Attribute(value=Attribute(value=Name(id='coverage', ctx=Load()), attr='plugin', ctx=Load()), attr='CoveragePlugin', ctx=Load())
      函数 file_tracer(self: , filename: )
      函数 file_reporter(self: , filename: )
      函数 find_executable_files(self: , src_dir: )
    类 KivyFileTracer:
      基类: Attribute(value=Attribute(value=Name(id='coverage', ctx=Load()), attr='plugin', ctx=Load()), attr='FileTracer', ctx=Load())
      函数 __init__(self: , filename: )
      函数 source_filename(self: )
    类 KivyFileReporter:
      基类: Attribute(value=Attribute(value=Name(id='coverage', ctx=Load()), attr='plugin', ctx=Load()), attr='FileReporter', ctx=Load())
      函数 lines(self: )
    函数 coverage_init(reg: , options: )
    pep8checker/
      分析文件: pep8kivy.py
      类 KivyStyleChecker:
        基类: Attribute(value=Name(id='pep8', ctx=Load()), attr='Checker', ctx=Load())
        函数 __init__(self: , filename: )
        函数 report_error(self: , line_number: , offset: , text: , check: )
      函数 usage()
      函数 check(fn: )
      分析文件: pep8.py
      函数 tabs_or_spaces(physical_line: , indent_char: )
        ```
        Never mix tabs and spaces.
        
        The most popular way of indenting Python is with spaces only.  The
        second-most popular way is with tabs only.  Code indented with a mixture
        of tabs and spaces should be converted to using spaces exclusively.  When
        invoking the Python command line interpreter with the -t option, it issues
        warnings about code that illegally mixes tabs and spaces.  When using -tt
        these warnings become errors.  These options are highly recommended!
        
        Okay: if a == 0:\n        a = 1\n        b = 1
        E101: if a == 0:\n        a = 1\n\tb = 1
        ```
      函数 tabs_obsolete(physical_line: )
        ```
        For new projects, spaces-only are strongly recommended over tabs.
        
        Okay: if True:\n    return
        W191: if True:\n\treturn
        ```
      函数 trailing_whitespace(physical_line: )
        ```
        Trailing whitespace is superfluous.
        
        The warning returned varies on whether the line itself is blank, for easier
        filtering for those who want to indent their blank lines.
        
        Okay: spam(1)\n#
        W291: spam(1) \n#
        W293: class Foo(object):\n    \n    bang = 12
        ```
      函数 trailing_blank_lines(physical_line: , lines: , line_number: , total_lines: )
        ```
        Trailing blank lines are superfluous.
        
        Okay: spam(1)
        W391: spam(1)\n
        
        However the last line should end with a new line (warning W292).
        ```
      函数 maximum_line_length(physical_line: , max_line_length: , multiline: , noqa: )
        ```
        Limit all lines to a maximum of 79 characters.
        
        There are still many devices around that are limited to 80 character
        lines; plus, limiting windows to 80 characters makes it possible to have
        several windows side-by-side.  The default wrapping on such devices looks
        ugly.  Therefore, please limit all lines to a maximum of 79 characters.
        For flowing long blocks of text (docstrings or comments), limiting the
        length to 72 characters is recommended.
        
        Reports error E501.
        ```
      函数 blank_lines(logical_line: , blank_lines: , indent_level: , line_number: , blank_before: , previous_logical: , previous_unindented_logical_line: , previous_indent_level: , lines: )
        ```
        Separate top-level function and class definitions with two blank lines.
        
        Method definitions inside a class are separated by a single blank line.
        
        Extra blank lines may be used (sparingly) to separate groups of related
        functions.  Blank lines may be omitted between a bunch of related
        one-liners (e.g. a set of dummy implementations).
        
        Use blank lines in functions, sparingly, to indicate logical sections.
        
        Okay: def a():\n    pass\n\n\ndef b():\n    pass
        Okay: def a():\n    pass\n\n\nasync def b():\n    pass
        Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass
        Okay: default = 1\nfoo = 1
        Okay: classify = 1\nfoo = 1
        
        E301: class Foo:\n    b = 0\n    def bar():\n        pass
        E302: def a():\n    pass\n\ndef b(n):\n    pass
        E302: def a():\n    pass\n\nasync def b(n):\n    pass
        E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
        E303: def a():\n\n\n\n    pass
        E304: @decorator\n\ndef a():\n    pass
        E305: def a():\n    pass\na()
        ```
      函数 extraneous_whitespace(logical_line: )
        ```
        Avoid extraneous whitespace.
        
        Avoid extraneous whitespace in these situations:
        - Immediately inside parentheses, brackets or braces.
        - Immediately before a comma, semicolon, or colon.
        
        Okay: spam(ham[1], {eggs: 2})
        E201: spam( ham[1], {eggs: 2})
        E201: spam(ham[ 1], {eggs: 2})
        E201: spam(ham[1], { eggs: 2})
        E202: spam(ham[1], {eggs: 2} )
        E202: spam(ham[1 ], {eggs: 2})
        E202: spam(ham[1], {eggs: 2 })
        
        E203: if x == 4: print(x, y); x, y = y , x
        E203: if x == 4: print(x, y); x, y = y, x
        E203: if x == 4 : print(x, y); x, y = y, x
        ```
      函数 whitespace_around_keywords(logical_line: )
        ```
        Avoid extraneous whitespace around keywords.
        
        Okay: True and False
        E271: True and  False
        E272: True  and False
        E273: True and\tFalse
        E274: True\tand False
        ```
      函数 missing_whitespace_after_import_keyword(logical_line: )
        ```
        Multiple imports in form from x import (a, b, c) should have space
        between import statement and parenthesised name list.
        
        Okay: from foo import (bar, baz)
        E275: from foo import(bar, baz)
        E275: from importable.module import(bar, baz)
        ```
      函数 missing_whitespace(logical_line: )
        ```
        Each comma, semicolon or colon should be followed by whitespace.
        
        Okay: [a, b]
        Okay: (3,)
        Okay: a[1:4]
        Okay: a[:4]
        Okay: a[1:]
        Okay: a[1:4:2]
        E231: ['a','b']
        E231: foo(bar,baz)
        E231: [{'a':'b'}]
        ```
      函数 indentation(logical_line: , previous_logical: , indent_char: , indent_level: , previous_indent_level: )
        ```
        Use 4 spaces per indentation level.
        
        For really old code that you don't want to mess up, you can continue to
        use 8-space tabs.
        
        Okay: a = 1
        Okay: if a == 0:\n    a = 1
        E111:   a = 1
        E114:   # a = 1
        
        Okay: for item in items:\n    pass
        E112: for item in items:\npass
        E115: for item in items:\n# Hi\n    pass
        
        Okay: a = 1\nb = 2
        E113: a = 1\n    b = 2
        E116: a = 1\n    # b = 2
        ```
      函数 continued_indentation(logical_line: , tokens: , indent_level: , hang_closing: , indent_char: , noqa: , verbose: )
        ```
        Continuation lines indentation.
        
        Continuation lines should align wrapped elements either vertically
        using Python's implicit line joining inside parentheses, brackets
        and braces, or using a hanging indent.
        
        When using a hanging indent these considerations should be applied:
        - there should be no arguments on the first line, and
        - further indentation should be used to clearly distinguish itself as a
          continuation line.
        
        Okay: a = (\n)
        E123: a = (\n    )
        
        Okay: a = (\n    42)
        E121: a = (\n   42)
        E122: a = (\n42)
        E123: a = (\n    42\n    )
        E124: a = (24,\n     42\n)
        E125: if (\n    b):\n    pass
        E126: a = (\n        42)
        E127: a = (24,\n      42)
        E128: a = (24,\n    42)
        E129: if (a or\n    b):\n    pass
        E131: a = (\n    42\n 24)
        ```
      函数 whitespace_before_parameters(logical_line: , tokens: )
        ```
        Avoid extraneous whitespace.
        
        Avoid extraneous whitespace in the following situations:
        - before the open parenthesis that starts the argument list of a
          function call.
        - before the open parenthesis that starts an indexing or slicing.
        
        Okay: spam(1)
        E211: spam (1)
        
        Okay: dict['key'] = list[index]
        E211: dict ['key'] = list[index]
        E211: dict['key'] = list [index]
        ```
      函数 whitespace_around_operator(logical_line: )
        ```
        Avoid extraneous whitespace around an operator.
        
        Okay: a = 12 + 3
        E221: a = 4  + 5
        E222: a = 4 +  5
        E223: a = 4\t+ 5
        E224: a = 4 +\t5
        ```
      函数 missing_whitespace_around_operator(logical_line: , tokens: )
        ```
        Surround operators with a single space on either side.
        
        - Always surround these binary operators with a single space on
          either side: assignment (=), augmented assignment (+=, -= etc.),
          comparisons (==, <, >, !=, <=, >=, in, not in, is, is not),
          Booleans (and, or, not).
        
        - If operators with different priorities are used, consider adding
          whitespace around the operators with the lowest priorities.
        
        Okay: i = i + 1
        Okay: submitted += 1
        Okay: x = x * 2 - 1
        Okay: hypot2 = x * x + y * y
        Okay: c = (a + b) * (a - b)
        Okay: foo(bar, key='word', *args, **kwargs)
        Okay: alpha[:-i]
        
        E225: i=i+1
        E225: submitted +=1
        E225: x = x /2 - 1
        E225: z = x **y
        E226: c = (a+b) * (a-b)
        E226: hypot2 = x*x + y*y
        E227: c = a|b
        E228: msg = fmt%(errno, errmsg)
        ```
      函数 whitespace_around_comma(logical_line: )
        ```
        Avoid extraneous whitespace after a comma or a colon.
        
        Note: these checks are disabled by default
        
        Okay: a = (1, 2)
        E241: a = (1,  2)
        E242: a = (1,\t2)
        ```
      函数 whitespace_around_named_parameter_equals(logical_line: , tokens: )
        ```
        Don't use spaces around the '=' sign in function arguments.
        
        Don't use spaces around the '=' sign when used to indicate a
        keyword argument or a default parameter value.
        
        Okay: def complex(real, imag=0.0):
        Okay: return magic(r=real, i=imag)
        Okay: boolean(a == b)
        Okay: boolean(a != b)
        Okay: boolean(a <= b)
        Okay: boolean(a >= b)
        Okay: def foo(arg: int = 42):
        Okay: async def foo(arg: int = 42):
        
        E251: def complex(real, imag = 0.0):
        E251: return magic(r = real, i = imag)
        ```
      函数 whitespace_before_comment(logical_line: , tokens: )
        ```
        Separate inline comments by at least two spaces.
        
        An inline comment is a comment on the same line as a statement.  Inline
        comments should be separated by at least two spaces from the statement.
        They should start with a # and a single space.
        
        Each line of a block comment starts with a # and a single space
        (unless it is indented text inside the comment).
        
        Okay: x = x + 1  # Increment x
        Okay: x = x + 1    # Increment x
        Okay: # Block comment
        E261: x = x + 1 # Increment x
        E262: x = x + 1  #Increment x
        E262: x = x + 1  #  Increment x
        E265: #Block comment
        E266: ### Block comment
        ```
      函数 imports_on_separate_lines(logical_line: )
        ```
        Place imports on separate lines.
        
        Okay: import os\nimport sys
        E401: import sys, os
        
        Okay: from subprocess import Popen, PIPE
        Okay: from myclas import MyClass
        Okay: from foo.bar.yourclass import YourClass
        Okay: import myclass
        Okay: import foo.bar.yourclass
        ```
      函数 module_imports_on_top_of_file(logical_line: , indent_level: , checker_state: , noqa: )
        ```
        Place imports at the top of the file.
        
        Always put imports at the top of the file, just after any module comments
        and docstrings, and before module globals and constants.
        
        Okay: import os
        Okay: # this is a comment\nimport os
        Okay: '''this is a module docstring'''\nimport os
        Okay: r'''this is a module docstring'''\nimport os
        Okay: try:\n    import x\nexcept:\n    pass\nelse:\n    pass\nimport y
        Okay: try:\n    import x\nexcept:\n    pass\nfinally:\n    pass\nimport y
        E402: a=1\nimport os
        E402: 'One string'\n"Two string"\nimport os
        E402: a=1\nfrom sys import x
        
        Okay: if x:\n    import os
        ```
      函数 compound_statements(logical_line: )
        ```
        Compound statements (on the same line) are generally discouraged.
        
        While sometimes it's okay to put an if/for/while with a small body
        on the same line, never do this for multi-clause statements.
        Also avoid folding such long lines!
        
        Always use a def statement instead of an assignment statement that
        binds a lambda expression directly to a name.
        
        Okay: if foo == 'blah':\n    do_blah_thing()
        Okay: do_one()
        Okay: do_two()
        Okay: do_three()
        
        E701: if foo == 'blah': do_blah_thing()
        E701: for x in lst: total += x
        E701: while t < 10: t = delay()
        E701: if foo == 'blah': do_blah_thing()
        E701: else: do_non_blah_thing()
        E701: try: something()
        E701: finally: cleanup()
        E701: if foo == 'blah': one(); two(); three()
        E702: do_one(); do_two(); do_three()
        E703: do_four();  # useless semicolon
        E704: def f(x): return 2*x
        E731: f = lambda x: 2*x
        ```
      函数 explicit_line_join(logical_line: , tokens: )
        ```
        Avoid explicit line join between brackets.
        
        The preferred way of wrapping long lines is by using Python's implied line
        continuation inside parentheses, brackets and braces.  Long lines can be
        broken over multiple lines by wrapping expressions in parentheses.  These
        should be used in preference to using a backslash for line continuation.
        
        E502: aaa = [123, \\n       123]
        E502: aaa = ("bbb " \\n       "ccc")
        
        Okay: aaa = [123,\n       123]
        Okay: aaa = ("bbb "\n       "ccc")
        Okay: aaa = "bbb " \\n    "ccc"
        Okay: aaa = 123  # \\
        ```
      函数 break_around_binary_operator(logical_line: , tokens: )
        ```
        Avoid breaks before binary operators.
        
        The preferred place to break around a binary operator is after the
        operator, not before it.
        
        W503: (width == 0\n + height == 0)
        W503: (width == 0\n and height == 0)
        
        Okay: (width == 0 +\n height == 0)
        Okay: foo(\n    -x)
        Okay: foo(x\n    [])
        Okay: x = '''\n''' + ''
        Okay: foo(x,\n    -y)
        Okay: foo(x,  # comment\n    -y)
        Okay: var = (1 &\n       ~2)
        Okay: var = (1 /\n       -2)
        Okay: var = (1 +\n       -1 +\n       -2)
        ```
      函数 comparison_to_singleton(logical_line: , noqa: )
        ```
        Comparison to singletons should use "is" or "is not".
        
        Comparisons to singletons like None should always be done
        with "is" or "is not", never the equality operators.
        
        Okay: if arg is not None:
        E711: if arg != None:
        E711: if None == arg:
        E712: if arg == True:
        E712: if False == arg:
        
        Also, beware of writing if x when you really mean if x is not None --
        e.g. when testing whether a variable or argument that defaults to None was
        set to some other value.  The other value might have a type (such as a
        container) that could be false in a boolean context!
        ```
      函数 comparison_negative(logical_line: )
        ```
        Negative comparison should be done using "not in" and "is not".
        
        Okay: if x not in y:\n    pass
        Okay: assert (X in Y or X is Z)
        Okay: if not (X in Y):\n    pass
        Okay: zz = x is not y
        E713: Z = not X in Y
        E713: if not X.B in Y:\n    pass
        E714: if not X is Y:\n    pass
        E714: Z = not X.B is Y
        ```
      函数 comparison_type(logical_line: , noqa: )
        ```
        Object type comparisons should always use isinstance().
        
        Do not compare types directly.
        
        Okay: if isinstance(obj, int):
        E721: if type(obj) is type(1):
        
        When checking if an object is a string, keep in mind that it might be a
        unicode string too! In Python 2.3, str and unicode have a common base
        class, basestring, so you can do:
        
        Okay: if isinstance(obj, basestring):
        Okay: if type(a1) is type(b1):
        ```
      函数 ambiguous_identifier(logical_line: , tokens: )
        ```
        Never use the characters 'l', 'O', or 'I' as variable names.
        
        In some fonts, these characters are indistinguishable from the numerals
        one and zero. When tempted to use 'l', use 'L' instead.
        
        Okay: L = 0
        Okay: o = 123
        Okay: i = 42
        E741: l = 0
        E741: O = 123
        E741: I = 42
        
        Variables can be bound in several other contexts, including class and
        function definitions, 'global' and 'nonlocal' statements, exception
        handlers, and 'with' statements.
        
        Okay: except AttributeError as o:
        Okay: with lock as L:
        E741: except AttributeError as O:
        E741: with lock as l:
        E741: global I
        E741: nonlocal l
        E742: class I(object):
        E743: def l(x):
        ```
      函数 python_3000_has_key(logical_line: , noqa: )
        ```
        The {}.has_key() method is removed in Python 3: use the 'in' operator.
        
        Okay: if "alph" in d:\n    print(d["alph"])
        W601: assert d.has_key('alph')
        ```
      函数 python_3000_raise_comma(logical_line: )
        ```
        When raising an exception, use "raise ValueError('message')".
        
        The older form is removed in Python 3.
        
        Okay: raise DummyError("Message")
        W602: raise DummyError, "Message"
        ```
      函数 python_3000_not_equal(logical_line: )
        ```
        New code should always use != instead of <>.
        
        The older syntax is removed in Python 3.
        
        Okay: if a != 'no':
        W603: if a <> 'no':
        ```
      函数 python_3000_backticks(logical_line: )
        ```
        Use repr() instead of backticks in Python 3.
        
        Okay: val = repr(1 + 2)
        W604: val = `1 + 2`
        ```
      函数 expand_indent(line: )
        ```
        Return the amount of indentation.
        
        Tabs are expanded to the next multiple of 8.
        
        >>> expand_indent('    ')
        4
        >>> expand_indent('\t')
        8
        >>> expand_indent('       \t')
        8
        >>> expand_indent('        \t')
        16
        ```
      函数 mute_string(text: )
        ```
        Replace contents with 'xxx' to prevent syntax matching.
        
        >>> mute_string('"abc"')
        '"xxx"'
        >>> mute_string("'''abc'''")
        "'''xxx'''"
        >>> mute_string("r'abc'")
        "r'xxx'"
        ```
      函数 parse_udiff(diff: , patterns: , parent: )
        ```
        Return a dictionary of matching lines.
        ```
      函数 normalize_paths(value: , parent: )
        ```
        Parse a comma-separated list of paths.
        
        Return a list of absolute paths.
        ```
      函数 filename_match(filename: , patterns: , default: )
        ```
        Check if patterns contains a pattern that matches filename.
        
        If patterns is unspecified, this always returns True.
        ```
      函数 update_counts(s: , counts: )
        ```
        Adds one to the counts of each appearance of characters in s,
        for characters in counts
        ```
      函数 _is_eol_token(token: )
      函数 _get_parameters(function: )
      函数 register_check(check: , codes: )
        ```
        Register a new check object.
        ```
      函数 init_checks_registry()
        ```
        Register all globally visible functions.
        
        The first argument name is either 'physical_line' or 'logical_line'.
        ```
      类 Checker:
        ```
        Load a Python source file, tokenize it, check coding style.
        ```
        基类: Name(id='object', ctx=Load())
        函数 __init__(self: , filename: , lines: , options: , report: )
        函数 report_invalid_syntax(self: )
          ```
          Check if the syntax is valid.
          ```
        函数 readline(self: )
          ```
          Get the next line from the input buffer.
          ```
        函数 run_check(self: , check: , argument_names: )
          ```
          Run a check plugin.
          ```
        函数 init_checker_state(self: , name: , argument_names: )
          ```
          Prepare custom state for the specific checker plugin.
          ```
        函数 check_physical(self: , line: )
          ```
          Run all physical checks on a raw input line.
          ```
        函数 build_tokens_line(self: )
          ```
          Build a logical line from tokens.
          ```
        函数 check_logical(self: )
          ```
          Build a line from tokens and run all logical checks on it.
          ```
        函数 check_ast(self: )
          ```
          Build the file's AST and run all AST checks.
          ```
        函数 generate_tokens(self: )
          ```
          Tokenize the file, run physical line checks and yield tokens.
          ```
        函数 maybe_check_physical(self: , token: )
          ```
          If appropriate (based on token), check current physical line(s).
          ```
        函数 check_all(self: , expected: , line_offset: )
          ```
          Run all checks on the input file.
          ```
      类 BaseReport:
        ```
        Collect the results of the checks.
        ```
        基类: Name(id='object', ctx=Load())
        函数 start(self: )
          ```
          Start the timer.
          ```
        函数 stop(self: )
          ```
          Stop the timer.
          ```
        函数 init_file(self: , filename: , lines: , expected: , line_offset: )
          ```
          Signal a new file.
          ```
        函数 increment_logical_line(self: )
          ```
          Signal a new logical line.
          ```
        函数 error(self: , line_number: , offset: , text: , check: )
          ```
          Report an error, according to options.
          ```
        函数 get_file_results(self: )
          ```
          Return the count of errors and warnings for this file.
          ```
        函数 get_count(self: , prefix: )
          ```
          Return the total count of errors and warnings.
          ```
        函数 get_statistics(self: , prefix: )
          ```
          Get statistics for message codes that start with the prefix.
          
          prefix='' matches all errors and warnings
          prefix='E' matches all errors
          prefix='W' matches all warnings
          prefix='E4' matches all errors that have to do with imports
          ```
        函数 print_statistics(self: , prefix: )
          ```
          Print overall statistics (number of errors and warnings).
          ```
        函数 print_benchmark(self: )
          ```
          Print benchmark numbers.
          ```
      类 FileReport:
        ```
        Collect the results of the checks and print only the filenames.
        ```
        基类: Name(id='BaseReport', ctx=Load())
      类 StandardReport:
        ```
        Collect and print the results of the checks.
        ```
        基类: Name(id='BaseReport', ctx=Load())
      类 DiffReport:
        ```
        Collect and print the results for the changed lines only.
        ```
        基类: Name(id='StandardReport', ctx=Load())
      类 StyleGuide:
        ```
        Initialize a PEP-8 instance with few options.
        ```
        基类: Name(id='object', ctx=Load())
        函数 init_report(self: , reporter: )
          ```
          Initialize the report instance.
          ```
        函数 check_files(self: , paths: )
          ```
          Run all checks on the paths.
          ```
        函数 input_file(self: , filename: , lines: , expected: , line_offset: )
          ```
          Run all checks on a Python source file.
          ```
        函数 input_dir(self: , dirname: )
          ```
          Check all files in this directory and all subdirectories.
          ```
        函数 excluded(self: , filename: , parent: )
          ```
          Check if the file should be excluded.
          
          Check if 'options.exclude' contains a pattern that matches filename.
          ```
        函数 ignore_code(self: , code: )
          ```
          Check if the error code should be ignored.
          
          If 'options.select' contains a prefix of the error code,
          return False.  Else, if 'options.ignore' contains a prefix of
          the error code, return True.
          ```
        函数 get_checks(self: , argument_name: )
          ```
          Get all the checks for this category.
          
          Find all globally visible functions where the first argument name
          starts with argument_name and which contain selected tests.
          ```
      函数 get_parser(prog: , version: )
        ```
        Create the parser for the program.
        ```
      函数 read_config(options: , args: , arglist: , parser: )
        ```
        Read and parse configurations.
        
        If a config file is specified on the command line with the "--config"
        option, then only it is used for configuration.
        
        Otherwise, the user configuration (~/.config/pycodestyle) and any local
        configurations in the current directory or above will be merged together
        (in that order) using the read method of ConfigParser.
        ```
      函数 process_options(arglist: , parse_argv: , config_file: , parser: )
        ```
        Process options passed either via arglist or via command line args.
        
        Passing in the ``config_file`` parameter allows other tools, such as flake8
        to specify their own options to be processed in pycodestyle.
        ```
      函数 _parse_multi_options(options: , split_token: )
        ```
        Split and strip and discard empties.
        
        Turns the following:
        
        A,
        B,
        
        into ["A", "B"]
        ```
      函数 _main()
        ```
        Parse options and run checks on Python source.
        ```
      函数 is_string_literal(line: )
      函数 is_binary_operator(token_type: , text: )
      函数 readlines(filename: )
        ```
        Read the source code.
        ```
      函数 stdin_get_value()
        ```
        Read the value from stdin.
        ```
      函数 _add_check(check: , kind: , codes: , args: )
    分析文件: benchmark.py
    类 FakeMotionEvent:
      基类: Name(id='MotionEvent', ctx=Load())
    类 bench_widget_creation:
      ```
      Widget: creation (10000 Widget)
      ```
      函数 run(self: )
    类 bench_widget_creation_with_root:
      ```
      Widget: creation (10000 Widget + 1 root)
      ```
    类 bench_widget_draw:
      ```
      Widget: empty drawing (10000 Widget + 1 root)
      ```
      函数 __init__(self: )
    类 bench_widget_dispatch:
      ```
      Widget: event dispatch (1000 on_update in 10*1000 Widget)
      ```
    类 bench_label_creation:
      ```
      Core: label creation (10000 * 10 a-z)
      ```
    类 bench_button_creation:
      ```
      Core: button creation (10000 * 10 a-z)
      ```
    类 bench_label_creation_with_tick:
      ```
      Core: label creation (10000 * 10 a-z), with Clock.tick
      ```
    类 bench_button_creation_with_tick:
      ```
      Core: button creation (10000 * 10 a-z), with Clock.tick
      ```
    函数 log(s: , newline: )
    分析文件: gallery.py
    函数 iter_filename_info(dir_name: )
      ```
      Yield info (dict) of each matching screenshot found walking the
      directory dir_name. A matching screenshot uses double underscores to
      separate fields, i.e. path__to__filename__py.png as the screenshot for
      examples/path/to/filename.py.
      
      Files not ending with .png are ignored, others are either parsed or
      yield an error.
      
      Info fields 'dunder', 'dir', 'file', 'ext', 'source' if not 'error'
      ```
    函数 parse_docstring_info(text: )
      ```
      parse docstring from text (normal string with '
      's) and return an info
          dict. A docstring should the first triple quoted string, have a title
          followed by a line of equal signs, and then a description at
          least one sentence long.
      
          fields are 'docstring', 'title', and 'first_sentence' if not 'error'
          'first_sentence' is a single line without newlines.
          
      ```
    函数 iter_docstring_info(dir_name: )
      ```
      Iterate over screenshots in directory, yield info from the file
      name and initial parse of the docstring. Errors are logged, but
      files with errors are skipped.
      ```
    函数 enhance_info_description(info: , line_length: )
      ```
      Using the info['description'], add fields to info.
      
      info['files'] is the source filename and any filenames referenced by the
      magic words in the description, e.g. 'the file xxx.py' or
      'The image this.png'. These are as written in the description, do
      not allow ../dir notation, and are relative to the source directory.
      
      info['enhanced_description'] is the description, as an array of
      paragraphs where each paragraph is an array of lines wrapped to width
      line_length. This enhanced description include the rst links to
      the files of info['files'].
      ```
    函数 get_infos(dir_name: )
      ```
      return infos, an array info dicts for each matching screenshot in the
      dir, sorted by source file name, and adding the field 'num' as he unique
      order in this array of dicts'.
      ```
    函数 make_gallery_page(infos: )
      ```
      return string of the rst (Restructured Text) of the gallery page,
      showing information on all screenshots found.
      ```
    函数 make_detail_page(info: )
      ```
      return str of the rst text for the detail page of the file in info. 
      ```
    函数 write_file(name: , s: )
      ```
      write the string to the filename 
      ```
    函数 make_index(infos: )
      ```
      return string of the rst for the gallery's index.rst file. 
      ```
    函数 write_all_rst_pages()
      ```
      Do the main task of writing the gallery,
      detail, and index rst pages.
      ```
    函数 a(s: )
      ```
      append formatted s to output, which will be joined into lines 
      ```
    highlight/
      分析文件: __init__.py
    分析文件: __init__.py
  分析文件: resources.py
  函数 resource_find(filename: , use_cache: )
    ```
    Search for a resource in the list of paths.
    Use resource_add_path to add a custom path to the search.
    By default, results are cached for 60 seconds.
    This can be disabled using use_cache=False.
    
    .. versionchanged:: 2.1.0
        `use_cache` parameter added and made True by default.
    ```
  函数 resource_add_path(path: )
    ```
    Add a custom path to search in.
        
    ```
  函数 resource_remove_path(path: )
    ```
    Remove a search path.
    
    .. versionadded:: 1.0.8
    ```
  lib/
    gstplayer/
      分析文件: __init__.py
    分析文件: ddsfile.py
    函数 dxt_to_str(dxt: )
    函数 str_to_dxt(dxt: )
    函数 align_value(val: , b: )
    函数 check_flags(val: , fl: )
    函数 dxt_size(w: , h: , dxt: )
    类 QueryDict:
      基类: Name(id='dict', ctx=Load())
      函数 __getattr__(self: , attr: )
      函数 __setattr__(self: , attr: , value: )
    类 DDSException:
      基类: Name(id='Exception', ctx=Load())
    类 DDSFile:
      基类: Name(id='object', ctx=Load())
      函数 __init__(self: , filename: )
      函数 load(self: , filename: )
      函数 save(self: , filename: )
      函数 add_image(self: , level: , bpp: , fmt: , width: , height: , data: )
      函数 __repr__(self: )
      函数 _get_size(self: )
      函数 _set_size(self: , size: )
      函数 _get_dxt(self: )
      函数 _set_dxt(self: , dxt: )
    vidcore_lite/
      分析文件: __init__.py
    pango/
    分析文件: mtdev.py
    类 timeval:
      基类: Name(id='Structure', ctx=Load())
    类 input_event:
      基类: Name(id='Structure', ctx=Load())
    类 input_absinfo:
      基类: Name(id='Structure', ctx=Load())
    类 mtdev_caps:
      基类: Name(id='Structure', ctx=Load())
    类 mtdev:
      基类: Name(id='Structure', ctx=Load())
    类 Device:
      函数 __init__(self: , filename: )
      函数 close(self: )
        ```
        Close the mtdev converter
                
        ```
      函数 idle(self: , ms: )
        ```
        Check state of kernel device
        
        :Parameters:
            `ms`: int
                Number of milliseconds to wait for activity
        
        :Return:
            Return True if the device is idle, i.e, there are no fetched events
            in the pipe and there is nothing to fetch from the device.
        ```
      函数 get(self: )
      函数 has_mtdata(self: )
        ```
        Return True if the device has multitouch data.
                
        ```
      函数 has_slot(self: )
        ```
        Return True if the device has slot information.
                
        ```
      函数 has_abs(self: , index: )
        ```
        Return True if the device has abs data.
        
        :Parameters:
            `index`: int
                One of const starting with a name ABS_MT_
        ```
      函数 get_max_abs(self: )
        ```
        Return the maximum number of abs information available.
                
        ```
      函数 get_slot(self: )
        ```
        Return the slot data.
                
        ```
      函数 get_abs(self: , index: )
        ```
        Return the abs data.
        
        :Parameters:
            `index`: int
                One of const starting with a name ABS_MT_
        ```
    分析文件: __init__.py
  effects/
    分析文件: opacityscroll.py
    类 OpacityScrollEffect:
      ```
      OpacityScrollEffect class. Uses the overscroll
      information to reduce the opacity of the scrollview widget. When the user
      stops the drag, the opacity is set back to 1.
      ```
      基类: Name(id='DampedScrollEffect', ctx=Load())
      函数 on_overscroll(self: )
    分析文件: kinetic.py
    类 KineticEffect:
      ```
      Kinetic effect class. See module documentation for more information.
          
      ```
      基类: Name(id='EventDispatcher', ctx=Load())
      函数 __init__(self: )
      函数 apply_distance(self: , distance: )
      函数 start(self: , val: , t: )
        ```
        Start the movement.
        
        :Parameters:
            `val`: float or int
                Value of the movement
            `t`: float, defaults to None
                Time when the movement happen. If no time is set, it will use
                time.time()
        ```
      函数 update(self: , val: , t: )
        ```
        Update the movement.
        
        See :meth:`start` for the arguments.
        ```
      函数 stop(self: , val: , t: )
        ```
        Stop the movement.
        
        See :meth:`start` for the arguments.
        ```
      函数 cancel(self: )
        ```
        Cancel a movement. This can be used in case :meth:`stop` cannot be
        called. It will reset :attr:`is_manual` to False, and compute the
        movement if the velocity is > 0.
        ```
      函数 update_velocity(self: , dt: )
        ```
        (internal) Update the velocity according to the frametime and
        friction.
        ```
    分析文件: scroll.py
    类 ScrollEffect:
      ```
      ScrollEffect class. See the module documentation for more information.
          
      ```
      基类: Name(id='KineticEffect', ctx=Load())
      函数 reset(self: , pos: )
        ```
        (internal) Reset the value and the velocity to the `pos`.
        Mostly used when the bounds are checked.
        ```
      函数 on_value(self: )
      函数 start(self: , val: , t: )
      函数 update(self: , val: , t: )
      函数 stop(self: , val: , t: )
    分析文件: __init__.py
    分析文件: dampedscroll.py
    类 DampedScrollEffect:
      ```
      DampedScrollEffect class. See the module documentation for more
      information.
      ```
      基类: Name(id='ScrollEffect', ctx=Load())
      函数 update_velocity(self: , dt: )
      函数 on_value(self: )
      函数 on_overscroll(self: )
      函数 apply_distance(self: , distance: )
  uix/
    分析文件: recyclegridlayout.py
    类 RecycleGridLayout:
      基类: Name(id='RecycleLayout', ctx=Load())
      基类: Name(id='GridLayout', ctx=Load())
      函数 __init__(self: )
      函数 on_children(self: , instance: , value: )
      函数 _fill_rows_cols_sizes(self: )
      函数 _update_rows_cols_sizes(self: , changed: )
      函数 compute_layout(self: , data: , flags: )
      函数 get_view_index_at(self: , pos: )
      函数 compute_visible_views(self: , data: , viewport: )
      函数 _calculate_idx_from_a_view_idx(self: , n_cols: , n_rows: , view_idx: )
        ```
        returns a tuple of (column-index, row-index) from a view-index
        ```
    分析文件: button.py
    类 Button:
      ```
      Button class, see module documentation for more information.
      
      .. versionchanged:: 1.8.0
          The behavior / logic of the button has been moved to
          :class:`~kivy.uix.behaviors.ButtonBehaviors`.
      ```
      基类: Name(id='ButtonBehavior', ctx=Load())
      基类: Name(id='Label', ctx=Load())
    分析文件: textinput.py
    类 Selector:
      基类: Name(id='ButtonBehavior', ctx=Load())
      基类: Name(id='Image', ctx=Load())
      函数 __init__(self: )
      函数 update_transform(self: , cb: )
      函数 transform_touch(self: , touch: )
      函数 on_touch_down(self: , touch: )
    类 TextInputCutCopyPaste:
      基类: Name(id='Bubble', ctx=Load())
      函数 on_touch_up(self: , touch: )
      函数 on_textinput(self: , instance: , value: )
      函数 _check_parent(self: , dt: )
      函数 on_parent(self: , instance: , value: )
      函数 do(self: , action: )
      函数 hide(self: )
    类 TextInput:
      ```
      TextInput class. See module documentation for more information.
      
      :Events:
          `on_text_validate`
              Fired only in multiline=False mode when the user hits 'enter'.
              This will also unfocus the textinput.
          `on_double_tap`
              Fired when a double tap happens in the text input. The default
              behavior selects the text around the cursor position. More info at
              :meth:`on_double_tap`.
          `on_triple_tap`
              Fired when a triple tap happens in the text input. The default
              behavior selects the line around the cursor position. More info at
              :meth:`on_triple_tap`.
          `on_quad_touch`
              Fired when four fingers are touching the text input. The default
              behavior selects the whole text. More info at
              :meth:`on_quad_touch`.
      
      .. warning::
          When changing a :class:`TextInput` property that requires re-drawing,
          e.g. modifying the :attr:`text`, the updates occur on the next
          clock cycle and not instantly. This might cause any changes to the
          :class:`TextInput` that occur between the modification and the next
          cycle to be ignored, or to use previous values. For example, after
          a update to the :attr:`text`, changing the cursor in the same clock
          frame will move it using the previous text and will likely end up in an
          incorrect position. The solution is to schedule any updates to occur
          on the next clock cycle using
          :meth:`~kivy.clock.ClockBase.schedule_once`.
      
      .. Note::
          Selection is cancelled when TextInput is focused. If you need to
          show selection when TextInput is focused, you should delay
          (use Clock.schedule) the call to the functions for selecting
          text (select_all, select_text).
      
      .. versionchanged:: 1.10.0
          `background_disabled_active` has been removed.
      
      .. versionchanged:: 1.9.0
      
          :class:`TextInput` now inherits from
          :class:`~kivy.uix.behaviors.FocusBehavior`.
          :attr:`~kivy.uix.behaviors.FocusBehavior.keyboard_mode`,
          :meth:`~kivy.uix.behaviors.FocusBehavior.show_keyboard`,
          :meth:`~kivy.uix.behaviors.FocusBehavior.hide_keyboard`,
          :meth:`~kivy.uix.behaviors.FocusBehavior.focus`,
          and :attr:`~kivy.uix.behaviors.FocusBehavior.input_type`
          have been removed since they are now inherited
          from :class:`~kivy.uix.behaviors.FocusBehavior`.
      
      .. versionchanged:: 1.7.0
          `on_double_tap`, `on_triple_tap` and `on_quad_touch` events added.
      
      .. versionchanged:: 2.1.0
          :attr:`~kivy.uix.behaviors.FocusBehavior.keyboard_suggestions`
          is now inherited from :class:`~kivy.uix.behaviors.FocusBehavior`.
      ```
      基类: Name(id='FocusBehavior', ctx=Load())
      基类: Name(id='Widget', ctx=Load())
      函数 on_text_validate(self: )
      函数 cursor_index(self: , cursor: )
        ```
        Return the cursor index in the text/value.
                
        ```
      函数 cursor_offset(self: )
        ```
        Get the cursor x offset on the current line.
                
        ```
      函数 get_cursor_from_index(self: , index: )
        ```
        Return the (col, row) of the cursor from text index.
                
        ```
      函数 select_text(self: , start: , end: )
        ```
        Select a portion of text displayed in this TextInput.
        
        .. versionadded:: 1.4.0
        
        :Parameters:
            `start`
                Index of textinput.text from where to start selection
            `end`
                Index of textinput.text till which the selection should be
                displayed
        ```
      函数 select_all(self: )
        ```
        Select all of the text displayed in this TextInput.
        
        .. versionadded:: 1.4.0
        ```
      函数 _auto_indent(self: , substring: )
      函数 insert_text(self: , substring: , from_undo: )
        ```
        Insert new text at the current cursor position. Override this
        function in order to pre-process text for input validation.
        ```
      函数 _get_line_from_cursor(self: , start: , new_text: , lines: , lines_flags: )
      函数 _set_unredo_insert(self: , ci: , sci: , substring: , from_undo: )
      函数 reset_undo(self: )
        ```
        Reset undo and redo lists from memory.
        
        .. versionadded:: 1.3.0
        ```
      函数 do_redo(self: )
        ```
        Do redo operation.
        
        .. versionadded:: 1.3.0
        
        This action re-does any command that has been un-done by
        do_undo/ctrl+z. This function is automatically called when
        `ctrl+r` keys are pressed.
        ```
      函数 do_undo(self: )
        ```
        Do undo operation.
        
        .. versionadded:: 1.3.0
        
        This action un-does any edits that have been made since the last
        call to reset_undo().
        This function is automatically called when `ctrl+z` keys are pressed.
        ```
      函数 do_backspace(self: , from_undo: , mode: )
        ```
        Do backspace operation from the current cursor position.
        This action might do several things:
        
            - removing the current selection if available.
            - removing the previous char and move the cursor back.
            - do nothing, if we are at the start.
        ```
      函数 _set_unredo_bkspc(self: , ol_index: , new_index: , substring: , from_undo: , mode: )
      函数 _move_cursor_word_left(self: , index: )
      函数 _move_cursor_word_right(self: , index: )
      函数 _expand_range(self: , ifrom: , ito: )
      函数 _expand_rows(self: , rfrom: , rto: )
      函数 _shift_lines(self: , direction: , rows: , old_cursor: , from_undo: )
      函数 pgmove_speed(self: )
        ```
        how much vertical distance hitting pg_up or pg_down will move
                
        ```
      函数 _move_cursor_up(self: , col: , row: , control: , alt: )
      函数 _move_cursor_down(self: , col: , row: , control: , alt: )
      函数 do_cursor_movement(self: , action: , control: , alt: )
        ```
        Move the cursor relative to its current position.
        Action can be one of :
        
            - cursor_left: move the cursor to the left
            - cursor_right: move the cursor to the right
            - cursor_up: move the cursor on the previous line
            - cursor_down: move the cursor on the next line
            - cursor_home: move the cursor at the start of the current line
            - cursor_end: move the cursor at the end of current line
            - cursor_pgup: move one "page" before
            - cursor_pgdown: move one "page" after
        
        In addition, the behavior of certain actions can be modified:
        
            - control + cursor_left: move the cursor one word to the left
            - control + cursor_right: move the cursor one word to the right
            - control + cursor_up: scroll up one line
            - control + cursor_down: scroll down one line
            - control + cursor_home: go to beginning of text
            - control + cursor_end: go to end of text
            - alt + cursor_up: shift line(s) up
            - alt + cursor_down: shift line(s) down
        
        .. versionchanged:: 1.9.1
        ```
      函数 get_cursor_from_xy(self: , x: , y: )
        ```
        Return the (col, row) of the cursor from an (x, y) position.
                
        ```
      函数 cancel_selection(self: )
        ```
        Cancel current selection (if any).
                
        ```
      函数 delete_selection(self: , from_undo: )
        ```
        Delete the current text selection (if any).
                
        ```
      函数 _set_unredo_delsel(self: , a: , b: , substring: , from_undo: )
      函数 _update_selection(self: , finished: )
        ```
        Update selection text and order of from/to if finished is True.
        Can be called multiple times until finished is True.
        ```
      函数 long_touch(self: , dt: )
      函数 cancel_long_touch_event(self: )
      函数 _select_word(self: , delimiters: )
      函数 on_double_tap(self: )
        ```
        This event is dispatched when a double tap happens
        inside TextInput. The default behavior is to select the
        word around the current cursor position. Override this to provide
        different behavior. Alternatively, you can bind to this
        event to provide additional functionality.
        ```
      函数 on_triple_tap(self: )
        ```
        This event is dispatched when a triple tap happens
        inside TextInput. The default behavior is to select the
        line around current cursor position. Override this to provide
        different behavior. Alternatively, you can bind to this
        event to provide additional functionality.
        ```
      函数 on_quad_touch(self: )
        ```
        This event is dispatched when four fingers are touching
        inside TextInput. The default behavior is to select all text.
        Override this to provide different behavior. Alternatively,
        you can bind to this event to provide additional functionality.
        ```
      函数 _cancel_update_selection(self: , touch: )
      函数 on_touch_move(self: , touch: )
      函数 scroll_text_from_swipe(self: , touch: )
      函数 _handle_pressed(self: , instance: )
      函数 _handle_released(self: , instance: )
      函数 _handle_move(self: , instance: , touch: )
      函数 _position_handles(self: )
      函数 _hide_handles(self: , win: )
      函数 _show_handles(self: , dt: )
      函数 _show_cut_copy_paste(self: , pos: , win: , parent_changed: , mode: , pos_in_window: )
        ```
        Show a bubble with cut copy and paste buttons
        ```
      函数 _hide_cut_copy_paste(self: , win: )
      函数 _reload_remove_observer(wr: )
        ```
        called when the textinput is deleted
        ```
      函数 _on_textinput_focused(self: , instance: , value: )
      函数 _ensure_clipboard(self: )
      函数 cut(self: )
        ```
        Copy current selection to clipboard then delete it from TextInput.
        
        .. versionadded:: 1.8.0
        ```
      函数 _cut(self: , data: )
      函数 copy(self: , data: )
        ```
        Copy the value provided in argument `data` into current clipboard.
        If data is not of type string it will be converted to string.
        If no data is provided then current selection if present is copied.
        
        .. versionadded:: 1.8.0
        ```
      函数 paste(self: )
        ```
        Insert text from system :class:`~kivy.core.clipboard.Clipboard`
        into the :class:`~kivy.uix.textinput.TextInput` at current cursor
        position.
        
        .. versionadded:: 1.8.0
        ```
      函数 _update_cutbuffer(self: )
      函数 _get_text_width(self: , text: , tab_width: , _label_cached: )
        ```
        Return the width of a text, according to the current line options
        ```
      函数 on_cursor_blink(self: , instance: , value: )
        ```
        trigger blink event reset to switch blinking while focused
        ```
      函数 _do_blink_cursor(self: , dt: )
      函数 _reset_cursor_blink(self: )
      函数 on_cursor(self: , instance: , value: )
        ```
        When the cursor is moved, reset cursor blinking to keep it showing,
        and update all the graphics.
        ```
      函数 _delete_line(self: , idx: )
        ```
        Delete current line, and fix cursor position
        ```
      函数 _set_line_text(self: , line_num: , text: )
        ```
        Set current line with other text than the default one.
        ```
      函数 _trigger_refresh_line_options(self: )
      函数 _refresh_line_options(self: )
      函数 _trigger_refresh_text(self: )
      函数 _update_text_options(self: )
      函数 _refresh_text_from_trigger(self: , dt: )
      函数 _refresh_text_from_property(self: )
      函数 _refresh_text(self: , text: )
        ```
        Refresh all the lines from a new text.
        By using cache in internal functions, this method should be fast.
        ```
      函数 _insert_lines(self: , start: , finish: , len_lines: , _lines_flags: , _lines: , _lines_labels: , _line_rects: )
      函数 _trigger_update_graphics(self: )
      函数 _update_graphics(self: )
        ```
        Update all the graphics according to the current internal values.
        ```
      函数 _draw_line(self: , value: , line_num: , texture: , viewport_pos: , line_height: , miny: , maxy: , x: , y: , base_dir: , halign: , rects: , auto_halign_r: )
      函数 _update_graphics_selection(self: )
      函数 _draw_selection(self: , pos: , size: , line_num: , selection_start: , selection_end: , lines: , get_text_width: , tab_width: , label_cached: , width_minus_padding: , padding_left: , padding_right: , x: , canvas_add: , selection_color: )
      函数 on_size(self: , instance: , value: )
      函数 _get_row_width(self: , row: )
      函数 _get_cursor_pos(self: )
      函数 _get_cursor_visual_height(self: )
      函数 _get_cursor_visual_pos(self: )
      函数 _get_line_options(self: )
      函数 _create_line_label(self: , text: , hint: )
      函数 _tokenize(self: , text: )
      函数 _split_smart(self: , text: )
        ```
        Do a "smart" split. If not multiline, or if wrap is set,
        we are not doing smart split, just a split on line break.
        Otherwise, we are trying to split as soon as possible, to prevent
        overflow on the widget.
        ```
      函数 _key_down(self: , key: , repeat: )
      函数 _key_up(self: , key: , repeat: )
      函数 keyboard_on_key_down(self: , window: , keycode: , text: , modifiers: )
      函数 _handle_command(self: , command: )
      函数 _handle_shortcut(self: , key: )
      函数 keyboard_on_key_up(self: , window: , keycode: )
      函数 keyboard_on_textinput(self: , window: , text: )
      函数 _bind_keyboard(self: )
      函数 _unbind_keyboard(self: )
      函数 window_on_textedit(self: , window: , ime_input: )
      函数 on__hint_text(self: , instance: , value: )
      函数 _refresh_hint_text(self: )
      函数 _get_cursor(self: )
      函数 _set_cursor(self: , pos: )
      函数 _adjust_viewport(self: , cc: , cr: )
      函数 _get_cursor_col(self: )
      函数 _get_cursor_row(self: )
      函数 on_padding_x(self: , instance: , value: )
      函数 on_padding_y(self: , instance: , value: )
      函数 get_sel_from(self: )
      函数 get_sel_to(self: )
      函数 on_selection_text(self: , instance: , value: )
      函数 _get_text(self: )
      函数 _set_text(self: , text: )
      函数 _set_hint_text(self: , value: )
      函数 _get_hint_text(self: )
      函数 _get_min_height(self: )
      函数 on_handle_image_middle(self: , instance: , value: )
      函数 on_handle_image_left(self: , instance: , value: )
      函数 on_handle_image_right(self: , instance: , value: )
    函数 triggered()
    函数 _textinput_clear_cache()
    类 TextInputApp:
      基类: Name(id='App', ctx=Load())
      函数 build(self: )
      函数 update_time(self: , dt: )
    函数 decorator_func(func: )
    函数 handle_readonly(instance: , value: )
    函数 decorated_func()
    函数 cb(dt: )
    函数 hide_()
    分析文件: floatlayout.py
    类 FloatLayout:
      ```
      Float layout class. See module documentation for more information.
          
      ```
      基类: Name(id='Layout', ctx=Load())
      函数 __init__(self: )
      函数 do_layout(self: )
      函数 add_widget(self: , widget: )
      函数 remove_widget(self: , widget: )
    分析文件: rst.py
    类 RstVideoPlayer:
      基类: Name(id='VideoPlayer', ctx=Load())
    类 RstDocument:
      ```
      Base widget used to store an Rst document. See module documentation for
      more information.
      ```
      基类: Name(id='ScrollView', ctx=Load())
      函数 _get_bgc(self: )
      函数 _set_bgc(self: , value: )
      函数 __init__(self: )
      函数 on_source(self: , instance: , value: )
      函数 on_text(self: , instance: , value: )
      函数 render(self: )
        ```
        Force document rendering.
                
        ```
      函数 resolve_path(self: , filename: )
        ```
        Get the path for this filename. If the filename doesn't exist,
        it returns the document_root + filename.
        ```
      函数 preload(self: , filename: , encoding: , errors: )
        ```
        Preload a rst file to get its toctree and its title.
        
        The result will be stored in :attr:`toctrees` with the ``filename`` as
        key.
        ```
      函数 _load_from_source(self: )
      函数 _load_from_text(self: )
      函数 on_ref_press(self: , node: , ref: )
      函数 goto(self: , ref: )
        ```
        Scroll to the reference. If it's not found, nothing will be done.
        
        For this text::
        
            .. _myref:
        
            This is something I always wanted.
        
        You can do::
        
            from kivy.clock import Clock
            from functools import partial
        
            doc = RstDocument(...)
            Clock.schedule_once(partial(doc.goto, 'myref'), 0.1)
        
        .. note::
        
            It is preferable to delay the call of the goto if you just loaded
            the document because the layout might not be finished or the
            size of the RstDocument has not yet been determined. In
            either case, the calculation of the scrolling would be
            wrong.
        
            You can, however, do a direct call if the document is already
            loaded.
        
        .. versionadded:: 1.3.0
        ```
      函数 add_anchors(self: , node: )
    类 RstTitle:
      基类: Name(id='Label', ctx=Load())
    类 RstParagraph:
      基类: Name(id='Label', ctx=Load())
    类 RstTerm:
      基类: Name(id='AnchorLayout', ctx=Load())
    类 RstBlockQuote:
      基类: Name(id='GridLayout', ctx=Load())
    类 RstLiteralBlock:
      基类: Name(id='GridLayout', ctx=Load())
    类 RstList:
      基类: Name(id='GridLayout', ctx=Load())
    类 RstListItem:
      基类: Name(id='GridLayout', ctx=Load())
    类 RstListBullet:
      基类: Name(id='Label', ctx=Load())
    类 RstSystemMessage:
      基类: Name(id='GridLayout', ctx=Load())
    类 RstWarning:
      基类: Name(id='GridLayout', ctx=Load())
    类 RstNote:
      基类: Name(id='GridLayout', ctx=Load())
    类 RstImage:
      基类: Name(id='Image', ctx=Load())
    类 RstAsyncImage:
      基类: Name(id='AsyncImage', ctx=Load())
    类 RstDefinitionList:
      基类: Name(id='GridLayout', ctx=Load())
    类 RstDefinition:
      基类: Name(id='GridLayout', ctx=Load())
    类 RstFieldList:
      基类: Name(id='GridLayout', ctx=Load())
    类 RstFieldName:
      基类: Name(id='Label', ctx=Load())
    类 RstFieldBody:
      基类: Name(id='GridLayout', ctx=Load())
    类 RstFootnote:
      基类: Name(id='GridLayout', ctx=Load())
    类 RstFootName:
      基类: Name(id='Label', ctx=Load())
    类 RstGridLayout:
      基类: Name(id='GridLayout', ctx=Load())
    类 RstTable:
      基类: Name(id='GridLayout', ctx=Load())
    类 RstEntry:
      基类: Name(id='GridLayout', ctx=Load())
    类 RstTransition:
      基类: Name(id='Widget', ctx=Load())
    类 RstEmptySpace:
      基类: Name(id='Widget', ctx=Load())
    类 RstDefinitionSpace:
      基类: Name(id='Widget', ctx=Load())
    类 _ToctreeVisitor:
      基类: Attribute(value=Name(id='nodes', ctx=Load()), attr='NodeVisitor', ctx=Load())
      函数 push(self: , tree: )
      函数 pop(self: )
      函数 dispatch_visit(self: , node: )
      函数 dispatch_departure(self: , node: )
    类 _Visitor:
      基类: Attribute(value=Name(id='nodes', ctx=Load()), attr='NodeVisitor', ctx=Load())
      函数 brute_refs(self: , node: )
      函数 set_text(self: , node: , parent: )
      函数 colorize(self: , text: , name: )
    类 role_doc:
      基类: Attribute(value=Name(id='nodes', ctx=Load()), attr='Inline', ctx=Load())
      基类: Attribute(value=Name(id='nodes', ctx=Load()), attr='TextElement', ctx=Load())
    类 role_video:
      基类: Attribute(value=Name(id='nodes', ctx=Load()), attr='General', ctx=Load())
      基类: Attribute(value=Name(id='nodes', ctx=Load()), attr='TextElement', ctx=Load())
    类 VideoDirective:
      基类: Name(id='Directive', ctx=Load())
      函数 run(self: )
    函数 get_refs(condition: , backref: )
    函数 set_size(img: , size: )
    分析文件: scatter.py
    类 Scatter:
      ```
      Scatter class. See module documentation for more information.
      
      :Events:
          `on_transform_with_touch`:
              Fired when the scatter has been transformed by user touch
              or multitouch, such as panning or zooming.
          `on_bring_to_front`:
              Fired when the scatter is brought to the front.
      
      .. versionchanged:: 1.9.0
          Event `on_bring_to_front` added.
      
      .. versionchanged:: 1.8.0
          Event `on_transform_with_touch` added.
      ```
      基类: Name(id='Widget', ctx=Load())
      函数 _get_do_translation(self: )
      函数 _set_do_translation(self: , value: )
      函数 _get_bbox(self: )
      函数 _get_rotation(self: )
      函数 _set_rotation(self: , rotation: )
      函数 _get_scale(self: )
      函数 _set_scale(self: , scale: )
      函数 _get_center(self: )
      函数 _set_center(self: , center: )
      函数 _get_pos(self: )
      函数 _set_pos(self: , pos: )
      函数 _get_x(self: )
      函数 _set_x(self: , x: )
      函数 _get_y(self: )
      函数 _set_y(self: , y: )
      函数 get_right(self: )
      函数 set_right(self: , value: )
      函数 get_top(self: )
      函数 set_top(self: , value: )
      函数 get_center_x(self: )
      函数 set_center_x(self: , value: )
      函数 get_center_y(self: )
      函数 set_center_y(self: , value: )
      函数 __init__(self: )
      函数 on_transform(self: , instance: , value: )
      函数 collide_point(self: , x: , y: )
      函数 to_parent(self: , x: , y: )
      函数 to_local(self: , x: , y: )
      函数 _apply_transform(self: , m: , pos: )
      函数 apply_transform(self: , trans: , post_multiply: , anchor: )
        ```
        Transforms the scatter by applying the "trans" transformation
        matrix (on top of its current transformation state). The resultant
        matrix can be found in the :attr:`~Scatter.transform` property.
        
        :Parameters:
            `trans`: :class:`~kivy.graphics.transformation.Matrix`.
                Transformation matrix to be applied to the scatter widget.
            `anchor`: tuple, defaults to (0, 0).
                The point to use as the origin of the transformation
                (uses local widget space).
            `post_multiply`: bool, defaults to False.
                If True, the transform matrix is post multiplied
                (as if applied before the current transform).
        
        Usage example::
        
            from kivy.graphics.transformation import Matrix
            mat = Matrix().scale(3, 3, 3)
            scatter_instance.apply_transform(mat)
        ```
      函数 transform_with_touch(self: , touch: )
      函数 _bring_to_front(self: , touch: )
      函数 on_motion(self: , etype: , me: )
      函数 on_touch_down(self: , touch: )
      函数 on_touch_move(self: , touch: )
      函数 on_transform_with_touch(self: , touch: )
        ```
        Called when a touch event has transformed the scatter widget.
        By default this does nothing, but can be overridden by derived
        classes that need to react to transformations caused by user
        input.
        
        :Parameters:
            `touch`:
                The touch object which triggered the transformation.
        
        .. versionadded:: 1.8.0
        ```
      函数 on_bring_to_front(self: , touch: )
        ```
        Called when a touch event causes the scatter to be brought to the
        front of the parent (only if :attr:`auto_bring_to_front` is True)
        
        :Parameters:
            `touch`:
                The touch object which brought the scatter to front.
        
        .. versionadded:: 1.9.0
        ```
      函数 on_touch_up(self: , touch: )
    类 ScatterPlane:
      ```
      This is essentially an unbounded Scatter widget. It's a convenience
      class to make it easier to handle infinite planes.
      ```
      基类: Name(id='Scatter', ctx=Load())
    分析文件: carousel.py
    类 Carousel:
      ```
      Carousel class. See module documentation for more information.
          
      ```
      基类: Name(id='StencilView', ctx=Load())
      函数 _get_slides_container(self: )
      函数 _get_index(self: )
      函数 _set_index(self: , value: )
      函数 _prev_slide(self: )
      函数 _curr_slide(self: )
      函数 _next_slide(self: )
      函数 __init__(self: )
      函数 load_slide(self: , slide: )
        ```
        Animate to the slide that is passed as the argument.
        
        .. versionchanged:: 1.8.0
        ```
      函数 load_previous(self: )
        ```
        Animate to the previous slide.
        
        .. versionadded:: 1.7.0
        ```
      函数 load_next(self: , mode: )
        ```
        Animate to the next slide.
        
        .. versionadded:: 1.7.0
        ```
      函数 get_slide_container(self: , slide: )
      函数 _prev_equals_next(self: )
      函数 _insert_visible_slides(self: , _next_slide: , _prev_slide: )
      函数 _position_visible_slides(self: )
      函数 on_size(self: )
      函数 on_pos(self: )
      函数 on_index(self: )
      函数 on_slides(self: )
      函数 on__offset(self: )
      函数 _start_animation(self: )
      函数 _get_uid(self: , prefix: )
      函数 on_touch_down(self: , touch: )
      函数 on_touch_move(self: , touch: )
      函数 on_touch_up(self: , touch: )
      函数 _do_touch_up(self: , touch: )
      函数 _change_touch_mode(self: )
      函数 add_widget(self: , widget: , index: )
      函数 remove_widget(self: , widget: )
      函数 clear_widgets(self: , children: )
    类 Example1:
      基类: Name(id='App', ctx=Load())
      函数 build(self: )
    函数 _cmp()
    分析文件: effectwidget.py
    类 EffectBase:
      ```
      The base class for GLSL effects. It simply returns its input.
      
      See the module documentation for more details.
      ```
      基类: Name(id='EventDispatcher', ctx=Load())
      函数 __init__(self: )
      函数 set_fbo_shader(self: )
        ```
        Sets the :class:`~kivy.graphics.Fbo`'s shader by splicing
        the :attr:`glsl` string into a full fragment shader.
        
        The full shader is made up of :code:`shader_header +
        shader_uniforms + self.glsl + shader_footer_effect`.
        ```
      函数 _load_from_source(self: )
        ```
        (internal) Loads the glsl string from a source file.
        ```
    类 AdvancedEffectBase:
      ```
      An :class:`EffectBase` with additional behavior to easily
      set and update uniform variables in your shader.
      
      This class is provided for convenience when implementing your own
      effects: it is not used by any of those provided with Kivy.
      
      In addition to your base glsl string that must be provided as
      normal, the :class:`AdvancedEffectBase` has an extra property
      :attr:`uniforms`, a dictionary of name-value pairs. Whenever
      a value is changed, the new value for the uniform variable is
      uploaded to the shader.
      
      You must still manually declare your uniform variables at the top
      of your glsl string.
      ```
      基类: Name(id='EffectBase', ctx=Load())
      函数 _update_uniforms(self: )
    类 MonochromeEffect:
      ```
      Returns its input colors in monochrome.
      ```
      基类: Name(id='EffectBase', ctx=Load())
    类 InvertEffect:
      ```
      Inverts the colors in the input.
      ```
      基类: Name(id='EffectBase', ctx=Load())
    类 ScanlinesEffect:
      ```
      Adds scanlines to the input.
      ```
      基类: Name(id='EffectBase', ctx=Load())
    类 ChannelMixEffect:
      ```
      Mixes the color channels of the input according to the order
      property. Channels may be arbitrarily rearranged or repeated.
      ```
      基类: Name(id='EffectBase', ctx=Load())
      函数 on_order(self: )
      函数 do_glsl(self: )
    类 PixelateEffect:
      ```
      Pixelates the input according to its
      :attr:`~PixelateEffect.pixel_size`
      ```
      基类: Name(id='EffectBase', ctx=Load())
      函数 on_pixel_size(self: )
    类 HorizontalBlurEffect:
      ```
      Blurs the input horizontally, with the width given by
      :attr:`~HorizontalBlurEffect.size`.
      ```
      基类: Name(id='EffectBase', ctx=Load())
      函数 on_size(self: )
    类 VerticalBlurEffect:
      ```
      Blurs the input vertically, with the width given by
      :attr:`~VerticalBlurEffect.size`.
      ```
      基类: Name(id='EffectBase', ctx=Load())
    类 FXAAEffect:
      ```
      Applies very simple anti-aliasing via fxaa.
      ```
      基类: Name(id='EffectBase', ctx=Load())
    类 EffectFbo:
      ```
      An :class:`~kivy.graphics.Fbo` with extra functionality that allows
      attempts to set a new shader. See :meth:`set_fs`.
      ```
      基类: Name(id='Fbo', ctx=Load())
      函数 set_fs(self: , value: )
        ```
        Attempt to set the fragment shader to the given value.
        If setting the shader fails, the existing one is preserved and an
        exception is raised.
        ```
    类 EffectWidget:
      ```
      Widget with the ability to apply a series of graphical effects to
      its children. See the module documentation for more information on
      setting effects and creating your own.
      ```
      基类: Name(id='RelativeLayout', ctx=Load())
      函数 _refresh_background_color(self: )
      函数 _update_glsl(self: )
        ```
        (internal) Passes new time and resolution uniform
        variables to the shader.
        ```
      函数 refresh_fbo_setup(self: )
        ```
        (internal) Creates and assigns one :class:`~kivy.graphics.Fbo`
        per effect, and makes sure all sizes etc. are correct and
        consistent.
        ```
      函数 add_widget(self: )
      函数 remove_widget(self: )
      函数 clear_widgets(self: )
    分析文件: layout.py
    类 Layout:
      ```
      Layout interface class, used to implement every layout. See module
      documentation for more information.
      ```
      基类: Name(id='Widget', ctx=Load())
      函数 __init__(self: )
      函数 do_layout(self: )
        ```
        This function is called when a layout is called by a trigger.
        If you are writing a new Layout subclass, don't call this function
        directly but use :meth:`_trigger_layout` instead.
        
        The function is by default called *before* the next frame, therefore
        the layout isn't updated immediately. Anything depending on the
        positions of e.g. children should be scheduled for the next frame.
        
        .. versionadded:: 1.0.8
        ```
      函数 add_widget(self: , widget: )
      函数 remove_widget(self: , widget: )
      函数 layout_hint_with_bounds(self: , sh_sum: , available_space: , min_bounded_size: , sh_min_vals: , sh_max_vals: , hint: )
        ```
        (internal) Computes the appropriate (size) hint for all the
        widgets given (potential) min or max bounds on the widgets' size.
        The ``hint`` list is updated with appropriate sizes.
        
        It walks through the hints and for any widgets whose hint will result
        in violating min or max constraints, it fixes the hint. Any remaining
        or missing space after all the widgets are fixed get distributed
        to the widgets making them smaller or larger according to their
        size hint.
        
        This algorithms knows nothing about the widgets other than what is
        passed through the input params, so it's fairly generic for laying
        things out according to constraints using size hints.
        
        :Parameters:
        
            `sh_sum`: float
                The sum of the size hints (basically ``sum(size_hint)``).
            `available_space`: float
                The amount of pixels available for all the widgets
                whose size hint is not None. Cannot be zero.
            `min_bounded_size`: float
                The minimum amount of space required according to the
                `size_hint_min` of the widgets (basically
                ``sum(size_hint_min)``).
            `sh_min_vals`: list or iterable
                Items in the iterable are the size_hint_min for each widget.
                Can be None. The length should be the same as ``hint``
            `sh_max_vals`: list or iterable
                Items in the iterable are the size_hint_max for each widget.
                Can be None. The length should be the same as ``hint``
            `hint`: list
                A list whose size is the same as the length of ``sh_min_vals``
                and ``sh_min_vals`` whose each element is the corresponding
                size hint value of that element. This list is updated in place
                with correct size hints that ensure the constraints are not
                violated.
        
        :returns:
            Nothing. ``hint`` is updated in place.
        ```
    分析文件: treeview.py
    类 TreeViewException:
      ```
      Exception for errors in the :class:`TreeView`.
          
      ```
      基类: Name(id='Exception', ctx=Load())
    类 TreeViewNode:
      ```
      TreeViewNode class, used to build a node class for a TreeView object.
          
      ```
      基类: Name(id='object', ctx=Load())
      函数 __init__(self: )
    类 TreeViewLabel:
      ```
      Combines a :class:`~kivy.uix.label.Label` and a :class:`TreeViewNode` to
      create a :class:`TreeViewLabel` that can be used as a text node in the
      tree.
      
      See module documentation for more information.
      ```
      基类: Name(id='Label', ctx=Load())
      基类: Name(id='TreeViewNode', ctx=Load())
    类 TreeView:
      ```
      TreeView class. See module documentation for more information.
      
      :Events:
          `on_node_expand`: (node, )
              Fired when a node is being expanded
          `on_node_collapse`: (node, )
              Fired when a node is being collapsed
      ```
      基类: Name(id='Widget', ctx=Load())
      函数 add_node(self: , node: , parent: )
        ```
        Add a new node to the tree.
        
        :Parameters:
            `node`: instance of a :class:`TreeViewNode`
                Node to add into the tree
            `parent`: instance of a :class:`TreeViewNode`, defaults to None
                Parent node to attach the new node. If `None`, it is added to
                the :attr:`root` node.
        
        :returns:
            the node `node`.
        ```
      函数 remove_node(self: , node: )
        ```
        Removes a node from the tree.
        
        .. versionadded:: 1.0.7
        
        :Parameters:
            `node`: instance of a :class:`TreeViewNode`
                Node to remove from the tree. If `node` is :attr:`root`, it is
                not removed.
        ```
      函数 on_node_expand(self: , node: )
      函数 on_node_collapse(self: , node: )
      函数 select_node(self: , node: )
        ```
        Select a node in the tree.
                
        ```
      函数 deselect_node(self: )
        ```
        Deselect any selected node.
        
        .. versionadded:: 1.10.0
        ```
      函数 toggle_node(self: , node: )
        ```
        Toggle the state of the node (open/collapsed).
                
        ```
      函数 get_node_at_pos(self: , pos: )
        ```
        Get the node at the position (x, y).
                
        ```
      函数 iterate_open_nodes(self: , node: )
        ```
        Generator to iterate over all the expended nodes starting from
        `node` and down. If `node` is `None`, the generator start with
        :attr:`root`.
        
        To get all the open nodes::
        
            treeview = TreeView()
            # ... add nodes ...
            for node in treeview.iterate_open_nodes():
                print(node)
        ```
      函数 iterate_all_nodes(self: , node: )
        ```
        Generator to iterate over all nodes from `node` and down whether
        expanded or not. If `node` is `None`, the generator start with
        :attr:`root`.
        ```
      函数 on_load_func(self: , instance: , value: )
      函数 _do_initial_load(self: )
      函数 _do_node_load(self: , node: )
      函数 on_root_options(self: , instance: , value: )
      函数 _do_layout(self: )
      函数 _do_open_node(self: , node: )
      函数 _do_layout_node(self: , node: , level: , y: )
      函数 on_touch_down(self: , touch: )
      函数 get_selected_node(self: )
      函数 get_root(self: )
    类 TestApp:
      基类: Name(id='App', ctx=Load())
      函数 build(self: )
    分析文件: tabbedpanel.py
    类 TabbedPanelException:
      ```
      The TabbedPanelException class.
          
      ```
      基类: Name(id='Exception', ctx=Load())
    类 TabbedPanelHeader:
      ```
      A Base for implementing a Tabbed Panel Head. A button intended to be
      used as a Heading/Tab for a TabbedPanel widget.
      
      You can use this TabbedPanelHeader widget to add a new tab to a
      TabbedPanel.
      ```
      基类: Name(id='ToggleButton', ctx=Load())
      函数 on_touch_down(self: , touch: )
      函数 on_release(self: )
    类 TabbedPanelItem:
      ```
      This is a convenience class that provides a header of type
      TabbedPanelHeader and links it with the content automatically. Thus
      facilitating you to simply do the following in kv language:
      
      .. code-block:: kv
      
          <TabbedPanel>:
              # ...other settings
              TabbedPanelItem:
                  BoxLayout:
                      Label:
                          text: 'Second tab content area'
                      Button:
                          text: 'Button that does nothing'
      
      .. versionadded:: 1.5.0
      ```
      基类: Name(id='TabbedPanelHeader', ctx=Load())
      函数 add_widget(self: , widget: )
      函数 remove_widget(self: )
    类 TabbedPanelStrip:
      ```
      A strip intended to be used as background for Heading/Tab.
      This does not cover the blank areas in case the tabs don't cover
      the entire width/height of the TabbedPanel(use :class:`StripLayout`
      for that).
      ```
      基类: Name(id='GridLayout', ctx=Load())
    类 StripLayout:
      ```
      The main layout that is used to house the entire tabbedpanel strip
      including the blank areas in case the tabs don't cover the entire
      width/height.
      
      .. versionadded:: 1.8.0
      ```
      基类: Name(id='GridLayout', ctx=Load())
    类 TabbedPanelContent:
      ```
      The TabbedPanelContent class.
          
      ```
      基类: Name(id='FloatLayout', ctx=Load())
    类 TabbedPanel:
      ```
      The TabbedPanel class. See module documentation for more information.
          
      ```
      基类: Name(id='GridLayout', ctx=Load())
      函数 get_current_tab(self: )
      函数 get_tab_list(self: )
      函数 get_def_tab(self: )
      函数 set_def_tab(self: , new_tab: )
      函数 get_def_tab_content(self: )
      函数 set_def_tab_content(self: )
      函数 __init__(self: )
      函数 switch_to(self: , header: , do_scroll: )
        ```
        Switch to a specific panel header.
        
        .. versionchanged:: 1.10.0
        
        If used with `do_scroll=True`, it scrolls
        to the header's tab too.
        
        :meth:`switch_to` cannot be called from within the
        :class:`TabbedPanel` or its subclass' ``__init__`` method.
        If that is required, use the ``Clock`` to schedule it. See `discussion
        <https://github.com/kivy/kivy/issues/3493#issuecomment-121567969>`_
        for full example.
        ```
      函数 clear_tabs(self: )
      函数 clear_widgets(self: )
      函数 on_strip_image(self: , instance: , value: )
      函数 on_strip_border(self: , instance: , value: )
      函数 on_do_default_tab(self: , instance: , value: )
      函数 on_default_tab_text(self: )
      函数 on_tab_width(self: )
      函数 on_tab_height(self: )
      函数 on_tab_pos(self: )
      函数 _setup_default_tab(self: )
      函数 _switch_to_first_tab(self: )
      函数 _load_default_tab_content(self: , dt: )
      函数 _reposition_tabs(self: )
      函数 _update_tabs(self: )
      函数 _update_tab_width(self: )
      函数 _update_top(self: )
      函数 _updt_top(self: , sctr: , top: , scrl_v_width: )
      函数 _update_scrollview(self: , scrl_v: )
    分析文件: pagelayout.py
    类 PageLayout:
      ```
      PageLayout class. See module documentation for more information.
          
      ```
      基类: Name(id='Layout', ctx=Load())
      函数 __init__(self: )
      函数 do_layout(self: )
      函数 on_touch_down(self: , touch: )
      函数 on_touch_move(self: , touch: )
      函数 on_touch_up(self: , touch: )
    分析文件: relativelayout.py
    类 RelativeLayout:
      ```
      RelativeLayout class, see module documentation for more information.
          
      ```
      基类: Name(id='FloatLayout', ctx=Load())
      函数 __init__(self: )
      函数 do_layout(self: )
      函数 to_parent(self: , x: , y: )
      函数 to_local(self: , x: , y: )
      函数 _apply_transform(self: , m: , pos: )
      函数 on_motion(self: , etype: , me: )
      函数 on_touch_down(self: , touch: )
      函数 on_touch_move(self: , touch: )
      函数 on_touch_up(self: , touch: )
    recycleview/
      分析文件: datamodel.py
      函数 recondition_slice_assign(val: , last_len: , new_len: )
      类 RecycleDataModelBehavior:
        ```
        :class:`RecycleDataModelBehavior` is the base class for the models
        that describes and provides the data for the
        :class:`~kivy.uix.recycleview.RecycleViewBehavior`.
        
        :Events:
            `on_data_changed`:
                Fired when the data changes. The event may dispatch
                keyword arguments specific to each implementation of the data
                model.
                When dispatched, the event and keyword arguments are forwarded to
                :meth:`~kivy.uix.recycleview.RecycleViewBehavior.refresh_from_data`.
        ```
        基类: Name(id='object', ctx=Load())
        函数 attach_recycleview(self: , rv: )
          ```
          Associates a
          :class:`~kivy.uix.recycleview.RecycleViewBehavior` with
          this data model.
          ```
        函数 detach_recycleview(self: )
          ```
          Removes the
          :class:`~kivy.uix.recycleview.RecycleViewBehavior`
          associated with this data model.
          ```
        函数 on_data_changed(self: )
      类 RecycleDataModel:
        ```
        An implementation of :class:`RecycleDataModelBehavior` that keeps the
        data in a indexable list. See :attr:`data`.
        
        When data changes this class currently dispatches `on_data_changed`  with
        one of the following additional keyword arguments.
        
        `none`: no keyword argument
            With no additional argument it means a generic data change.
        `removed`: a slice or integer
            The value is a slice or integer indicating the indices removed.
        `appended`: a slice
            The slice in :attr:`data` indicating the first and last new items
            (i.e. the slice pointing to the new items added at the end).
        `inserted`: a integer
            The index in :attr:`data` where a new data item was inserted.
        `modified`: a slice
            The slice with the indices where the data has been modified.
            This currently does not allow changing of size etc.
        ```
        基类: Name(id='RecycleDataModelBehavior', ctx=Load())
        基类: Name(id='EventDispatcher', ctx=Load())
        函数 __init__(self: )
        函数 __getitem__(self: , index: )
        函数 observable_dict(self: )
          ```
          A dictionary instance, which when modified will trigger a `data` and
          consequently an `on_data_changed` dispatch.
          ```
        函数 _on_data_callback(self: , instance: , value: )
      分析文件: layout.py
      类 LayoutChangeException:
        基类: Name(id='Exception', ctx=Load())
      类 LayoutSelectionBehavior:
        ```
        The :class:`LayoutSelectionBehavior` can be combined with
        :class:`RecycleLayoutManagerBehavior` to allow its derived classes
        selection behaviors similarly to how
        :class:`~kivy.uix.behaviors.compoundselection.CompoundSelectionBehavior`
        can be used to add selection behaviors to normal layout.
        
        :class:`RecycleLayoutManagerBehavior` manages its children
        differently than normal layouts or widgets so this class adapts
        :class:`~kivy.uix.behaviors.compoundselection.CompoundSelectionBehavior`
        based selection to work with :class:`RecycleLayoutManagerBehavior` as well.
        
        Similarly to
        :class:`~kivy.uix.behaviors.compoundselection.CompoundSelectionBehavior`,
        one can select using the keyboard or touch, which calls :meth:`select_node`
        or :meth:`deselect_node`, or one can call these methods directly. When a
        item is selected or deselected :meth:`apply_selection` is called. See
        :meth:`apply_selection`.
        ```
        基类: Name(id='CompoundSelectionBehavior', ctx=Load())
        函数 __init__(self: )
        函数 compute_sizes_from_data(self: , data: , flags: )
        函数 get_selectable_nodes(self: )
        函数 get_index_of_node(self: , node: , selectable_nodes: )
        函数 goto_node(self: , key: , last_node: , last_node_idx: )
        函数 select_node(self: , node: )
        函数 deselect_node(self: , node: )
        函数 apply_selection(self: , index: , view: , is_selected: )
          ```
          Applies the selection to the view. This is called internally when
          a view is displayed and it needs to be shown as selected or as not
          selected.
          
          It is called when :meth:`select_node` or :meth:`deselect_node` is
          called or when a view needs to be refreshed. Its function is purely to
          update the view to reflect the selection state. So the function may be
          called multiple times even if the selection state may not have changed.
          
          If the view is a instance of
          :class:`~kivy.uix.recycleview.views.RecycleDataViewBehavior`, its
          :meth:`~kivy.uix.recycleview.views.RecycleDataViewBehavior.apply_selection` method will be called every time the view needs to refresh
          the selection state. Otherwise, the this method is responsible
          for applying the selection.
          
          :Parameters:
          
              `index`: int
                  The index of the data item that is associated with the view.
              `view`: widget
                  The widget that is the view of this data item.
              `is_selected`: bool
                  Whether the item is selected.
          ```
        函数 refresh_view_layout(self: , index: , layout: , view: , viewport: )
      类 RecycleLayoutManagerBehavior:
        ```
        A RecycleLayoutManagerBehavior is responsible for positioning views into
        the :attr:`RecycleView.data` within a :class:`RecycleView`. It adds new
        views into the data when it becomes visible to the user, and removes them
        when they leave the visible area.
        ```
        基类: Name(id='object', ctx=Load())
        函数 attach_recycleview(self: , rv: )
        函数 detach_recycleview(self: )
        函数 compute_layout(self: , data: , flags: )
        函数 compute_visible_views(self: , data: , viewport: )
          ```
          `viewport` is in coordinates of the layout manager.
                  
          ```
        函数 set_visible_views(self: , indices: , data: , viewport: )
          ```
          `viewport` is in coordinates of the layout manager.
                  
          ```
        函数 get_view_index_at(self: , pos: )
          ```
          Return the view `index` on which position, `pos`, falls.
          
          `pos` is in coordinates of the layout manager.
          ```
        函数 remove_views(self: )
        函数 remove_view(self: , view: , index: )
        函数 clear_layout(self: )
        函数 goto_view(self: , index: )
          ```
          Moves the views so that the view corresponding to `index` is
          visible.
          ```
        函数 on_viewclass(self: , instance: , value: )
      分析文件: views.py
      函数 _clean_cache()
        ```
        Trims _cached_views cache to half the size of `_max_cache_size`.
            
        ```
      类 RecycleDataViewBehavior:
        ```
        A optional base class for data views (:attr:`RecycleView`.viewclass).
        If a view inherits from this class, the class's functions will be called
        when the view needs to be updated due to a data change or layout update.
        ```
        基类: Name(id='object', ctx=Load())
        函数 refresh_view_attrs(self: , rv: , index: , data: )
          ```
          Called by the :class:`RecycleAdapter` when the view is initially
          populated with the values from the `data` dictionary for this item.
          
          Any pos or size info should be removed because they are set
          subsequently with :attr:`refresh_view_layout`.
          
          :Parameters:
          
              `rv`: :class:`RecycleView` instance
                  The :class:`RecycleView` that caused the update.
              `data`: dict
                  The data dict used to populate this view.
          ```
        函数 refresh_view_layout(self: , rv: , index: , layout: , viewport: )
          ```
          Called when the view's size is updated by the layout manager,
          :class:`RecycleLayoutManagerBehavior`.
          
          :Parameters:
          
              `rv`: :class:`RecycleView` instance
                  The :class:`RecycleView` that caused the update.
              `viewport`: 4-tuple
                  The coordinates of the bottom left and width height in layout
                  manager coordinates. This may be larger than this view item.
          
          :raises:
              `LayoutChangeException`: If the sizing or data changed during a
              call to this method, raising a `LayoutChangeException` exception
              will force a refresh. Useful when data changed and we don't want
              to layout further since it'll be overwritten again soon.
          ```
        函数 apply_selection(self: , rv: , index: , is_selected: )
      类 RecycleKVIDsDataViewBehavior:
        ```
        Similar to :class:`RecycleDataViewBehavior`, except that the data keys
        can signify properties of an object named with an id in the root KV rule.
        
        E.g. given a KV rule::
        
            <MyRule@RecycleKVIDsDataViewBehavior+BoxLayout>:
                Label:
                    id: name
                Label:
                    id: value
        
        Then setting the data list with
        ``rv.data = [{'name.text': 'Kivy user', 'value.text': '12'}]`` would
        automatically set the corresponding labels.
        
        So, if the key doesn't have a period, the named property of the root widget
        will be set to the corresponding value. If there is a period, the named
        property of the widget with the id listed before the period will be set to
        the corresponding value.
        
        .. versionadded:: 2.0.0
        ```
        基类: Name(id='RecycleDataViewBehavior', ctx=Load())
      类 RecycleDataAdapter:
        ```
        The class that converts data to a view.
        
        --- Internal details ---
        A view can have 3 states.
        
            * It can be completely in sync with the data, which
              occurs when the view is displayed. These are stored in :attr:`views`.
            * It can be dirty, which occurs when the view is in sync with the data,
              except for the size/pos parameters which is controlled by the layout.
              This occurs when the view is not currently displayed but the data has
              not changed. These views are stored in :attr:`dirty_views`.
            * Finally the view can be dead which occurs when the data changes and
              the view was not updated or when a view is just created. Such views
              are typically added to the internal cache.
        
        Typically what happens is that the layout manager lays out the data
        and then asks for views, using :meth:`set_visible_views,` for some specific
        data items that it displays.
        
        These views are gotten from the current views, dirty or global cache. Then
        depending on the view state :meth:`refresh_view_attrs` is called to bring
        the view up to date with the data (except for sizing parameters). Finally,
        the layout manager gets these views, updates their size and displays them.
        ```
        基类: Name(id='EventDispatcher', ctx=Load())
        函数 __init__(self: )
          ```
          Fix for issue https://github.com/kivy/kivy/issues/5913:
          Scrolling RV A, then Scrolling RV B, content of A and B seemed
          to be getting mixed up
          ```
        函数 attach_recycleview(self: , rv: )
          ```
          Associates a :class:`~kivy.uix.recycleview.RecycleViewBehavior`
          with this instance. It is stored in :attr:`recycleview`.
          ```
        函数 detach_recycleview(self: )
          ```
          Removes the :class:`~kivy.uix.recycleview.RecycleViewBehavior`
          associated with this instance and clears :attr:`recycleview`.
          ```
        函数 create_view(self: , index: , data_item: , viewclass: )
          ```
          (internal) Creates and initializes the view for the data at `index`.
          
          The returned view is synced with the data, except for the pos/size
          information.
          ```
        函数 get_view(self: , index: , data_item: , viewclass: )
          ```
          (internal) Returns a view instance for the data at `index`
          
          It looks through the various caches and finally creates a view if it
          doesn't exist. The returned view is synced with the data, except for
          the pos/size information.
          
          If found in the cache it's removed from the source
          before returning. It doesn't check the current views.
          ```
        函数 make_view_dirty(self: , view: , index: )
          ```
          (internal) Used to flag this view as dirty, ready to be used for
          others. See :meth:`make_views_dirty`.
          ```
        函数 make_views_dirty(self: )
          ```
          Makes all the current views dirty.
          
          Dirty views are still in sync with the corresponding data. However, the
          size information may go out of sync. Therefore a dirty view can be
          reused by the same index by just updating the sizing information.
          
          Once the underlying data of this index changes, the view should be
          removed from the dirty views and moved to the global cache with
          :meth:`invalidate`.
          
          This is typically called when the layout manager needs to re-layout all
          the data.
          ```
        函数 invalidate(self: )
          ```
          Moves all the current views into the global cache.
          
          As opposed to making a view dirty where the view is in sync with the
          data except for sizing information, this will completely disconnect the
          view from the data, as it is assumed the data has gone out of sync with
          the view.
          
          This is typically called when the data changes.
          ```
        函数 set_visible_views(self: , indices: , data: , viewclasses: )
          ```
          Gets a 3-tuple of the new, remaining, and old views for the current
          viewport.
          
          The new views are synced to the data except for the size/pos
          properties.
          The old views need to be removed from the layout, and the new views
          added.
          
          The new views are not necessarily *new*, but are all the currently
          visible views.
          ```
        函数 get_visible_view(self: , index: )
          ```
          Returns the currently visible view associated with ``index``.
          
          If no view is currently displayed for ``index`` it returns ``None``.
          ```
      分析文件: __init__.py
      类 RecycleViewBehavior:
        ```
        RecycleViewBehavior provides a behavioral model upon which the
        :class:`RecycleView` is built. Together, they offer an extensible and
        flexible way to produce views with limited windows over large data sets.
        
        See the module documentation for more information.
        ```
        基类: Name(id='object', ctx=Load())
        函数 __init__(self: )
        函数 get_viewport(self: )
        函数 save_viewport(self: )
        函数 restore_viewport(self: )
        函数 refresh_views(self: )
        函数 refresh_from_data(self: )
          ```
          This should be called when data changes. Data changes typically
          indicate that everything should be recomputed since the source data
          changed.
          
          This method is automatically bound to the
          :attr:`~RecycleDataModelBehavior.on_data_changed` method of the
          :class:`~RecycleDataModelBehavior` class and
          therefore responds to and accepts the keyword arguments of that event.
          
          It can be called manually to trigger an update.
          ```
        函数 refresh_from_layout(self: )
          ```
          This should be called when the layout changes or needs to change. It is
          typically called when a layout parameter has changed and therefore the
          layout needs to be recomputed.
          ```
        函数 refresh_from_viewport(self: )
          ```
          This should be called when the viewport changes and the displayed data
          must be updated. Neither the data nor the layout will be recomputed.
          ```
        函数 _dispatch_prop_on_source(self: , prop_name: )
        函数 _get_data_model(self: )
        函数 _set_data_model(self: , value: )
        函数 _get_view_adapter(self: )
        函数 _set_view_adapter(self: , value: )
        函数 _get_layout_manager(self: )
        函数 _set_layout_manager(self: , value: )
      类 RecycleView:
        ```
        RecycleView is a flexible view for providing a limited window
        into a large data set.
        
        See the module documentation for more information.
        ```
        基类: Name(id='RecycleViewBehavior', ctx=Load())
        基类: Name(id='ScrollView', ctx=Load())
        函数 _convert_sv_to_lm(self: , x: , y: )
        函数 add_widget(self: , widget: )
        函数 remove_widget(self: , widget: )
        函数 _get_data(self: )
        函数 _set_data(self: , value: )
        函数 _get_viewclass(self: )
        函数 _set_viewclass(self: , value: )
        函数 _get_key_viewclass(self: )
        函数 _set_key_viewclass(self: , value: )
    分析文件: image.py
    类 Image:
      ```
      Image class, see module documentation for more information.
      ```
      基类: Name(id='Widget', ctx=Load())
      函数 get_image_ratio(self: )
      函数 get_norm_image_size(self: )
      函数 __init__(self: )
      函数 _update_fit_mode(self: )
      函数 texture_update(self: )
      函数 set_texture_from_resource(self: , resource: )
      函数 on_anim_delay(self: , instance: , value: )
      函数 on_texture(self: , instance: , value: )
      函数 _clear_core_image(self: )
      函数 _on_tex_change(self: )
      函数 reload(self: )
        ```
        Reload image from disk. This facilitates re-loading of
        images from disk in case the image content changes.
        
        .. versionadded:: 1.3.0
        
        Usage::
        
            im = Image(source = '1.jpg')
            # -- do something --
            im.reload()
            # image will be re-loaded from disk
        ```
      函数 remove_from_cache(self: )
        ```
        Remove image from cache.
        
        .. versionadded:: 2.0.0
        ```
      函数 on_nocache(self: )
    类 AsyncImage:
      ```
      Asynchronous Image class. See the module documentation for more
      information.
      
      .. note::
      
          The AsyncImage is a specialized form of the Image class. You may
          want to refer to the :mod:`~kivy.loader` documentation and in
          particular, the :class:`~kivy.loader.ProxyImage` for more detail
          on how to handle events around asynchronous image loading.
      
      .. note::
      
          AsyncImage currently does not support properties
          :attr:`anim_loop` and :attr:`mipmap` and setting those properties will
          have no effect.
      ```
      基类: Name(id='Image', ctx=Load())
      函数 _load_source(self: )
      函数 _on_source_load(self: , value: )
      函数 _on_source_error(self: , instance: , error: )
      函数 on_error(self: , error: )
      函数 on_load(self: )
      函数 is_uri(self: , filename: )
    分析文件: anchorlayout.py
    类 AnchorLayout:
      ```
      Anchor layout class. See the module documentation for more information.
          
      ```
      基类: Name(id='Layout', ctx=Load())
      函数 __init__(self: )
      函数 do_layout(self: )
    分析文件: switch.py
    类 Switch:
      ```
      Switch class. See module documentation for more information.
          
      ```
      基类: Name(id='Widget', ctx=Load())
      函数 on_touch_down(self: , touch: )
      函数 on_touch_move(self: , touch: )
      函数 on_touch_up(self: , touch: )
    分析文件: sandbox.py
    函数 sandbox(f: )
    类 SandboxExceptionManager:
      基类: Name(id='ExceptionManagerBase', ctx=Load())
      函数 __init__(self: , sandbox: )
      函数 handle_exception(self: , e: )
    类 SandboxContent:
      基类: Name(id='RelativeLayout', ctx=Load())
    类 Sandbox:
      ```
      Sandbox widget, used to trap all the exceptions raised by child
      widgets.
      ```
      基类: Name(id='FloatLayout', ctx=Load())
      函数 __enter__(self: )
      函数 __exit__(self: , _type: , value: , traceback: )
      函数 on_context_created(self: )
        ```
        Override this method in order to load your kv file or do anything
        else with the newly created context.
        ```
      函数 on_exception(self: , exception: , _traceback: )
        ```
        Override this method in order to catch all the exceptions from
        children.
        
        If you return True, it will not reraise the exception.
        If you return False, the exception will be raised to the parent.
        ```
      函数 add_widget(self: )
      函数 remove_widget(self: )
      函数 clear_widgets(self: )
      函数 on_size(self: )
      函数 on_pos(self: )
      函数 _clock_sandbox(self: , dt: )
      函数 _clock_sandbox_draw(self: , dt: )
      函数 _call_draw(self: , dt: )
    函数 _f2(self: )
    类 TestButton:
      基类: Name(id='Button', ctx=Load())
      函数 on_touch_up(self: , touch: )
      函数 on_touch_down(self: , touch: )
    分析文件: stencilview.py
    类 StencilView:
      ```
      StencilView class. See module documentation for more information.
          
      ```
      基类: Name(id='Widget', ctx=Load())
    分析文件: gridlayout.py
    函数 nmax()
    函数 nmin()
    类 GridLayoutException:
      ```
      Exception for errors if the grid layout manipulation fails.
          
      ```
      基类: Name(id='Exception', ctx=Load())
    类 GridLayout:
      ```
      Grid layout class. See module documentation for more information.
          
      ```
      基类: Name(id='Layout', ctx=Load())
      函数 __init__(self: )
      函数 get_max_widgets(self: )
      函数 on_children(self: , instance: , value: )
      函数 _fills_row_first(self: )
      函数 _fills_from_left_to_right(self: )
      函数 _fills_from_top_to_bottom(self: )
      函数 _init_rows_cols_sizes(self: , count: )
      函数 _fill_rows_cols_sizes(self: )
      函数 _update_minimum_size(self: )
      函数 _finalize_rows_cols_sizes(self: )
      函数 _iterate_layout(self: , count: )
      函数 do_layout(self: )
      函数 _create_idx_iter(self: , n_cols: , n_rows: )
    分析文件: slider.py
    类 Slider:
      ```
      Class for creating a Slider widget.
      
      Check module documentation for more details.
      ```
      基类: Name(id='Widget', ctx=Load())
      函数 on_min(self: )
      函数 on_max(self: )
      函数 get_norm_value(self: )
      函数 set_norm_value(self: , value: )
      函数 get_value_pos(self: )
      函数 set_value_pos(self: , pos: )
      函数 on_touch_down(self: , touch: )
      函数 on_touch_move(self: , touch: )
      函数 on_touch_up(self: , touch: )
    类 SliderApp:
      基类: Name(id='App', ctx=Load())
      函数 build(self: )
    分析文件: codeinput.py
    类 CodeInput:
      ```
      CodeInput class, used for displaying highlighted code.
          
      ```
      基类: Name(id='CodeNavigationBehavior', ctx=Load())
      基类: Name(id='TextInput', ctx=Load())
      函数 __init__(self: )
      函数 on_style_name(self: )
      函数 on_style(self: )
      函数 _create_line_label(self: , text: , hint: )
      函数 _get_line_options(self: )
      函数 _get_text_width(self: , text: , tab_width: , _label_cached: )
      函数 _get_bbcode(self: , ntext: )
      函数 _cursor_offset(self: )
        ```
        Get the cursor x offset on the current line
                
        ```
      函数 on_lexer(self: , instance: , value: )
      函数 on_foreground_color(self: , instance: , text_color: )
    类 CodeInputTest:
      基类: Name(id='App', ctx=Load())
      函数 build(self: )
    behaviors/
      分析文件: compoundselection.py
      类 CompoundSelectionBehavior:
        ```
        The Selection behavior `mixin <https://en.wikipedia.org/wiki/Mixin>`_
        implements the logic behind keyboard and touch
        selection of selectable widgets managed by the derived widget. Please see
        the :mod:`compound selection behaviors module
        <kivy.uix.behaviors.compoundselection>` documentation
        for more information.
        
        .. versionadded:: 1.9.0
        ```
        基类: Name(id='object', ctx=Load())
        函数 __init__(self: )
        函数 select_with_touch(self: , node: , touch: )
          ```
          (internal) Processes a touch on the node. This should be called by
          the derived widget when a node is touched and is to be used for
          selection. Depending on the keyboard keys pressed and the
          configuration, it could select or deslect this and other nodes in the
          selectable nodes list, :meth:`get_selectable_nodes`.
          
          :Parameters:
              `node`
                  The node that received the touch. Can be None for a scroll
                  type touch.
              `touch`
                  Optionally, the touch. Defaults to None.
          
          :Returns:
              bool, True if the touch was used, False otherwise.
          ```
        函数 select_with_key_down(self: , keyboard: , scancode: , codepoint: , modifiers: )
          ```
          Processes a key press. This is called when a key press is to be used
          for selection. Depending on the keyboard keys pressed and the
          configuration, it could select or deselect nodes or node ranges
          from the selectable nodes list, :meth:`get_selectable_nodes`.
          
          The parameters are such that it could be bound directly to the
          on_key_down event of a keyboard. Therefore, it is safe to be called
          repeatedly when the key is held down as is done by the keyboard.
          
          :Returns:
              bool, True if the keypress was used, False otherwise.
          ```
        函数 select_with_key_up(self: , keyboard: , scancode: )
          ```
          (internal) Processes a key release. This must be called by the
          derived widget when a key that :meth:`select_with_key_down` returned
          True is released.
          
          The parameters are such that it could be bound directly to the
          on_key_up event of a keyboard.
          
          :Returns:
              bool, True if the key release was used, False otherwise.
          ```
        函数 _update_counts(self: )
        函数 _resolve_last_node(self: )
        函数 _select_range(self: , multiselect: , keep_anchor: , node: , idx: )
          ```
          Selects a range between self._anchor and node or idx.
          If multiselect is True, it will be added to the selection, otherwise
          it will unselect everything before selecting the range. This is only
          called if self.multiselect is True.
          If keep anchor is False, the anchor is moved to node. This should
          always be True for keyboard selection.
          ```
        函数 clear_selection(self: )
          ```
          Deselects all the currently selected nodes.
                  
          ```
        函数 get_selectable_nodes(self: )
          ```
          (internal) Returns a list of the nodes that can be selected. It can
          be overwritten by the derived widget to return the correct list.
          
          This list is used to determine which nodes to select with group
          selection. E.g. the last element in the list will be selected when
          home is pressed, pagedown will move (or add to, if shift is held) the
          selection from the current position by negative :attr:`page_count`
          nodes starting from the position of the currently selected node in
          this list and so on. Still, nodes can be selected even if they are not
          in this list.
          
          .. note::
          
              It is safe to dynamically change this list including removing,
              adding, or re-arranging its elements. Nodes can be selected even
              if they are not on this list. And selected nodes removed from the
              list will remain selected until :meth:`deselect_node` is called.
          
          .. warning::
          
              Layouts display their children in the reverse order. That is, the
              contents of :attr:`~kivy.uix.widget.Widget.children` is displayed
              form right to left, bottom to top. Therefore, internally, the
              indices of the elements returned by this function are reversed to
              make it work by default for most layouts so that the final result
              is consistent e.g. home, although it will select the last element
              in this list visually, will select the first element when
              counting from top to bottom and left to right. If this behavior is
              not desired, a reversed list should be returned instead.
          
          Defaults to returning :attr:`~kivy.uix.widget.Widget.children`.
          ```
        函数 get_index_of_node(self: , node: , selectable_nodes: )
          ```
          (internal) Returns the index of the `node` within the
          `selectable_nodes` returned by :meth:`get_selectable_nodes`.
          ```
        函数 goto_node(self: , key: , last_node: , last_node_idx: )
          ```
          (internal) Used by the controller to get the node at the position
          indicated by key. The key can be keyboard inputs, e.g. pageup,
          or scroll inputs from the mouse scroll wheel, e.g. scrollup.
          'last_node' is the last node selected and is used to find the resulting
          node. For example, if the key is up, the returned node is one node
          up from the last node.
          
          It can be overwritten by the derived widget.
          
          :Parameters:
              `key`
                  str, the string used to find the desired node. It can be any
                  of the keyboard keys, as well as the mouse scrollup,
                  scrolldown, scrollright, and scrollleft strings. If letters
                  are typed in quick succession, the letters will be combined
                  before it's passed in as key and can be used to find nodes that
                  have an associated string that starts with those letters.
              `last_node`
                  The last node that was selected.
              `last_node_idx`
                  The cached index of the last node selected in the
                  :meth:`get_selectable_nodes` list. If the list hasn't changed
                  it saves having to look up the index of `last_node` in that
                  list.
          
          :Returns:
              tuple, the node targeted by key and its index in the
              :meth:`get_selectable_nodes` list. Returning
              `(last_node, last_node_idx)` indicates a node wasn't found.
          ```
        函数 select_node(self: , node: )
          ```
          Selects a node.
          
          It is called by the controller when it selects a node and can be
          called from the outside to select a node directly. The derived widget
          should overwrite this method and change the node state to selected
          when called.
          
          :Parameters:
              `node`
                  The node to be selected.
          
          :Returns:
              bool, True if the node was selected, False otherwise.
          
          .. warning::
          
              This method must be called by the derived widget using super if it
              is overwritten.
          ```
        函数 deselect_node(self: , node: )
          ```
          Deselects a possibly selected node.
          
          It is called by the controller when it deselects a node and can also
          be called from the outside to deselect a node directly. The derived
          widget should overwrite this method and change the node to its
          unselected state when this is called
          
          :Parameters:
              `node`
                  The node to be deselected.
          
          .. warning::
          
              This method must be called by the derived widget using super if it
              is overwritten.
          ```
      函数 ensure_single_select()
      分析文件: codenavigation.py
      类 CodeNavigationBehavior:
        ```
        Code navigation behavior. Modifies the navigation behavior in TextInput
        to work like an IDE instead of a word processor. Please see the
        :mod:`code navigation behaviors module <kivy.uix.behaviors.codenavigation>`
        documentation for more information.
        
        .. versionadded:: 1.9.1
        ```
        基类: Name(id='EventDispatcher', ctx=Load())
        函数 _move_cursor_word_left(self: , index: )
        函数 _move_cursor_word_right(self: , index: )
      分析文件: button.py
      类 ButtonBehavior:
        ```
        This `mixin <https://en.wikipedia.org/wiki/Mixin>`_ class provides
        :class:`~kivy.uix.button.Button` behavior. Please see the
        :mod:`button behaviors module <kivy.uix.behaviors.button>` documentation
        for more information.
        
        :Events:
            `on_press`
                Fired when the button is pressed.
            `on_release`
                Fired when the button is released (i.e. the touch/click that
                pressed the button goes away).
        ```
        基类: Name(id='object', ctx=Load())
        函数 __init__(self: )
        函数 _do_press(self: )
        函数 _do_release(self: )
        函数 cancel_event(self: )
        函数 on_touch_down(self: , touch: )
        函数 on_touch_move(self: , touch: )
        函数 on_touch_up(self: , touch: )
        函数 on_press(self: )
        函数 on_release(self: )
        函数 trigger_action(self: , duration: )
          ```
          Trigger whatever action(s) have been bound to the button by calling
          both the on_press and on_release callbacks.
          
          This is similar to a quick button press without using any touch events,
          but note that like most kivy code, this is not guaranteed to be safe to
          call from external threads. If needed use
          :class:`Clock <kivy.clock.Clock>` to safely schedule this function and
          the resulting callbacks to be called from the main thread.
          
          Duration is the length of the press in seconds. Pass 0 if you want
          the action to happen instantly.
          
          .. versionadded:: 1.8.0
          ```
      函数 trigger_release(dt: )
      分析文件: cover.py
      类 CoverBehavior:
        ```
        The CoverBehavior `mixin <https://en.wikipedia.org/wiki/Mixin>`_
        provides rendering a texture covering full widget size keeping aspect ratio
        of the original texture.
        
        .. versionadded:: 1.10.0
        ```
        基类: Name(id='object', ctx=Load())
        函数 __init__(self: )
        函数 _aspect_ratio_approximate(self: , size: )
        函数 _scale_size(self: , size: , sizer: )
        函数 calculate_cover(self: )
      分析文件: emacs.py
      类 EmacsBehavior:
        ```
        A `mixin <https://en.wikipedia.org/wiki/Mixin>`_ that enables Emacs-style
        keyboard shortcuts for the :class:`~kivy.uix.textinput.TextInput` widget.
        Please see the :mod:`Emacs behaviors module <kivy.uix.behaviors.emacs>`
        documentation for more information.
        
        .. versionadded:: 1.9.1
        ```
        基类: Name(id='object', ctx=Load())
        函数 __init__(self: )
        函数 keyboard_on_key_down(self: , window: , keycode: , text: , modifiers: )
        函数 delete_word_right(self: )
          ```
          Delete text right of the cursor to the end of the word
          ```
        函数 delete_word_left(self: )
          ```
          Delete text left of the cursor to the beginning of word
          ```
      分析文件: focus.py
      类 FocusBehavior:
        ```
        Provides keyboard focus behavior. When combined with other
        FocusBehavior widgets it allows one to cycle focus among them by pressing
        tab. Please see the
        :mod:`focus behavior module documentation <kivy.uix.behaviors.focus>`
        for more information.
        
        .. versionadded:: 1.9.0
        ```
        基类: Name(id='object', ctx=Load())
        函数 _set_keyboard(self: , value: )
        函数 _get_keyboard(self: )
        函数 _set_on_focus_next(self: , instance: , value: )
          ```
          If changing focus, ensure your code does not create an infinite loop.
          eg:
          ```python
          widget.focus_next = widget
          widget.focus_previous = widget
          ```
          ```
        函数 _set_on_focus_previous(self: , instance: , value: )
        函数 __init__(self: )
        函数 _on_focusable(self: , instance: , value: )
        函数 _on_focus(self: , instance: , value: )
        函数 _ensure_keyboard(self: )
        函数 _bind_keyboard(self: )
        函数 _unbind_keyboard(self: )
        函数 keyboard_on_textinput(self: , window: , text: )
        函数 _keyboard_released(self: )
        函数 on_touch_down(self: , touch: )
        函数 _handle_post_on_touch_up(touch: )
          ```
          Called by window after each touch has finished.
                  
          ```
        函数 _get_focus_next(self: , focus_dir: )
        函数 get_focus_next(self: )
          ```
          Returns the next focusable widget using either :attr:`focus_next`
          or the :attr:`children` similar to the order when tabbing forwards
          with the ``tab`` key.
          ```
        函数 get_focus_previous(self: )
          ```
          Returns the previous focusable widget using either
          :attr:`focus_previous` or the :attr:`children` similar to the
          order when the ``tab`` + ``shift`` keys are triggered together.
          ```
        函数 keyboard_on_key_down(self: , window: , keycode: , text: , modifiers: )
          ```
          The method bound to the keyboard when the instance has focus.
          
          When the instance becomes focused, this method is bound to the
          keyboard and will be called for every input press. The parameters are
          the same as :meth:`kivy.core.window.WindowBase.on_key_down`.
          
          When overwriting the method in the derived widget, super should be
          called to enable tab cycling. If the derived widget wishes to use tab
          for its own purposes, it can call super after it has processed the
          character (if it does not wish to consume the tab).
          
          Similar to other keyboard functions, it should return True if the
          key was consumed.
          ```
        函数 keyboard_on_key_up(self: , window: , keycode: )
          ```
          The method bound to the keyboard when the instance has focus.
          
          When the instance becomes focused, this method is bound to the
          keyboard and will be called for every input release. The parameters are
          the same as :meth:`kivy.core.window.WindowBase.on_key_up`.
          
          When overwriting the method in the derived widget, super should be
          called to enable de-focusing on escape. If the derived widget wishes
          to use escape for its own purposes, it can call super after it has
          processed the character (if it does not wish to consume the escape).
          
          See :meth:`keyboard_on_key_down`
          ```
        函数 show_keyboard(self: )
          ```
          Convenience function to show the keyboard in managed mode.
          ```
        函数 hide_keyboard(self: )
          ```
          Convenience function to hide the keyboard in managed mode.
          ```
      分析文件: knspace.py
      类 KNSpace:
        ```
        Each :class:`KNSpace` instance is a namespace that stores the named Kivy
        objects associated with this namespace. Each named object is
        stored as the value of a Kivy :class:`~kivy.properties.ObjectProperty` of
        this instance whose property name is the object's given name. Both `rebind`
        and `allownone` are set to `True` for the property.
        
        See :attr:`KNSpaceBehavior.knspace` for details on how a namespace is
        associated with a named object.
        
        When storing an object in the namespace, the object's `proxy_ref` is
        stored if the object has such an attribute.
        
        :Parameters:
        
            `parent`: (internal) A :class:`KNSpace` instance or None.
                If specified, it's a parent namespace, in which case, the current
                namespace will have in its namespace all its named objects
                as well as the named objects of its parent and parent's parent
                etc. See :meth:`fork` for more details.
        ```
        基类: Name(id='EventDispatcher', ctx=Load())
        函数 __init__(self: , parent: , keep_ref: )
        函数 __setattr__(self: , name: , value: )
        函数 __getattribute__(self: , name: )
        函数 property(self: , name: , quiet: )
        函数 fork(self: )
          ```
          Returns a new :class:`KNSpace` instance which will have access to
          all the named objects in the current namespace but will also have a
          namespace of its own that is unique to it.
          
          For example:
          
          .. code-block:: python
          
              forked_knspace1 = knspace.fork()
              forked_knspace2 = knspace.fork()
          
          Now, any names added to `knspace` will be accessible by the
          `forked_knspace1` and `forked_knspace2` namespaces by the normal means.
          However, any names added to `forked_knspace1` will not be accessible
          from `knspace` or `forked_knspace2`. Similar for `forked_knspace2`.
          ```
      类 KNSpaceBehavior:
        ```
        Inheriting from this class allows naming of the inherited objects, which
        are then added to the associated namespace :attr:`knspace` and accessible
        through it.
        
        Please see the :mod:`knspace behaviors module <kivy.uix.behaviors.knspace>`
        documentation for more information.
        ```
        基类: Name(id='object', ctx=Load())
        函数 __knspace_clear_callbacks(self: )
        函数 __set_parent_knspace(self: )
        函数 _get_knspace(self: )
        函数 _set_knspace(self: , value: )
        函数 _get_knsname(self: )
        函数 _set_knsname(self: , value: )
      分析文件: togglebutton.py
      类 ToggleButtonBehavior:
        ```
        This `mixin <https://en.wikipedia.org/wiki/Mixin>`_ class provides
        :mod:`~kivy.uix.togglebutton` behavior. Please see the
        :mod:`togglebutton behaviors module <kivy.uix.behaviors.togglebutton>`
        documentation for more information.
        
        .. versionadded:: 1.8.0
        ```
        基类: Name(id='ButtonBehavior', ctx=Load())
        函数 __init__(self: )
        函数 on_group(self: )
        函数 _release_group(self: , current: )
        函数 _do_press(self: )
        函数 _do_release(self: )
        函数 _clear_groups(wk: )
        函数 get_widgets(groupname: )
          ```
          Return a list of the widgets contained in a specific group. If the
          group doesn't exist, an empty list will be returned.
          
          .. note::
          
              Always release the result of this method! Holding a reference to
              any of these widgets can prevent them from being garbage collected.
              If in doubt, do::
          
                  l = ToggleButtonBehavior.get_widgets('mygroup')
                  # do your job
                  del l
          
          .. warning::
          
              It's possible that some widgets that you have previously
              deleted are still in the list. The garbage collector might need
              to release other objects before flushing them.
          ```
      分析文件: touchripple.py
      类 TouchRippleBehavior:
        ```
        Touch ripple behavior.
        
        Supposed to be used as mixin on widget classes.
        
        Ripple behavior does not trigger automatically, concrete implementation
        needs to call :func:`ripple_show` respective :func:`ripple_fade` manually.
        
        Example
        -------
        
        Here we create a Label which renders the touch ripple animation on
        interaction::
        
            class RippleLabel(TouchRippleBehavior, Label):
        
                def __init__(self, **kwargs):
                    super(RippleLabel, self).__init__(**kwargs)
        
                def on_touch_down(self, touch):
                    collide_point = self.collide_point(touch.x, touch.y)
                    if collide_point:
                        touch.grab(self)
                        self.ripple_show(touch)
                        return True
                    return False
        
                def on_touch_up(self, touch):
                    if touch.grab_current is self:
                        touch.ungrab(self)
                        self.ripple_fade()
                        return True
                    return False
        ```
        基类: Name(id='object', ctx=Load())
        函数 __init__(self: )
        函数 ripple_show(self: , touch: )
          ```
          Begin ripple animation on current widget.
          
          Expects touch event as argument.
          ```
        函数 ripple_fade(self: )
          ```
          Finish ripple animation on current widget.
                  
          ```
        函数 _ripple_set_ellipse(self: , instance: , value: )
        函数 _ripple_set_color(self: , instance: , value: )
        函数 _ripple_anim_complete(self: , anim: , instance: )
        函数 _ripple_reset_pane(self: )
      类 TouchRippleButtonBehavior:
        ```
        This `mixin <https://en.wikipedia.org/wiki/Mixin>`_ class provides
        a similar behavior to :class:`~kivy.uix.behaviors.button.ButtonBehavior`
        but provides touch ripple animation instead of button pressed/released as
        visual effect.
        
        :Events:
            `on_press`
                Fired when the button is pressed.
            `on_release`
                Fired when the button is released (i.e. the touch/click that
                pressed the button goes away).
        ```
        基类: Name(id='TouchRippleBehavior', ctx=Load())
        函数 on_touch_down(self: , touch: )
        函数 on_touch_move(self: , touch: )
        函数 on_touch_up(self: , touch: )
        函数 on_disabled(self: , instance: , value: )
        函数 on_press(self: )
        函数 on_release(self: )
      函数 defer_release(dt: )
      分析文件: drag.py
      类 DragBehavior:
        ```
        The DragBehavior `mixin <https://en.wikipedia.org/wiki/Mixin>`_ provides
        Drag behavior. When combined with a widget, dragging in the rectangle
        defined by :attr:`drag_rectangle` will drag the widget. Please see
        the :mod:`drag behaviors module <kivy.uix.behaviors.drag>` documentation
        for more information.
        
        .. versionadded:: 1.8.0
        ```
        基类: Name(id='object', ctx=Load())
        函数 __init__(self: )
        函数 _get_uid(self: , prefix: )
        函数 on_touch_down(self: , touch: )
        函数 on_touch_move(self: , touch: )
        函数 on_touch_up(self: , touch: )
        函数 _do_touch_up(self: , touch: )
        函数 _change_touch_mode(self: )
      分析文件: __init__.py
    分析文件: splitter.py
    类 SplitterStrip:
      ```
      Class used for the graphical representation of a
      :class:`kivy.uix.splitter.SplitterStripe`.
      ```
      基类: Name(id='Button', ctx=Load())
    类 Splitter:
      ```
      See module documentation.
      
      :Events:
          `on_press`:
              Fired when the splitter is pressed.
          `on_release`:
              Fired when the splitter is released.
      
      .. versionchanged:: 1.6.0
          Added `on_press` and `on_release` events.
      ```
      基类: Name(id='BoxLayout', ctx=Load())
      函数 __init__(self: )
      函数 on_sizable_from(self: , instance: , sizable_from: )
      函数 add_widget(self: , widget: , index: )
      函数 remove_widget(self: , widget: )
      函数 clear_widgets(self: )
      函数 strip_down(self: , instance: , touch: )
      函数 on_press(self: )
      函数 _rebind_parent(self: , instance: , new_parent: )
      函数 rescale_parent_proportion(self: )
      函数 _do_size(self: , instance: , value: )
      函数 _is_moving(sz_frm: , diff: , pos: , minpos: , maxpos: )
      函数 strip_move(self: , instance: , touch: )
      函数 strip_up(self: , instance: , touch: )
      函数 on_release(self: )
    类 SplitterApp:
      基类: Name(id='App', ctx=Load())
      函数 build(self: )
    分析文件: recycleboxlayout.py
    类 RecycleBoxLayout:
      基类: Name(id='RecycleLayout', ctx=Load())
      基类: Name(id='BoxLayout', ctx=Load())
      函数 __init__(self: )
      函数 _update_sizes(self: , changed: )
      函数 compute_layout(self: , data: , flags: )
      函数 get_view_index_at(self: , pos: )
      函数 compute_visible_views(self: , data: , viewport: )
    分析文件: togglebutton.py
    类 ToggleButton:
      ```
      Toggle button class, see module documentation for more information.
          
      ```
      基类: Name(id='ToggleButtonBehavior', ctx=Load())
      基类: Name(id='Button', ctx=Load())
    分析文件: widget.py
    函数 _widget_destructor(uid: , r: )
    类 WidgetException:
      ```
      Fired when the widget gets an exception.
          
      ```
      基类: Name(id='Exception', ctx=Load())
    类 WidgetMetaclass:
      ```
      Metaclass to automatically register new widgets for the
      :class:`~kivy.factory.Factory`.
      
      .. warning::
          This metaclass is used by the Widget. Do not use it directly!
      ```
      基类: Name(id='type', ctx=Load())
      函数 __init__(mcs: , name: , bases: , attrs: )
    类 Widget:
      ```
      Widget class. See module documentation for more information.
      
      :Events:
          `on_touch_down`: `(touch, )`
              Fired when a new touch event occurs. `touch` is the touch object.
          `on_touch_move`: `(touch, )`
              Fired when an existing touch moves. `touch` is the touch object.
          `on_touch_up`: `(touch, )`
              Fired when an existing touch disappears. `touch` is the touch
              object.
          `on_kv_post`: `(base_widget, )`
              Fired after all the kv rules associated with the widget
              and all other widgets that are in any of those rules have had
              all their kv rules applied. `base_widget` is the base-most widget
              whose instantiation triggered the kv rules (i.e. the widget
              instantiated from Python, e.g. ``MyWidget()``).
      
              .. versionchanged:: 1.11.0
      
      .. warning::
          Adding a `__del__` method to a class derived from Widget with Python
          prior to 3.4 will disable automatic garbage collection for instances
          of that class. This is because the Widget class creates reference
          cycles, thereby `preventing garbage collection
          <https://docs.python.org/2/library/gc.html#gc.garbage>`_.
      
      .. versionchanged:: 1.0.9
          Everything related to event properties has been moved to the
          :class:`~kivy.event.EventDispatcher`. Event properties can now be used
          when constructing a simple class without subclassing :class:`Widget`.
      
      .. versionchanged:: 1.5.0
          The constructor now accepts on_* arguments to automatically bind
          callbacks to properties or events, as in the Kv language.
      ```
      基类: Name(id='WidgetBase', ctx=Load())
      函数 proxy_ref(self: )
        ```
        Return a proxy reference to the widget, i.e. without creating a
        reference to the widget. See `weakref.proxy
        <http://docs.python.org/2/library/weakref.html?highlight        =proxy#weakref.proxy>`_ for more information.
        
        .. versionadded:: 1.7.2
        ```
      函数 __hash__(self: )
      函数 apply_class_lang_rules(self: , root: , ignored_consts: , rule_children: )
        ```
        Method that is called by kivy to apply the kv rules of this widget's
        class.
        
        :Parameters:
            `root`: :class:`Widget`
                The root widget that instantiated this widget in kv, if the
                widget was instantiated in kv, otherwise ``None``.
            `ignored_consts`: set
                (internal) See :meth:`~kivy.lang.builder.BuilderBase.apply`.
            `rule_children`: list
                (internal) See :meth:`~kivy.lang.builder.BuilderBase.apply`.
        
        This is useful to be able to execute code before/after the class kv
        rules are applied to the widget. E.g. if the kv code requires some
        properties to be initialized before it is used in a binding rule.
        If overwriting remember to call ``super``, otherwise the kv rules will
        not be applied.
        
        In the following example,
        
        .. code-block:: python
        
            class MyWidget(Widget):
                pass
        
            class OtherWidget(MyWidget):
                pass
        
        .. code-block:: kv
        
        <MyWidget>:
            my_prop: some_value
        
        <OtherWidget>:
            other_prop: some_value
        
        When ``OtherWidget`` is instantiated with ``OtherWidget()``, the
        widget's :meth:`apply_class_lang_rules` is called and it applies the
        kv rules of this class - ``<MyWidget>`` and ``<OtherWidget>``.
        
        Similarly, when the widget is instantiated from kv, e.g.
        
        .. code-block:: kv
        
            <MyBox@BoxLayout>:
                height: 55
                OtherWidget:
                    width: 124
        
        ``OtherWidget``'s :meth:`apply_class_lang_rules` is called and it
        applies the kv rules of this class - ``<MyWidget>`` and
        ``<OtherWidget>``.
        
        .. note::
        
            It applies only the class rules not the instance rules. I.e. in the
            above kv example in the ``MyBox`` rule when ``OtherWidget`` is
            instantiated, its :meth:`apply_class_lang_rules` applies the
            ``<MyWidget>`` and ``<OtherWidget>`` rules to it - it does not
            apply the ``width: 124`` rule. The ``width: 124`` rule is part of
            the ``MyBox`` rule and is applied by the ``MyBox``'s instance's
            :meth:`apply_class_lang_rules`.
        
        .. versionchanged:: 1.11.0
        ```
      函数 collide_point(self: , x: , y: )
        ```
        Check if a point (x, y) is inside the widget's axis aligned bounding
        box.
        
        :Parameters:
            `x`: numeric
                x position of the point (in parent coordinates)
            `y`: numeric
                y position of the point (in parent coordinates)
        
        :Returns:
            A bool. True if the point is inside the bounding box, False
            otherwise.
        
        .. code-block:: python
        
            >>> Widget(pos=(10, 10), size=(50, 50)).collide_point(40, 40)
            True
        ```
      函数 collide_widget(self: , wid: )
        ```
        Check if another widget collides with this widget. This function
        performs an axis-aligned bounding box intersection test by default.
        
        :Parameters:
            `wid`: :class:`Widget` class
                Widget to test collision with.
        
        :Returns:
            bool. True if the other widget collides with this widget, False
            otherwise.
        
        .. code-block:: python
        
            >>> wid = Widget(size=(50, 50))
            >>> wid2 = Widget(size=(50, 50), pos=(25, 25))
            >>> wid.collide_widget(wid2)
            True
            >>> wid2.pos = (55, 55)
            >>> wid.collide_widget(wid2)
            False
        ```
      函数 on_motion(self: , etype: , me: )
        ```
        Called when a motion event is received.
        
        :Parameters:
            `etype`: `str`
                Event type, one of "begin", "update" or "end"
            `me`: :class:`~kivy.input.motionevent.MotionEvent`
                Received motion event
        :Returns: `bool`
            `True` to stop event dispatching
        
        .. versionadded:: 2.1.0
        
        .. warning::
            This is an experimental method and it remains so while this warning
            is present.
        ```
      函数 on_touch_down(self: , touch: )
        ```
        Receive a touch down event.
        
        :Parameters:
            `touch`: :class:`~kivy.input.motionevent.MotionEvent` class
                Touch received. The touch is in parent coordinates. See
                :mod:`~kivy.uix.relativelayout` for a discussion on
                coordinate systems.
        
        :Returns: bool
            If True, the dispatching of the touch event will stop.
            If False, the event will continue to be dispatched to the rest
            of the widget tree.
        ```
      函数 on_touch_move(self: , touch: )
        ```
        Receive a touch move event. The touch is in parent coordinates.
        
        See :meth:`on_touch_down` for more information.
        ```
      函数 on_touch_up(self: , touch: )
        ```
        Receive a touch up event. The touch is in parent coordinates.
        
        See :meth:`on_touch_down` for more information.
        ```
      函数 on_kv_post(self: , base_widget: )
      函数 add_widget(self: , widget: , index: , canvas: )
        ```
        Add a new widget as a child of this widget.
        
            :Parameters:
                `widget`: :class:`Widget`
                    Widget to add to our list of children.
                `index`: int, defaults to 0
                    Index to insert the widget in the list. Notice that the default
                    of 0 means the widget is inserted at the beginning of the list
                    and will thus be drawn on top of other sibling widgets. For a
                    full discussion of the index and widget hierarchy, please see
                    the :doc:`Widgets Programming Guide <guide/widgets>`.
        
                    .. versionadded:: 1.0.5
                `canvas`: str, defaults to None
                    Canvas to add widget's canvas to. Can be 'before', 'after' or
                    None for the default canvas.
        
                    .. versionadded:: 1.9.0
        
        .. code-block:: python
        
            >>> from kivy.uix.button import Button
            >>> from kivy.uix.slider import Slider
            >>> root = Widget()
            >>> root.add_widget(Button())
            >>> slider = Slider()
            >>> root.add_widget(slider)
        
            
        ```
      函数 remove_widget(self: , widget: )
        ```
        Remove a widget from the children of this widget.
        
            :Parameters:
                `widget`: :class:`Widget`
                    Widget to remove from our children list.
        
        .. code-block:: python
        
            >>> from kivy.uix.button import Button
            >>> root = Widget()
            >>> button = Button()
            >>> root.add_widget(button)
            >>> root.remove_widget(button)
            
        ```
      函数 clear_widgets(self: , children: )
        ```
        Remove all (or the specified) :attr:`~Widget.children` of this widget.
        If the 'children' argument is specified, it should be a list (or
        filtered list) of children of the current widget.
        
        .. versionchanged:: 1.8.0
            The `children` argument can be used to specify the children you
            want to remove.
        .. versionchanged:: 2.1.0
        
            Specifying an empty ``children`` list leaves the widgets unchanged.
            Previously it was treated like ``None`` and all children were
            removed.
        ```
      函数 _update_motion_filter(self: , child_widget: , child_motion_filter: )
      函数 _find_index_in_motion_filter(self: , type_id: , widget: )
      函数 register_for_motion_event(self: , type_id: , widget: )
        ```
        Register to receive motion events of `type_id`.
        
        Override :meth:`on_motion` or bind to `on_motion` event to handle
        the incoming motion events.
        
        :Parameters:
            `type_id`: `str`
                Motion event type id (eg. "touch", "hover", etc.)
            `widget`: `Widget`
                Child widget or `self` if omitted
        
        .. versionadded:: 2.1.0
        
        .. note::
            Method can be called multiple times with the same arguments.
        
        .. warning::
            This is an experimental method and it remains so while this warning
            is present.
        ```
      函数 unregister_for_motion_event(self: , type_id: , widget: )
        ```
        Unregister to receive motion events of `type_id`.
        
        :Parameters:
            `type_id`: `str`
                Motion event type id (eg. "touch", "hover", etc.)
            `widget`: `Widget`
                Child widget or `self` if omitted
        
        .. versionadded:: 2.1.0
        
        .. note::
            Method can be called multiple times with the same arguments.
        
        .. warning::
            This is an experimental method and it remains so while this warning
            is present.
        ```
      函数 export_to_png(self: , filename: )
        ```
        Saves an image of the widget and its children in png format at the
        specified filename. Works by removing the widget canvas from its
        parent, rendering to an :class:`~kivy.graphics.fbo.Fbo`, and calling
        :meth:`~kivy.graphics.texture.Texture.save`.
        
        .. note::
        
            The image includes only this widget and its children. If you want
            to include widgets elsewhere in the tree, you must call
            :meth:`~Widget.export_to_png` from their common parent, or use
            :meth:`~kivy.core.window.WindowBase.screenshot` to capture the
            whole window.
        
        .. note::
        
            The image will be saved in png format, you should include the
            extension in your filename.
        
        .. versionadded:: 1.9.0
        
        :Parameters:
            `filename`: str
                The filename with which to save the png.
            `scale`: float
                The amount by which to scale the saved image, defaults to 1.
        
                .. versionadded:: 1.11.0
        ```
      函数 export_as_image(self: )
        ```
        Return an core :class:`~kivy.core.image.Image` of the actual
        widget.
        
        .. versionadded:: 1.11.0
        ```
      函数 get_root_window(self: )
        ```
        Return the root window.
        
        :Returns:
            Instance of the root window. Can be a
            :class:`~kivy.core.window.WindowBase` or
            :class:`Widget`.
        ```
      函数 get_parent_window(self: )
        ```
        Return the parent window.
        
        :Returns:
            Instance of the parent window. Can be a
            :class:`~kivy.core.window.WindowBase` or
            :class:`Widget`.
        ```
      函数 _walk(self: , restrict: , loopback: , index: )
      函数 walk(self: , restrict: , loopback: )
        ```
        Iterator that walks the widget tree starting with this widget and
        goes forward returning widgets in the order in which layouts display
        them.
        
        :Parameters:
            `restrict`: bool, defaults to False
                If True, it will only iterate through the widget and its
                children (or children of its children etc.). Defaults to False.
            `loopback`: bool, defaults to False
                If True, when the last widget in the tree is reached,
                it'll loop back to the uppermost root and start walking until
                we hit this widget again. Naturally, it can only loop back when
                `restrict` is False. Defaults to False.
        
        :return:
            A generator that walks the tree, returning widgets in the
            forward layout order.
        
        For example, given a tree with the following structure:
        
        .. code-block:: kv
        
            GridLayout:
                Button
                BoxLayout:
                    id: box
                    Widget
                    Button
                Widget
        
        walking this tree:
        
        .. code-block:: python
        
            >>> # Call walk on box with loopback True, and restrict False
            >>> [type(widget) for widget in box.walk(loopback=True)]
            [<class 'BoxLayout'>, <class 'Widget'>, <class 'Button'>,
                <class 'Widget'>, <class 'GridLayout'>, <class 'Button'>]
            >>> # Now with loopback False, and restrict False
            >>> [type(widget) for widget in box.walk()]
            [<class 'BoxLayout'>, <class 'Widget'>, <class 'Button'>,
                <class 'Widget'>]
            >>> # Now with restrict True
            >>> [type(widget) for widget in box.walk(restrict=True)]
            [<class 'BoxLayout'>, <class 'Widget'>, <class 'Button'>]
        
        .. versionadded:: 1.9.0
        ```
      函数 _walk_reverse(self: , loopback: , go_up: )
      函数 walk_reverse(self: , loopback: )
        ```
        Iterator that walks the widget tree backwards starting with the
        widget before this, and going backwards returning widgets in the
        reverse order in which layouts display them.
        
        This walks in the opposite direction of :meth:`walk`, so a list of the
        tree generated with :meth:`walk` will be in reverse order compared
        to the list generated with this, provided `loopback` is True.
        
        :Parameters:
            `loopback`: bool, defaults to False
                If True, when the uppermost root in the tree is
                reached, it'll loop back to the last widget and start walking
                back until after we hit widget again. Defaults to False.
        
        :return:
            A generator that walks the tree, returning widgets in the
            reverse layout order.
        
        For example, given a tree with the following structure:
        
        .. code-block:: kv
        
            GridLayout:
                Button
                BoxLayout:
                    id: box
                    Widget
                    Button
                Widget
        
        walking this tree:
        
        .. code-block:: python
        
            >>> # Call walk on box with loopback True
            >>> [type(widget) for widget in box.walk_reverse(loopback=True)]
            [<class 'Button'>, <class 'GridLayout'>, <class 'Widget'>,
                <class 'Button'>, <class 'Widget'>, <class 'BoxLayout'>]
            >>> # Now with loopback False
            >>> [type(widget) for widget in box.walk_reverse()]
            [<class 'Button'>, <class 'GridLayout'>]
            >>> forward = [w for w in box.walk(loopback=True)]
            >>> backward = [w for w in box.walk_reverse(loopback=True)]
            >>> forward == backward[::-1]
            True
        
        .. versionadded:: 1.9.0
        ```
      函数 to_widget(self: , x: , y: , relative: )
        ```
        Convert the coordinate from window to local (current widget)
        coordinates.
        
        See :mod:`~kivy.uix.relativelayout` for details on the coordinate
        systems.
        ```
      函数 to_window(self: , x: , y: , initial: , relative: )
        ```
        If ``initial`` is True, the default, it transforms **parent**
        coordinates to window coordinates. Otherwise, it transforms **local**
        (current widget) coordinates to window coordinates.
        
        See :mod:`~kivy.uix.relativelayout` for details on the coordinate
        systems.
        ```
      函数 to_parent(self: , x: , y: , relative: )
        ```
        Transform local (current widget) coordinates to parent coordinates.
        
        See :mod:`~kivy.uix.relativelayout` for details on the coordinate
        systems.
        
        :Parameters:
            `relative`: bool, defaults to False
                Change to True if you want to translate relative positions from
                a widget to its parent coordinates.
        ```
      函数 to_local(self: , x: , y: , relative: )
        ```
        Transform parent coordinates to local (current widget) coordinates.
        
        See :mod:`~kivy.uix.relativelayout` for details on the coordinate
        systems.
        
        :Parameters:
            `relative`: bool, defaults to False
                Change to True if you want to translate coordinates to
                relative widget coordinates.
        ```
      函数 _apply_transform(self: , m: , pos: )
      函数 get_window_matrix(self: , x: , y: )
        ```
        Calculate the transformation matrix to convert between window and
        widget coordinates.
        
        :Parameters:
            `x`: float, defaults to 0
                Translates the matrix on the x axis.
            `y`: float, defaults to 0
                Translates the matrix on the y axis.
        ```
      函数 get_right(self: )
      函数 set_right(self: , value: )
      函数 get_top(self: )
      函数 set_top(self: , value: )
      函数 get_center_x(self: )
      函数 set_center_x(self: , value: )
      函数 get_center_y(self: )
      函数 set_center_y(self: , value: )
      函数 on_opacity(self: , instance: , value: )
      函数 get_disabled(self: )
      函数 set_disabled(self: , value: )
      函数 inc_disabled(self: , count: )
      函数 dec_disabled(self: , count: )
    分析文件: vkeyboard.py
    类 VKeyboard:
      ```
      VKeyboard is an onscreen keyboard with multitouch support.
      Its layout is entirely customizable and you can switch between available
      layouts using a button in the bottom right of the widget.
      
      :Events:
          `on_key_down`: keycode, internal, modifiers
              Fired when the keyboard received a key down event (key press).
          `on_key_up`: keycode, internal, modifiers
              Fired when the keyboard received a key up event (key release).
      ```
      基类: Name(id='Scatter', ctx=Load())
      函数 __init__(self: )
      函数 on_disabled(self: , instance: , value: )
      函数 _update_layout_mode(self: )
      函数 _load_layout(self: )
      函数 _load_layouts(self: )
      函数 _load_layout_fn(self: , fn: , name: )
      函数 setup_mode(self: )
        ```
        Call this method when you want to readjust the keyboard according to
        options: :attr:`docked` or not, with attached :attr:`target` or not:
        
        * If :attr:`docked` is True, it will call :meth:`setup_mode_dock`
        * If :attr:`docked` is False, it will call :meth:`setup_mode_free`
        
        Feel free to overload these methods to create new
        positioning behavior.
        ```
      函数 setup_mode_dock(self: )
        ```
        Setup the keyboard in docked mode.
        
        Dock mode will reset the rotation, disable translation, rotation and
        scale. Scale and position will be automatically adjusted to attach the
        keyboard to the bottom of the screen.
        
        .. note::
            Don't call this method directly, use :meth:`setup_mode` instead.
        ```
      函数 _update_dock_mode(self: , win: )
      函数 setup_mode_free(self: )
        ```
        Setup the keyboard in free mode.
        
        Free mode is designed to let the user control the position and
        orientation of the keyboard. The only real usage is for a multiuser
        environment, but you might found other ways to use it.
        If a :attr:`target` is set, it will place the vkeyboard under the
        target.
        
        .. note::
            Don't call this method directly, use :meth:`setup_mode` instead.
        ```
      函数 change_layout(self: )
      函数 refresh(self: , force: )
        ```
        (internal) Recreate the entire widget and graphics according to the
        selected layout.
        ```
      函数 refresh_active_keys_layer(self: )
      函数 refresh_keys_hint(self: )
      函数 refresh_keys(self: )
      函数 draw_keys(self: )
      函数 on_key_down(self: )
      函数 on_key_up(self: )
      函数 on_textinput(self: )
      函数 get_key_at_pos(self: , x: , y: )
      函数 collide_margin(self: , x: , y: )
        ```
        Do a collision test, and return True if the (x, y) is inside the
        vkeyboard margin.
        ```
      函数 process_key_on(self: , touch: )
      函数 process_key_up(self: , touch: )
      函数 _get_modifiers(self: )
      函数 _start_repeat_key(self: )
      函数 _repeat_key(self: )
      函数 on_touch_down(self: , touch: )
      函数 on_touch_up(self: , touch: )
    分析文件: modalview.py
    类 ModalView:
      ```
      ModalView class. See module documentation for more information.
      
      :Events:
          `on_pre_open`:
              Fired before the ModalView is opened. When this event is fired
              ModalView is not yet added to window.
          `on_open`:
              Fired when the ModalView is opened.
          `on_pre_dismiss`:
              Fired before the ModalView is closed.
          `on_dismiss`:
              Fired when the ModalView is closed. If the callback returns True,
              the dismiss will be canceled.
      
      .. versionchanged:: 1.11.0
          Added events `on_pre_open` and `on_pre_dismiss`.
      
      .. versionchanged:: 2.0.0
          Added property 'overlay_color'.
      
      .. versionchanged:: 2.1.0
          Marked `attach_to` property as deprecated.
      ```
      基类: Name(id='AnchorLayout', ctx=Load())
      函数 __init__(self: )
      函数 open(self: )
        ```
        Display the modal in the Window.
        
        When the view is opened, it will be faded in with an animation. If you
        don't want the animation, use::
        
            view.open(animation=False)
        ```
      函数 dismiss(self: )
        ```
        Close the view if it is open.
        
        If you really want to close the view, whatever the on_dismiss
        event returns, you can use the *force* keyword argument::
        
            view = ModalView()
            view.dismiss(force=True)
        
        When the view is dismissed, it will be faded out before being
        removed from the parent. If you don't want this animation, use::
        
            view.dismiss(animation=False)
        ```
      函数 _align_center(self: )
      函数 on_motion(self: , etype: , me: )
      函数 on_touch_down(self: , touch: )
        ```
        touch down event handler. 
        ```
      函数 on_touch_move(self: , touch: )
        ```
        touch moved event handler. 
        ```
      函数 on_touch_up(self: , touch: )
        ```
        touch up event handler. 
        ```
      函数 on__anim_alpha(self: , _instance: , value: )
        ```
        animation progress callback. 
        ```
      函数 _real_remove_widget(self: )
      函数 on_pre_open(self: )
        ```
        default pre-open event handler. 
        ```
      函数 on_open(self: )
        ```
        default open event handler. 
        ```
      函数 on_pre_dismiss(self: )
        ```
        default pre-dismiss event handler. 
        ```
      函数 on_dismiss(self: )
        ```
        default dismiss event handler. 
        ```
      函数 _handle_keyboard(self: , _window: , key: )
    分析文件: gesturesurface.py
    类 GestureContainer:
      ```
      Container object that stores information about a gesture. It has
      various properties that are updated by `GestureSurface` as drawing
      progresses.
      
      :Arguments:
          `touch`
              Touch object (as received by on_touch_down) used to initialize
              the gesture container. Required.
      
      :Properties:
          `active`
              Set to False once the gesture is complete (meets
              `max_stroke` setting or `GestureSurface.temporal_window`)
      
              :attr:`active` is a
              :class:`~kivy.properties.BooleanProperty`
      
          `active_strokes`
              Number of strokes currently active in the gesture, ie
              concurrent touches associated with this gesture.
      
              :attr:`active_strokes` is a
              :class:`~kivy.properties.NumericProperty`
      
          `max_strokes`
              Max number of strokes allowed in the gesture. This
              is set by `GestureSurface.max_strokes` but can
              be overridden for example from `on_gesture_start`.
      
              :attr:`max_strokes` is a
              :class:`~kivy.properties.NumericProperty`
      
          `was_merged`
              Indicates that this gesture has been merged with another
              gesture and should be considered discarded.
      
              :attr:`was_merged` is a
              :class:`~kivy.properties.BooleanProperty`
      
          `bbox`
              Dictionary with keys minx, miny, maxx, maxy. Represents the size
              of the gesture bounding box.
      
              :attr:`bbox` is a
              :class:`~kivy.properties.DictProperty`
      
          `width`
              Represents the width of the gesture.
      
              :attr:`width` is a
              :class:`~kivy.properties.NumericProperty`
      
          `height`
              Represents the height of the gesture.
      
              :attr:`height` is a
              :class:`~kivy.properties.NumericProperty`
      ```
      基类: Name(id='EventDispatcher', ctx=Load())
      函数 __init__(self: , touch: )
      函数 get_vectors(self: )
        ```
        Return strokes in a format that is acceptable for
        `kivy.multistroke.Recognizer` as a gesture candidate or template. The
        result is cached automatically; the cache is invalidated at the start
        and end of a stroke and if `update_bbox` is called. If you are going
        to analyze a gesture mid-stroke, you may need to set the `no_cache`
        argument to True.
        ```
      函数 handles(self: , touch: )
        ```
        Returns True if this container handles the given touch
        ```
      函数 accept_stroke(self: , count: )
        ```
        Returns True if this container can accept `count` new strokes
        ```
      函数 update_bbox(self: , touch: )
        ```
        Update gesture bbox from a touch coordinate
        ```
      函数 add_stroke(self: , touch: , line: )
        ```
        Associate a list of points with a touch.uid; the line itself is
        created by the caller, but subsequent move/up events look it
        up via us. This is done to avoid problems during merge.
        ```
      函数 complete_stroke(self: )
        ```
        Called on touch up events to keep track of how many strokes
        are active in the gesture (we only want to dispatch event when
        the *last* stroke in the gesture is released)
        ```
      函数 single_points_test(self: )
        ```
        Returns True if the gesture consists only of single-point strokes,
        we must discard it in this case, or an exception will be raised
        ```
    类 GestureSurface:
      ```
      Simple gesture surface to track/draw touch movements. Typically used
      to gather user input suitable for :class:`kivy.multistroke.Recognizer`.
      
      :Properties:
          `temporal_window`
              Time to wait from the last touch_up event before attempting
              to recognize the gesture. If you set this to 0, the
              `on_gesture_complete` event is not fired unless the
              :attr:`max_strokes` condition is met.
      
              :attr:`temporal_window` is a
              :class:`~kivy.properties.NumericProperty` and defaults to 2.0
      
          `max_strokes`
              Max number of strokes in a single gesture; if this is reached,
              recognition will start immediately on the final touch_up event.
              If this is set to 0, the `on_gesture_complete` event is not
              fired unless the :attr:`temporal_window` expires.
      
              :attr:`max_strokes` is a
              :class:`~kivy.properties.NumericProperty` and defaults to 2.0
      
          `bbox_margin`
              Bounding box margin for detecting gesture collisions, in
              pixels.
      
              :attr:`bbox_margin` is a
              :class:`~kivy.properties.NumericProperty` and defaults to 30
      
          `draw_timeout`
              Number of seconds to keep lines/bbox on canvas after the
              `on_gesture_complete` event is fired. If this is set to 0,
              gestures are immediately removed from the surface when
              complete.
      
              :attr:`draw_timeout` is a
              :class:`~kivy.properties.NumericProperty` and defaults to 3.0
      
          `color`
              Color used to draw the gesture, in RGB. This option does not
              have an effect if :attr:`use_random_color` is True.
      
              :attr:`color` is a
              :class:`~kivy.properties.ColorProperty` and defaults to
              [1, 1, 1, 1] (white)
      
              .. versionchanged:: 2.0.0
                  Changed from :class:`~kivy.properties.ListProperty` to
                  :class:`~kivy.properties.ColorProperty`.
      
          `use_random_color`
              Set to True to pick a random color for each gesture, if you do
              this then `color` is ignored. Defaults to False.
      
              :attr:`use_random_color` is a
              :class:`~kivy.properties.BooleanProperty` and defaults to False
      
          `line_width`
              Line width used for tracing touches on the surface. Set to 0
              if you only want to detect gestures without drawing anything.
              If you use 1.0, OpenGL GL_LINE is used for drawing; values > 1
              will use an internal drawing method based on triangles (less
              efficient), see :mod:`kivy.graphics`.
      
              :attr:`line_width` is a
              :class:`~kivy.properties.NumericProperty` and defaults to 2
      
          `draw_bbox`
              Set to True if you want to draw bounding box behind gestures.
              This only works if `line_width` >= 1. Default is False.
      
              :attr:`draw_bbox` is a
              :class:`~kivy.properties.BooleanProperty` and defaults to True
      
          `bbox_alpha`
              Opacity for bounding box if `draw_bbox` is True. Default 0.1
      
              :attr:`bbox_alpha` is a
              :class:`~kivy.properties.NumericProperty` and defaults to 0.1
      
      :Events:
          `on_gesture_start` :class:`GestureContainer`
              Fired when a new gesture is initiated on the surface, i.e. the
              first on_touch_down that does not collide with an existing
              gesture on the surface.
      
          `on_gesture_extend` :class:`GestureContainer`
              Fired when a touch_down event occurs within an existing gesture.
      
          `on_gesture_merge` :class:`GestureContainer`, :class:`GestureContainer`
              Fired when two gestures collide and get merged to one gesture.
              The first argument is the gesture that has been merged (no longer
              valid); the second is the combined (resulting) gesture.
      
          `on_gesture_complete` :class:`GestureContainer`
              Fired when a set of strokes is considered a complete gesture,
              this happens when `temporal_window` expires or `max_strokes`
              is reached. Typically you will bind to this event and use
              the provided `GestureContainer` get_vectors() method to
              match against your gesture database.
      
          `on_gesture_cleanup` :class:`GestureContainer`
              Fired `draw_timeout` seconds after `on_gesture_complete`,
              The gesture will be removed from the canvas (if line_width > 0 or
              draw_bbox is True) and the internal gesture list before this.
      
          `on_gesture_discard` :class:`GestureContainer`
              Fired when a gesture does not meet the minimum size requirements
              for recognition (width/height < 5, or consists only of single-
              point strokes).
      ```
      基类: Name(id='FloatLayout', ctx=Load())
      函数 on_touch_down(self: , touch: )
        ```
        When a new touch is registered, the first thing we do is to test if
        it collides with the bounding box of another known gesture. If so, it
        is assumed to be part of that gesture.
        ```
      函数 on_touch_move(self: , touch: )
        ```
        When a touch moves, we add a point to the line on the canvas so the
        path is updated. We must also check if the new point collides with the
        bounding box of another gesture - if so, they should be merged.
        ```
      函数 on_touch_up(self: , touch: )
      函数 init_gesture(self: , touch: )
        ```
        Create a new gesture from touch, i.e. it's the first on
        surface, or was not close enough to any existing gesture (yet)
        ```
      函数 init_stroke(self: , g: , touch: )
      函数 get_gesture(self: , touch: )
        ```
        Returns GestureContainer associated with given touch
        ```
      函数 find_colliding_gesture(self: , touch: )
        ```
        Checks if a touch x/y collides with the bounding box of an existing
        gesture. If so, return it (otherwise returns None)
        ```
      函数 merge_gestures(self: , g: , other: )
        ```
        Merges two gestures together, the oldest one is retained and the
        newer one gets the `GestureContainer.was_merged` flag raised.
        ```
      函数 _update_canvas_bbox(self: , g: )
      函数 _complete_dispatcher(self: , dt: )
        ```
        This method is scheduled on all touch up events. It will dispatch
        the `on_gesture_complete` event for all completed gestures, and remove
        merged gestures from the internal gesture list.
        ```
      函数 _cleanup(self: , dt: )
        ```
        This method is scheduled from _complete_dispatcher to clean up the
        canvas and internal gesture list after a gesture is completed.
        ```
      函数 on_gesture_start(self: )
      函数 on_gesture_extend(self: )
      函数 on_gesture_merge(self: )
      函数 on_gesture_complete(self: )
      函数 on_gesture_discard(self: )
      函数 on_gesture_cleanup(self: )
    分析文件: recyclelayout.py
    类 RecycleLayout:
      ```
      RecycleLayout provides the default layout for RecycleViews.
      ```
      基类: Name(id='RecycleLayoutManagerBehavior', ctx=Load())
      基类: Name(id='Layout', ctx=Load())
      函数 __init__(self: )
      函数 attach_recycleview(self: , rv: )
      函数 detach_recycleview(self: )
      函数 _catch_layout_trigger(self: , instance: , value: )
      函数 compute_sizes_from_data(self: , data: , flags: )
      函数 compute_layout(self: , data: , flags: )
      函数 do_layout(self: )
      函数 set_visible_views(self: , indices: , data: , viewport: )
      函数 refresh_view_layout(self: , index: , layout: , view: , viewport: )
      函数 remove_views(self: )
      函数 remove_view(self: , view: , index: )
      函数 clear_layout(self: )
    分析文件: dropdown.py
    类 DropDownException:
      ```
      DropDownException class.
          
      ```
      基类: Name(id='Exception', ctx=Load())
    类 DropDown:
      ```
      DropDown class. See module documentation for more information.
      
      :Events:
          `on_select`: data
              Fired when a selection is done. The data of the selection is passed
              in as the first argument and is what you pass in the :meth:`select`
              method as the first argument.
          `on_dismiss`:
              .. versionadded:: 1.8.0
      
              Fired when the DropDown is dismissed, either on selection or on
              touching outside the widget.
      ```
      基类: Name(id='ScrollView', ctx=Load())
      函数 __init__(self: )
      函数 on_key_down(self: , instance: , key: , scancode: , codepoint: , modifiers: )
      函数 on_container(self: , instance: , value: )
      函数 open(self: , widget: )
        ```
        Open the dropdown list and attach it to a specific widget.
        Depending on the position of the widget within the window and
        the height of the dropdown, the dropdown might be above or below
        that widget.
        ```
      函数 dismiss(self: )
        ```
        Remove the dropdown widget from the window and detach it from
        the attached widget.
        ```
      函数 _real_dismiss(self: )
      函数 on_dismiss(self: )
      函数 select(self: , data: )
        ```
        Call this method to trigger the `on_select` event with the `data`
        selection. The `data` can be anything you want.
        ```
      函数 on_select(self: , data: )
      函数 add_widget(self: )
      函数 remove_widget(self: )
      函数 clear_widgets(self: )
      函数 on_motion(self: , etype: , me: )
      函数 on_touch_down(self: , touch: )
      函数 on_touch_move(self: , touch: )
      函数 on_touch_up(self: , touch: )
      函数 _reposition(self: )
    函数 show_dropdown(button: )
    函数 touch_move(instance: , touch: )
    分析文件: camera.py
    类 Camera:
      ```
      Camera class. See module documentation for more information.
          
      ```
      基类: Name(id='Image', ctx=Load())
      函数 __init__(self: )
      函数 on_tex(self: , camera: )
      函数 _on_index(self: )
      函数 on_play(self: , instance: , value: )
    分析文件: progressbar.py
    类 ProgressBar:
      ```
      Class for creating a progress bar widget.
      
      See module documentation for more details.
      ```
      基类: Name(id='Widget', ctx=Load())
      函数 __init__(self: )
      函数 _get_value(self: )
      函数 _set_value(self: , value: )
      函数 get_norm_value(self: )
      函数 set_norm_value(self: , value: )
    分析文件: checkbox.py
    类 CheckBox:
      ```
      CheckBox class, see module documentation for more information.
          
      ```
      基类: Name(id='ToggleButtonBehavior', ctx=Load())
      基类: Name(id='Widget', ctx=Load())
      函数 _get_active(self: )
      函数 _set_active(self: , value: )
      函数 __init__(self: )
      函数 _on_state(self: , instance: , value: )
      函数 on_group(self: )
    分析文件: settings.py
    类 SettingSpacer:
      基类: Name(id='Widget', ctx=Load())
    类 SettingItem:
      ```
      Base class for individual settings (within a panel). This class cannot
      be used directly; it is used for implementing the other setting classes.
      It builds a row with a title/description (left) and a setting control
      (right).
      
      Look at :class:`SettingBoolean`, :class:`SettingNumeric` and
      :class:`SettingOptions` for usage examples.
      
      :Events:
          `on_release`
              Fired when the item is touched and then released.
      ```
      基类: Name(id='FloatLayout', ctx=Load())
      函数 __init__(self: )
      函数 add_widget(self: )
      函数 on_touch_down(self: , touch: )
      函数 on_touch_up(self: , touch: )
      函数 on_release(self: )
      函数 on_value(self: , instance: , value: )
    类 SettingBoolean:
      ```
      Implementation of a boolean setting on top of a :class:`SettingItem`.
      It is visualized with a :class:`~kivy.uix.switch.Switch` widget.
      By default, 0 and 1 are used for values: you can change them by setting
      :attr:`values`.
      ```
      基类: Name(id='SettingItem', ctx=Load())
    类 SettingString:
      ```
      Implementation of a string setting on top of a :class:`SettingItem`.
      It is visualized with a :class:`~kivy.uix.label.Label` widget that, when
      clicked, will open a :class:`~kivy.uix.popup.Popup` with a
      :class:`~kivy.uix.textinput.Textinput` so the user can enter a custom
      value.
      ```
      基类: Name(id='SettingItem', ctx=Load())
      函数 on_panel(self: , instance: , value: )
      函数 _dismiss(self: )
      函数 _validate(self: , instance: )
      函数 _create_popup(self: , instance: )
    类 SettingPath:
      ```
      Implementation of a Path setting on top of a :class:`SettingItem`.
      It is visualized with a :class:`~kivy.uix.label.Label` widget that, when
      clicked, will open a :class:`~kivy.uix.popup.Popup` with a
      :class:`~kivy.uix.filechooser.FileChooserListView` so the user can enter
      a custom value.
      
      .. versionadded:: 1.1.0
      ```
      基类: Name(id='SettingItem', ctx=Load())
    类 SettingColor:
      ```
      Implementation of a color setting on top of a :class:`SettingItem`.
      It is visualized with a :class:`~kivy.uix.label.Label` widget and a
      colored canvas rectangle that, when clicked, will open a
      :class:`~kivy.uix.popup.Popup` with a
      :class:`~kivy.uix.colorpicker.ColorPicker` so the user can choose a color.
      
      .. versionadded:: 2.0.1
      ```
      基类: Name(id='SettingItem', ctx=Load())
    类 SettingNumeric:
      ```
      Implementation of a numeric setting on top of a :class:`SettingString`.
      It is visualized with a :class:`~kivy.uix.label.Label` widget that, when
      clicked, will open a :class:`~kivy.uix.popup.Popup` with a
      :class:`~kivy.uix.textinput.Textinput` so the user can enter a custom
      value.
      ```
      基类: Name(id='SettingString', ctx=Load())
    类 SettingOptions:
      ```
      Implementation of an option list on top of a :class:`SettingItem`.
      It is visualized with a :class:`~kivy.uix.label.Label` widget that, when
      clicked, will open a :class:`~kivy.uix.popup.Popup` with a
      list of options from which the user can select.
      ```
      基类: Name(id='SettingItem', ctx=Load())
      函数 _set_option(self: , instance: )
    类 SettingTitle:
      ```
      A simple title label, used to organize the settings in sections.
          
      ```
      基类: Name(id='Label', ctx=Load())
    类 SettingsPanel:
      ```
      This class is used to construct panel settings, for use with a
      :class:`Settings` instance or subclass.
      ```
      基类: Name(id='GridLayout', ctx=Load())
      函数 on_config(self: , instance: , value: )
      函数 get_value(self: , section: , key: )
        ```
        Return the value of the section/key from the :attr:`config`
        ConfigParser instance. This function is used by :class:`SettingItem` to
        get the value for a given section/key.
        
        If you don't want to use a ConfigParser instance, you might want to
        override this function.
        ```
      函数 set_value(self: , section: , key: , value: )
    类 InterfaceWithSidebar:
      ```
      The default Settings interface class. It displays a sidebar menu
      with names of available settings panels, which may be used to switch
      which one is currently displayed.
      
      See :meth:`~InterfaceWithSidebar.add_panel` for information on the
      method you must implement if creating your own interface.
      
      This class also dispatches an event 'on_close', which is triggered
      when the sidebar menu's close button is released. If creating your
      own interface widget, it should also dispatch such an event which
      will automatically be caught by :class:`Settings` and used to
      trigger its own 'on_close' event.
      ```
      基类: Name(id='BoxLayout', ctx=Load())
      函数 add_panel(self: , panel: , name: , uid: )
        ```
        This method is used by Settings to add new panels for possible
        display. Any replacement for ContentPanel *must* implement
        this method.
        
        :Parameters:
            `panel`: :class:`SettingsPanel`
                It should be stored and the interface should provide a way to
                switch between panels.
            `name`:
                The name of the panel as a string. It may be used to represent
                the panel but isn't necessarily unique.
            `uid`:
                A unique int identifying the panel. It should be used to
                identify and switch between panels.
        ```
      函数 on_close(self: )
    类 InterfaceWithSpinner:
      ```
      A settings interface that displays a spinner at the top for
      switching between panels.
      
      The workings of this class are considered internal and are not
      documented. See :meth:`InterfaceWithSidebar` for
      information on implementing your own interface class.
      ```
      基类: Name(id='BoxLayout', ctx=Load())
    类 ContentPanel:
      ```
      A class for displaying settings panels. It displays a single
      settings panel at a time, taking up the full size and shape of the
      ContentPanel. It is used by :class:`InterfaceWithSidebar` and
      :class:`InterfaceWithSpinner` to display settings.
      ```
      基类: Name(id='ScrollView', ctx=Load())
      函数 on_current_uid(self: )
        ```
        The uid of the currently displayed panel. Changing this will
        automatically change the displayed panel.
        
        :Parameters:
            `uid`:
                A panel uid. It should be used to retrieve and display
                a settings panel that has previously been added with
                :meth:`add_panel`.
        ```
      函数 remove_widget(self: )
    类 Settings:
      ```
      Settings UI. Check module documentation for more information on how
      to use this class.
      
      :Events:
          `on_config_change`: ConfigParser instance, section, key, value
              Fired when the section's key-value pair of a ConfigParser changes.
      
              .. warning:
      
                  value will be str/unicode type, regardless of the setting
                  type (numeric, boolean, etc)
          `on_close`
              Fired by the default panel when the Close button is pressed.
      
          
      ```
      基类: Name(id='BoxLayout', ctx=Load())
      函数 register_type(self: , tp: , cls: )
        ```
        Register a new type that can be used in the JSON definition.
                
        ```
      函数 add_interface(self: )
        ```
        (Internal) creates an instance of :attr:`Settings.interface_cls`,
        and sets it to :attr:`~Settings.interface`. When json panels are
        created, they will be added to this interface which will display them
        to the user.
        ```
      函数 on_config_change(self: , config: , section: , key: , value: )
      函数 add_json_panel(self: , title: , config: , filename: , data: )
        ```
        Create and add a new :class:`SettingsPanel` using the configuration
        `config` with the JSON definition `filename`. If `filename` is not set,
        then the JSON definition is read from the `data` parameter instead.
        
        Check the :ref:`settings_json` section in the documentation for more
        information about JSON format and the usage of this function.
        ```
      函数 create_json_panel(self: , title: , config: , filename: , data: )
        ```
        Create new :class:`SettingsPanel`.
        
        .. versionadded:: 1.5.0
        
        Check the documentation of :meth:`add_json_panel` for more information.
        ```
      函数 add_kivy_panel(self: )
        ```
        Add a panel for configuring Kivy. This panel acts directly on the
        kivy configuration. Feel free to include or exclude it in your
        configuration.
        
        See :meth:`~kivy.app.App.use_kivy_settings` for information on
        enabling/disabling the automatic kivy panel.
        ```
    类 SettingsWithSidebar:
      ```
      A settings widget that displays settings panels with a sidebar to
      switch between them. This is the default behaviour of
      :class:`Settings`, and this widget is a trivial wrapper subclass.
      ```
      基类: Name(id='Settings', ctx=Load())
    类 SettingsWithSpinner:
      ```
      A settings widget that displays one settings panel at a time with a
      spinner at the top to switch between them.
      ```
      基类: Name(id='Settings', ctx=Load())
    类 SettingsWithTabbedPanel:
      ```
      A settings widget that displays settings panels as pages in a
      :class:`~kivy.uix.tabbedpanel.TabbedPanel`.
      ```
      基类: Name(id='Settings', ctx=Load())
    类 SettingsWithNoMenu:
      ```
      A settings widget that displays a single settings panel with *no*
      Close button. It will not accept more than one Settings panel. It
      is intended for use in programs with few enough settings that a
      full panel switcher is not useful.
      
      .. warning::
      
          This Settings panel does *not* provide a Close
          button, and so it is impossible to leave the settings screen
          unless you also add other behaviour or override
          :meth:`~kivy.app.App.display_settings` and
          :meth:`~kivy.app.App.close_settings`.
      ```
      基类: Name(id='Settings', ctx=Load())
    类 InterfaceWithNoMenu:
      ```
      The interface widget used by :class:`SettingsWithNoMenu`. It
      stores and displays a single settings panel.
      
      This widget is considered internal and is not documented. See the
      :class:`ContentPanel` for information on defining your own content
      widget.
      ```
      基类: Name(id='ContentPanel', ctx=Load())
    类 InterfaceWithTabbedPanel:
      ```
      The content widget used by :class:`SettingsWithTabbedPanel`. It
      stores and displays Settings panels in tabs of a TabbedPanel.
      
      This widget is considered internal and is not documented. See
      :class:`InterfaceWithSidebar` for information on defining your own
      interface widget.
      ```
      基类: Name(id='FloatLayout', ctx=Load())
    类 MenuSpinner:
      ```
      The menu class used by :class:`SettingsWithSpinner`. It provides a
      sidebar with an entry for each settings panel.
      
      This widget is considered internal and is not documented. See
      :class:`MenuSidebar` for information on menus and creating your own menu
      class.
      ```
      基类: Name(id='BoxLayout', ctx=Load())
      函数 add_item(self: , name: , uid: )
      函数 on_spinner_text(self: )
    类 MenuSidebar:
      ```
      The menu used by :class:`InterfaceWithSidebar`. It provides a
      sidebar with an entry for each settings panel, which the user may
      click to select.
      ```
      基类: Name(id='FloatLayout', ctx=Load())
      函数 on_selected_uid(self: )
        ```
        (internal) unselects any currently selected menu buttons, unless
        they represent the current panel.
        ```
    类 SettingSidebarLabel:
      基类: Name(id='Label', ctx=Load())
    类 SettingsApp:
      基类: Name(id='App', ctx=Load())
      函数 build(self: )
      函数 build_config(self: , config: )
    分析文件: actionbar.py
    类 ActionBarException:
      ```
      ActionBarException class
      ```
      基类: Name(id='Exception', ctx=Load())
    类 ActionItem:
      ```
      ActionItem class, an abstract class for all ActionBar widgets. To create a
      custom widget for an ActionBar, inherit from this class. See module
      documentation for more information.
      ```
      基类: Name(id='object', ctx=Load())
      函数 get_pack_width(self: )
    类 ActionButton:
      ```
      ActionButton class, see module documentation for more information.
      
      The text color, width and size_hint_x are set manually via the Kv language
      file. It covers a lot of cases: with/without an icon, with/without a group
      and takes care of the padding between elements.
      
      You don't have much control over these properties, so if you want to
      customize its appearance, we suggest you create you own button
      representation. You can do this by creating a class that subclasses an
      existing widget and an :class:`ActionItem`::
      
          class MyOwnActionButton(Button, ActionItem):
              pass
      
      You can then create your own style using the Kv language.
      ```
      基类: Name(id='Button', ctx=Load())
      基类: Name(id='ActionItem', ctx=Load())
    类 ActionPrevious:
      ```
      ActionPrevious class, see module documentation for more information.
      ```
      基类: Name(id='BoxLayout', ctx=Load())
      基类: Name(id='ActionItem', ctx=Load())
      函数 __init__(self: )
      函数 on_press(self: )
      函数 on_release(self: )
    类 ActionToggleButton:
      ```
      ActionToggleButton class, see module documentation for more information.
      ```
      基类: Name(id='ActionItem', ctx=Load())
      基类: Name(id='ToggleButton', ctx=Load())
    类 ActionLabel:
      ```
      ActionLabel class, see module documentation for more information.
      ```
      基类: Name(id='ActionItem', ctx=Load())
      基类: Name(id='Label', ctx=Load())
    类 ActionCheck:
      ```
      ActionCheck class, see module documentation for more information.
      ```
      基类: Name(id='ActionItem', ctx=Load())
      基类: Name(id='CheckBox', ctx=Load())
    类 ActionSeparator:
      ```
      ActionSeparator class, see module documentation for more information.
      ```
      基类: Name(id='ActionItem', ctx=Load())
      基类: Name(id='Widget', ctx=Load())
    类 ActionDropDown:
      ```
      ActionDropDown class, see module documentation for more information.
      ```
      基类: Name(id='DropDown', ctx=Load())
    类 ActionGroup:
      ```
      ActionGroup class, see module documentation for more information.
      ```
      基类: Name(id='ActionItem', ctx=Load())
      基类: Name(id='Button', ctx=Load())
      函数 on_is_open(self: , instance: , value: )
      函数 _toggle_dropdown(self: )
      函数 add_widget(self: , widget: )
        ```
        .. versionchanged:: 2.1.0
            Renamed argument `item` to `widget`.
        ```
      函数 show_group(self: )
      函数 clear_widgets(self: )
    类 ActionOverflow:
      ```
      ActionOverflow class, see module documentation for more information.
      ```
      基类: Name(id='ActionGroup', ctx=Load())
      函数 show_default_items(self: , parent: )
    类 ActionView:
      ```
      ActionView class, see module documentation for more information.
      ```
      基类: Name(id='BoxLayout', ctx=Load())
      函数 on_action_previous(self: , instance: , value: )
      函数 on_use_separator(self: , instance: , value: )
      函数 remove_widget(self: , widget: )
      函数 _clear_all(self: )
      函数 _layout_all(self: )
      函数 _layout_group(self: )
      函数 _layout_random(self: )
      函数 on_width(self: , width: )
    类 ContextualActionView:
      ```
      ContextualActionView class, see the module documentation for more
      information.
      ```
      基类: Name(id='ActionView', ctx=Load())
    类 ActionBar:
      ```
      ActionBar class, which acts as the main container for an
      :class:`ActionView` instance. The ActionBar determines the overall
      styling aspects of the bar. :class:`ActionItem`\s are not added to
      this class directly, but to the contained :class:`ActionView` instance.
      
      :Events:
          `on_previous`
              Fired when action_previous of action_view is pressed.
      
      Please see the module documentation for more information.
      ```
      基类: Name(id='BoxLayout', ctx=Load())
      函数 on_previous(self: )
      函数 _pop_contextual_action_view(self: )
        ```
        Remove the current ContextualActionView and display either the
        previous one or the ActionView.
        ```
    类 MainWindow:
      基类: Name(id='FloatLayout', ctx=Load())
    分析文件: popup.py
    类 PopupException:
      ```
      Popup exception, fired when multiple content widgets are added to the
      popup.
      
      .. versionadded:: 1.4.0
      ```
      基类: Name(id='Exception', ctx=Load())
    类 Popup:
      ```
      Popup class. See module documentation for more information.
      
      :Events:
          `on_open`:
              Fired when the Popup is opened.
          `on_dismiss`:
              Fired when the Popup is closed. If the callback returns True, the
              dismiss will be canceled.
      ```
      基类: Name(id='ModalView', ctx=Load())
      函数 add_widget(self: , widget: )
      函数 on_content(self: , instance: , value: )
      函数 on__container(self: , instance: , value: )
      函数 on_touch_down(self: , touch: )
    分析文件: scrollview.py
    类 ScrollView:
      ```
      ScrollView class. See module documentation for more information.
      
      :Events:
          `on_scroll_start`
              Generic event fired when scrolling starts from touch.
          `on_scroll_move`
              Generic event fired when scrolling move from touch.
          `on_scroll_stop`
              Generic event fired when scrolling stops from touch.
      
      .. versionchanged:: 1.9.0
          `on_scroll_start`, `on_scroll_move` and `on_scroll_stop` events are
          now dispatched when scrolling to handle nested ScrollViews.
      
      .. versionchanged:: 1.7.0
          `auto_scroll`, `scroll_friction`, `scroll_moves`, `scroll_stoptime' has
          been deprecated, use :attr:`effect_cls` instead.
      ```
      基类: Name(id='StencilView', ctx=Load())
      函数 _get_do_scroll(self: )
      函数 _set_do_scroll(self: , value: )
      函数 _get_vbar(self: )
      函数 _get_hbar(self: )
      函数 _set_viewport_size(self: , instance: , value: )
      函数 on__viewport(self: , instance: , value: )
      函数 __init__(self: )
      函数 on_effect_x(self: , instance: , value: )
      函数 on_effect_y(self: , instance: , value: )
      函数 on_effect_cls(self: , instance: , cls: )
      函数 _update_effect_widget(self: )
      函数 _update_effect_x_bounds(self: )
      函数 _update_effect_y_bounds(self: )
      函数 _update_effect_bounds(self: )
      函数 _update_effect_x(self: )
      函数 _update_effect_y(self: )
      函数 to_local(self: , x: , y: )
      函数 to_parent(self: , x: , y: )
      函数 _apply_transform(self: , m: , pos: )
      函数 simulate_touch_down(self: , touch: )
      函数 on_motion(self: , etype: , me: )
      函数 on_touch_down(self: , touch: )
      函数 _touch_in_handle(self: , pos: , size: , touch: )
      函数 on_scroll_start(self: , touch: , check_children: )
      函数 on_touch_move(self: , touch: )
      函数 on_scroll_move(self: , touch: )
      函数 on_touch_up(self: , touch: )
      函数 on_scroll_stop(self: , touch: , check_children: )
      函数 scroll_to(self: , widget: , padding: , animate: )
        ```
        Scrolls the viewport to ensure that the given widget is visible,
        optionally with padding and animation. If animate is True (the
        default), then the default animation parameters will be used.
        Otherwise, it should be a dict containing arguments to pass to
        :class:`~kivy.animation.Animation` constructor.
        
        .. versionadded:: 1.9.1
        ```
      函数 convert_distance_to_scroll(self: , dx: , dy: )
        ```
        Convert a distance in pixels to a scroll distance, depending on the
        content size and the scrollview size.
        
        The result will be a tuple of scroll distance that can be added to
        :data:`scroll_x` and :data:`scroll_y`
        ```
      函数 update_from_scroll(self: )
        ```
        Force the reposition of the content, according to current value of
        :attr:`scroll_x` and :attr:`scroll_y`.
        
        This method is automatically called when one of the :attr:`scroll_x`,
        :attr:`scroll_y`, :attr:`pos` or :attr:`size` properties change, or
        if the size of the content changes.
        ```
      函数 _bind_inactive_bar_color(self: )
      函数 _change_bar_color(self: , inst: , value: )
      函数 add_widget(self: , widget: )
      函数 remove_widget(self: , widget: )
      函数 _get_uid(self: , prefix: )
      函数 _change_touch_mode(self: )
      函数 _do_touch_up(self: , touch: )
    类 ScrollViewApp:
      基类: Name(id='App', ctx=Load())
      函数 build(self: )
    分析文件: colorpicker.py
    函数 distance(pt1: , pt2: )
    函数 polar_to_rect(origin: , r: , theta: )
    函数 rect_to_polar(origin: , x: , y: )
    类 ColorWheel:
      ```
      Chromatic wheel for the ColorPicker.
      
      .. versionchanged:: 1.7.1
          `font_size`, `font_name` and `foreground_color` have been removed. The
          sizing is now the same as others widget, based on 'sp'. Orientation is
          also automatically determined according to the width/height ratio.
      ```
      基类: Name(id='Widget', ctx=Load())
      函数 __init__(self: )
      函数 on__origin(self: , instance: , value: )
      函数 on__radius(self: , instance: , value: )
      函数 init_wheel(self: , dt: )
      函数 recolor_wheel(self: )
      函数 change_alpha(self: , val: )
      函数 inertial_incr_sv_idx(self: , dt: )
      函数 inertial_decr_sv_idx(self: , dt: )
      函数 on_touch_down(self: , touch: )
      函数 on_touch_move(self: , touch: )
      函数 on_touch_up(self: , touch: )
      函数 _get_touch_r(self: , pos: )
    类 _ColorArc:
      基类: Name(id='InstructionGroup', ctx=Load())
      函数 __str__(self: )
      函数 get_mesh(self: )
      函数 change_color(self: , color: , color_delta: , sv: , a: )
    类 ColorPicker:
      ```
      See module documentation.
      ```
      基类: Name(id='RelativeLayout', ctx=Load())
      函数 _get_hsv(self: )
      函数 _set_hsv(self: , value: )
      函数 _get_hex(self: )
      函数 _set_hex(self: , value: )
      函数 _trigger_update_clr(self: , mode: , clr_idx: , text: )
      函数 _update_clr(self: , dt: )
      函数 _update_hex(self: , dt: )
      函数 _trigger_update_hex(self: , text: )
      函数 set_color(self: , color: )
    类 ColorPickerApp:
      基类: Name(id='App', ctx=Load())
      函数 build(self: )
    分析文件: scatterlayout.py
    类 ScatterLayout:
      ```
      ScatterLayout class, see module documentation for more information.
          
      ```
      基类: Name(id='Scatter', ctx=Load())
      函数 __init__(self: )
      函数 update_size(self: , instance: , size: )
      函数 add_widget(self: )
      函数 remove_widget(self: )
      函数 clear_widgets(self: )
    类 ScatterPlaneLayout:
      ```
      ScatterPlaneLayout class, see module documentation for more information.
      
      Similar to ScatterLayout, but based on ScatterPlane - so the input is not
      bounded.
      
      .. versionadded:: 1.9.0
      ```
      基类: Name(id='ScatterPlane', ctx=Load())
      函数 collide_point(self: , x: , y: )
    分析文件: accordion.py
    类 AccordionException:
      ```
      AccordionException class.
          
      ```
      基类: Name(id='Exception', ctx=Load())
    类 AccordionItem:
      ```
      AccordionItem class that must be used in conjunction with the
      :class:`Accordion` class. See the module documentation for more
      information.
      ```
      基类: Name(id='FloatLayout', ctx=Load())
      函数 __init__(self: )
      函数 add_widget(self: )
      函数 remove_widget(self: )
      函数 on_collapse(self: , instance: , value: )
      函数 on_collapse_alpha(self: , instance: , value: )
      函数 on_touch_down(self: , touch: )
      函数 _update_title(self: , dt: )
    类 Accordion:
      ```
      Accordion class. See module documentation for more information.
          
      ```
      基类: Name(id='Widget', ctx=Load())
      函数 select(self: , instance: )
      函数 _do_layout(self: , dt: )
    函数 toggle_layout()
    函数 select_2nd_item()
    函数 update_min_space(instance: , value: )
    分析文件: video.py
    类 Video:
      ```
      Video class. See module documentation for more information.
          
      ```
      基类: Name(id='Image', ctx=Load())
      函数 __init__(self: )
      函数 texture_update(self: )
      函数 seek(self: , percent: , precise: )
        ```
        Change the position to a percentage (strictly, a proportion)
           of duration.
        
        :Parameters:
            `percent`: float or int
                Position to seek as a proportion of the total duration,
                must be between 0-1.
            `precise`: bool, defaults to True
                Precise seeking is slower, but seeks to exact requested
                percent.
        
        .. warning::
            Calling seek() before the video is loaded has no effect.
        
        .. versionadded:: 1.2.0
        
        .. versionchanged:: 1.10.1
            The `precise` keyword argument has been added.
        ```
      函数 _trigger_video_load(self: )
      函数 _do_video_load(self: )
      函数 on_play(self: , instance: , value: )
      函数 on_state(self: , instance: , value: )
      函数 _on_video_frame(self: )
      函数 _on_eos(self: )
      函数 _on_load(self: )
      函数 on_volume(self: , instance: , value: )
      函数 unload(self: )
        ```
        Unload the video. The playback will be stopped.
        
        .. versionadded:: 1.8.0
        ```
    类 VideoApp:
      基类: Name(id='App', ctx=Load())
      函数 build(self: )
      函数 replay(self: )
    分析文件: screenmanager.py
    类 ScreenManagerException:
      ```
      Exception for the :class:`ScreenManager`.
          
      ```
      基类: Name(id='Exception', ctx=Load())
    类 Screen:
      ```
      Screen is an element intended to be used with a :class:`ScreenManager`.
      Check module documentation for more information.
      
      :Events:
          `on_pre_enter`: ()
              Event fired when the screen is about to be used: the entering
              animation is started.
          `on_enter`: ()
              Event fired when the screen is displayed: the entering animation is
              complete.
          `on_pre_leave`: ()
              Event fired when the screen is about to be removed: the leaving
              animation is started.
          `on_leave`: ()
              Event fired when the screen is removed: the leaving animation is
              finished.
      
      .. versionchanged:: 1.6.0
          Events `on_pre_enter`, `on_enter`, `on_pre_leave` and `on_leave` were
          added.
      ```
      基类: Name(id='RelativeLayout', ctx=Load())
      函数 on_pre_enter(self: )
      函数 on_enter(self: )
      函数 on_pre_leave(self: )
      函数 on_leave(self: )
      函数 __repr__(self: )
    类 TransitionBase:
      ```
      TransitionBase is used to animate 2 screens within the
      :class:`ScreenManager`. This class acts as a base for other
      implementations like the :class:`SlideTransition` and
      :class:`SwapTransition`.
      
      :Events:
          `on_progress`: Transition object, progression float
              Fired during the animation of the transition.
          `on_complete`: Transition object
              Fired when the transition is finished.
      ```
      基类: Name(id='EventDispatcher', ctx=Load())
      函数 start(self: , manager: )
        ```
        (internal) Starts the transition. This is automatically
        called by the :class:`ScreenManager`.
        ```
      函数 stop(self: )
        ```
        (internal) Stops the transition. This is automatically called by the
        :class:`ScreenManager`.
        ```
      函数 add_screen(self: , screen: )
        ```
        (internal) Used to add a screen to the :class:`ScreenManager`.
                
        ```
      函数 remove_screen(self: , screen: )
        ```
        (internal) Used to remove a screen from the :class:`ScreenManager`.
                
        ```
      函数 on_complete(self: )
      函数 on_progress(self: , progression: )
      函数 _on_progress(self: )
      函数 _on_complete(self: )
    类 ShaderTransition:
      ```
      Transition class that uses a Shader for animating the transition between
      2 screens. By default, this class doesn't assign any fragment/vertex
      shader. If you want to create your own fragment shader for the transition,
      you need to declare the header yourself and include the "t", "tex_in" and
      "tex_out" uniform::
      
          # Create your own transition. This shader implements a "fading"
          # transition.
          fs = """$HEADER
              uniform float t;
              uniform sampler2D tex_in;
              uniform sampler2D tex_out;
      
              void main(void) {
                  vec4 cin = texture2D(tex_in, tex_coord0);
                  vec4 cout = texture2D(tex_out, tex_coord0);
                  gl_FragColor = mix(cout, cin, t);
              }
          """
      
          # And create your transition
          tr = ShaderTransition(fs=fs)
          sm = ScreenManager(transition=tr)
      ```
      基类: Name(id='TransitionBase', ctx=Load())
      函数 make_screen_fbo(self: , screen: )
      函数 _remove_out_canvas(self: )
    类 NoTransition:
      ```
      No transition, instantly switches to the next screen with no delay or
      animation.
      
      .. versionadded:: 1.8.0
      ```
      基类: Name(id='TransitionBase', ctx=Load())
    类 SlideTransition:
      ```
      Slide Transition, can be used to show a new screen from any direction:
      left, right, up or down.
      ```
      基类: Name(id='TransitionBase', ctx=Load())
    类 CardTransition:
      ```
      Card transition that looks similar to Android 4.x application drawer
      interface animation.
      
      It supports 4 directions like SlideTransition: left, right, up and down,
      and two modes, pop and push. If push mode is activated, the previous
      screen does not move, and the new one slides in from the given direction.
      If the pop mode is activated, the previous screen slides out, when the new
      screen is already on the position of the ScreenManager.
      
      .. versionadded:: 1.10
      ```
      基类: Name(id='SlideTransition', ctx=Load())
    类 SwapTransition:
      ```
      Swap transition that looks like iOS transition when a new window
      appears on the screen.
      ```
      基类: Name(id='TransitionBase', ctx=Load())
      函数 __init__(self: )
      函数 update_scale(self: , screen: , center: )
    类 WipeTransition:
      ```
      Wipe transition, based on a fragment Shader.
          
      ```
      基类: Name(id='ShaderTransition', ctx=Load())
    类 FadeTransition:
      ```
      Fade transition, based on a fragment Shader.
          
      ```
      基类: Name(id='ShaderTransition', ctx=Load())
    类 FallOutTransition:
      ```
      Transition where the new screen 'falls' from the screen centre,
      becoming smaller and more transparent until it disappears, and
      revealing the new screen behind it. Mimics the popular/standard
      Android transition.
      
      .. versionadded:: 1.8.0
      ```
      基类: Name(id='ShaderTransition', ctx=Load())
    类 RiseInTransition:
      ```
      Transition where the new screen rises from the screen centre,
      becoming larger and changing from transparent to opaque until it
      fills the screen. Mimics the popular/standard Android transition.
      
      .. versionadded:: 1.8.0
      ```
      基类: Name(id='ShaderTransition', ctx=Load())
    类 ScreenManager:
      ```
      Screen manager. This is the main class that will control your
      :class:`Screen` stack and memory.
      
      By default, the manager will show only one screen at a time.
      ```
      基类: Name(id='FloatLayout', ctx=Load())
      函数 _get_screen_names(self: )
      函数 _screen_name_changed(self: , screen: , name: )
      函数 add_widget(self: , widget: )
        ```
        .. versionchanged:: 2.1.0
            Renamed argument `screen` to `widget`.
        ```
      函数 remove_widget(self: , widget: )
      函数 clear_widgets(self: , children: )
        ```
        .. versionchanged:: 2.1.0
            Renamed argument `screens` to `children`.
        ```
      函数 real_add_widget(self: , screen: )
      函数 real_remove_widget(self: , screen: )
      函数 on_current(self: , instance: , value: )
      函数 get_screen(self: , name: )
        ```
        Return the screen widget associated with the name or raise a
        :class:`ScreenManagerException` if not found.
        ```
      函数 has_screen(self: , name: )
        ```
        Return True if a screen with the `name` has been found.
        
        .. versionadded:: 1.6.0
        ```
      函数 __next__(self: )
        ```
        Py2K backwards compatibility without six or other lib.
                
        ```
      函数 next(self: )
        ```
        Return the name of the next screen from the screen list.
        ```
      函数 previous(self: )
        ```
        Return the name of the previous screen from the screen list.
                
        ```
      函数 switch_to(self: , screen: )
        ```
        Add a new or existing screen to the ScreenManager and switch to it.
        The previous screen will be "switched away" from. `options` are the
        :attr:`transition` options that will be changed before the animation
        happens.
        
        If no previous screens are available, the screen will be used as the
        main one::
        
            sm = ScreenManager()
            sm.switch_to(screen1)
            # later
            sm.switch_to(screen2, direction='left')
            # later
            sm.switch_to(screen3, direction='right', duration=1.)
        
        If any animation is in progress, it will be stopped and replaced by
        this one: you should avoid this because the animation will just look
        weird. Use either :meth:`switch_to` or :attr:`current` but not both.
        
        The `screen` name will be changed if there is any conflict with the
        current screen.
        
        .. versionadded: 1.8.0
        ```
      函数 _generate_screen_name(self: )
      函数 _update_pos(self: , instance: , value: )
      函数 on_motion(self: , etype: , me: )
      函数 on_touch_down(self: , touch: )
      函数 on_touch_move(self: , touch: )
      函数 on_touch_up(self: , touch: )
    类 TestApp:
      基类: Name(id='App', ctx=Load())
      函数 change_view(self: )
      函数 build(self: )
    函数 remove_screen_out(instr: )
    函数 remove_old_screen(transition: )
    分析文件: stacklayout.py
    函数 _compute_size(c: , available_size: , idx: )
    类 StackLayout:
      ```
      Stack layout class. See module documentation for more information.
          
      ```
      基类: Name(id='Layout', ctx=Load())
      函数 __init__(self: )
      函数 do_layout(self: )
    分析文件: spinner.py
    类 SpinnerOption:
      ```
      Special button used in the :class:`Spinner` dropdown list. By default,
      this is just a :class:`~kivy.uix.button.Button` with a size_hint_y of None
      and a height of :meth:`48dp <kivy.metrics.dp>`.
      ```
      基类: Name(id='Button', ctx=Load())
    类 Spinner:
      ```
      Spinner class, see module documentation for more information.
          
      ```
      基类: Name(id='Button', ctx=Load())
      函数 __init__(self: )
      函数 _build_dropdown(self: )
      函数 _update_dropdown_size(self: )
      函数 _update_dropdown(self: )
      函数 _toggle_dropdown(self: )
      函数 _close_dropdown(self: )
      函数 _on_dropdown_select(self: , instance: , data: )
      函数 on_is_open(self: , instance: , value: )
    分析文件: videoplayer.py
    类 VideoPlayerVolume:
      基类: Name(id='Image', ctx=Load())
      函数 on_touch_down(self: , touch: )
      函数 on_touch_move(self: , touch: )
      函数 on_touch_up(self: , touch: )
    类 VideoPlayerPlayPause:
      基类: Name(id='Image', ctx=Load())
    类 VideoPlayerStop:
      基类: Name(id='Image', ctx=Load())
    类 VideoPlayerProgressBar:
      基类: Name(id='ProgressBar', ctx=Load())
      函数 __init__(self: )
      函数 on_video(self: , instance: , value: )
      函数 _update_seek(self: , x: )
      函数 _show_bubble(self: )
      函数 _hide_bubble(self: )
      函数 on_alpha(self: , instance: , value: )
      函数 _update_bubble(self: )
      函数 _showhide_bubble(self: , instance: , value: )
    类 VideoPlayerPreview:
      基类: Name(id='FloatLayout', ctx=Load())
    类 VideoPlayerAnnotation:
      ```
      Annotation class used for creating annotation labels.
      
      Additional keys are available:
      
      * bgcolor: [r, g, b, a] - background color of the text box
      * bgsource: 'filename' - background image used for the background text box
      * border: (n, e, s, w) - border used for the background image
      ```
      基类: Name(id='Label', ctx=Load())
      函数 on_annotation(self: , instance: , ann: )
    类 VideoPlayer:
      ```
      VideoPlayer class. See module documentation for more information.
          
      ```
      基类: Name(id='GridLayout', ctx=Load())
      函数 _trigger_video_load(self: )
      函数 _try_load_default_thumbnail(self: )
      函数 _try_load_default_annotations(self: )
      函数 on_source(self: , instance: , value: )
      函数 _update_thumbnail(self: )
      函数 _update_annotations(self: )
      函数 on_image_overlay_play(self: , instance: , value: )
      函数 on_image_loading(self: , instance: , value: )
      函数 _load_thumbnail(self: , thumbnail: )
      函数 _load_annotations(self: , annotations: )
      函数 on_state(self: , instance: , value: )
      函数 _set_state(self: , instance: , value: )
      函数 _do_video_load(self: )
      函数 on_play(self: , instance: , value: )
      函数 on_volume(self: , instance: , value: )
      函数 on_position(self: , instance: , value: )
      函数 seek(self: , percent: , precise: )
        ```
        Change the position to a percentage (strictly, a proportion)
           of duration.
        
        :Parameters:
            `percent`: float or int
                Position to seek as a proportion of total duration, must
                be between 0-1.
            `precise`: bool, defaults to True
                Precise seeking is slower, but seeks to exact requested
                percent.
        
        .. warning::
            Calling seek() before the video is loaded has no effect.
        
        .. versionadded:: 1.2.0
        
        .. versionchanged:: 1.10.1
            The `precise` keyword argument has been added.
        ```
      函数 _play_started(self: , instance: , value: )
      函数 on_fullscreen(self: , instance: , value: )
    分析文件: bubble.py
    类 BubbleException:
      基类: Name(id='Exception', ctx=Load())
    类 BubbleButton:
      ```
      A button intended for use in a BubbleContent widget.
      You can use a "normal" button class, but it will not look good unless the
      background is changed.
      
      Rather use this BubbleButton widget that is already defined and provides a
      suitable background for you.
      ```
      基类: Name(id='Button', ctx=Load())
    类 BubbleContent:
      ```
      A styled BoxLayout that can be used as the content widget of a Bubble.
      
      .. versionchanged:: 2.2.0
      The graphical appearance of :class:`BubbleContent` is now based on it's
      own properties :attr:`background_image`, :attr:`background_color`,
      :attr:`border` and :attr:`border_auto_scale`. The parent widget properties
      are no longer considered. This makes the BubbleContent a standalone themed
      BoxLayout.
      ```
      基类: Name(id='BoxLayout', ctx=Load())
    类 Bubble:
      ```
      Bubble class. See module documentation for more information.
          
      ```
      基类: Name(id='BoxLayout', ctx=Load())
      函数 __init__(self: )
      函数 add_widget(self: , widget: )
      函数 remove_widget(self: , widget: )
      函数 on_content_size(self: , instance: , value: )
      函数 on_limit_to(self: , instance: , value: )
      函数 on_pos(self: , instance: , value: )
      函数 on_size(self: , instance: , value: )
      函数 on_arrow_image(self: , instance: , value: )
      函数 on_arrow_color(self: , instance: , value: )
      函数 on_arrow_pos(self: , instance: , value: )
      函数 on_flex_arrow_pos(self: , instance: , value: )
      函数 get_flex_arrow_layout_params(self: )
      函数 update_content_size(self: , instance: , value: )
      函数 adjust_position(self: )
      函数 reposition_inner_widgets(self: )
    函数 calc_x0(x: , length: )
    分析文件: filechooser.py
    函数 alphanumeric_folders_first(files: , filesystem: )
    类 FileSystemAbstract:
      ```
      Class for implementing a File System view that can be used with the
      :class:`FileChooser <FileChooser>`.
      
      .. versionadded:: 1.8.0
      ```
      基类: Name(id='object', ctx=Load())
      函数 listdir(self: , fn: )
        ```
        Return the list of files in the directory `fn`
                
        ```
      函数 getsize(self: , fn: )
        ```
        Return the size in bytes of a file
                
        ```
      函数 is_hidden(self: , fn: )
        ```
        Return True if the file is hidden
                
        ```
      函数 is_dir(self: , fn: )
        ```
        Return True if the argument passed to this method is a directory
                
        ```
    类 FileSystemLocal:
      ```
      Implementation of :class:`FileSystemAbstract` for local files.
      
      .. versionadded:: 1.8.0
      ```
      基类: Name(id='FileSystemAbstract', ctx=Load())
    类 FileChooserProgressBase:
      ```
      Base for implementing a progress view. This view is used when too many
      entries need to be created and are delayed over multiple frames.
      
      .. versionadded:: 1.2.0
      ```
      基类: Name(id='FloatLayout', ctx=Load())
      函数 cancel(self: )
        ```
        Cancel any action from the FileChooserController.
                
        ```
      函数 on_touch_down(self: , touch: )
      函数 on_touch_move(self: , touch: )
      函数 on_touch_up(self: , touch: )
    类 FileChooserProgress:
      基类: Name(id='FileChooserProgressBase', ctx=Load())
    类 FileChooserLayout:
      ```
      Base class for file chooser layouts.
      
      .. versionadded:: 1.9.0
      ```
      基类: Name(id='FloatLayout', ctx=Load())
      函数 on_entry_added(self: , node: , parent: )
      函数 on_entries_cleared(self: )
      函数 on_subentry_to_entry(self: , subentry: , entry: )
      函数 on_remove_subentry(self: , subentry: , entry: )
      函数 on_submit(self: , selected: , touch: )
    类 FileChooserListLayout:
      ```
      File chooser layout using a list view.
      
      .. versionadded:: 1.9.0
      ```
      基类: Name(id='FileChooserLayout', ctx=Load())
      函数 __init__(self: )
      函数 scroll_to_top(self: )
    类 FileChooserIconLayout:
      ```
      File chooser layout using an icon view.
      
      .. versionadded:: 1.9.0
      ```
      基类: Name(id='FileChooserLayout', ctx=Load())
    类 FileChooserController:
      ```
      Base for implementing a FileChooser. Don't use this class directly, but
      prefer using an implementation such as the :class:`FileChooser`,
      :class:`FileChooserListView` or :class:`FileChooserIconView`.
      
      :Events:
          `on_entry_added`: entry, parent
              Fired when a root-level entry is added to the file list. If you
              return True from this event, the entry is not added to FileChooser.
          `on_entries_cleared`
              Fired when the the entries list is cleared, usually when the
              root is refreshed.
          `on_subentry_to_entry`: entry, parent
              Fired when a sub-entry is added to an existing entry or
              when entries are removed from an entry e.g. when
              a node is closed.
          `on_submit`: selection, touch
              Fired when a file has been selected with a double-tap.
      ```
      基类: Name(id='RelativeLayout', ctx=Load())
      函数 _update_item_selection(self: )
      函数 _save_previous_path(self: , instance: , value: )
      函数 _trigger_update(self: )
      函数 entry_touched(self: , entry: , touch: )
        ```
        (internal) This method must be called by the template when an entry
        is touched by the user.
        ```
      函数 entry_released(self: , entry: , touch: )
        ```
        (internal) This method must be called by the template when an entry
        is touched by the user.
        
        .. versionadded:: 1.1.0
        ```
      函数 open_entry(self: , entry: )
      函数 _apply_filters(self: , files: )
      函数 get_nice_size(self: , fn: )
        ```
        Pass the filepath. Returns the size in the best human readable
        format or '' if it is a directory (Don't recursively calculate size).
        ```
      函数 _update_files(self: )
      函数 _get_file_paths(self: , items: )
      函数 _create_files_entries(self: )
      函数 _show_progress(self: )
      函数 _hide_progress(self: )
      函数 _generate_file_entries(self: )
      函数 _create_entry_widget(self: , ctx: )
      函数 _add_files(self: , path: , parent: )
      函数 entry_subselect(self: , entry: )
      函数 close_subselection(self: , entry: )
    类 FileChooserListView:
      ```
      Implementation of a :class:`FileChooserController` using a list view.
      
      .. versionadded:: 1.9.0
      ```
      基类: Name(id='FileChooserController', ctx=Load())
    类 FileChooserIconView:
      ```
      Implementation of a :class:`FileChooserController` using an icon view.
      
      .. versionadded:: 1.9.0
      ```
      基类: Name(id='FileChooserController', ctx=Load())
    类 FileChooser:
      ```
      Implementation of a :class:`FileChooserController` which supports
      switching between multiple, synced layout views.
      
      The FileChooser can be used as follows:
      
      .. code-block:: kv
      
          BoxLayout:
              orientation: 'vertical'
      
              BoxLayout:
                  size_hint_y: None
                  height: sp(52)
      
                  Button:
                      text: 'Icon View'
                      on_press: fc.view_mode = 'icon'
                  Button:
                      text: 'List View'
                      on_press: fc.view_mode = 'list'
      
              FileChooser:
                  id: fc
                  FileChooserIconLayout
                  FileChooserListLayout
      
      .. versionadded:: 1.9.0
      ```
      基类: Name(id='FileChooserController', ctx=Load())
      函数 get_view_list(self: )
      函数 get_view_mode(self: )
      函数 set_view_mode(self: , mode: )
      函数 _views(self: )
      函数 add_widget(self: , widget: )
      函数 rebuild_views(self: )
      函数 update_view(self: )
    类 FileChooserApp:
      基类: Name(id='App', ctx=Load())
      函数 build(self: )
    分析文件: boxlayout.py
    类 BoxLayout:
      ```
      Box layout class. See module documentation for more information.
          
      ```
      基类: Name(id='Layout', ctx=Load())
      函数 __init__(self: )
      函数 _iterate_layout(self: , sizes: )
      函数 do_layout(self: )
      函数 add_widget(self: , widget: )
      函数 remove_widget(self: , widget: )
    分析文件: __init__.py
    分析文件: label.py
    类 Label:
      ```
      Label class, see module documentation for more information.
      
      :Events:
          `on_ref_press`
              Fired when the user clicks on a word referenced with a
              ``[ref]`` tag in a text markup.
      ```
      基类: Name(id='Widget', ctx=Load())
      函数 __init__(self: )
      函数 _create_label(self: )
      函数 _trigger_texture_update(self: , name: , source: , value: )
      函数 texture_update(self: )
        ```
        Force texture recreation with the current Label properties.
        
        After this function call, the :attr:`texture` and :attr:`texture_size`
        will be updated in this order.
        ```
      函数 on_touch_down(self: , touch: )
      函数 on_ref_press(self: , ref: )
  deps/
    分析文件: __init__.py
  分析文件: support.py
  函数 install_gobject_iteration()
    ```
    Import and install gobject context iteration inside our event loop.
    This is used as soon as gobject is used (like gstreamer).
    ```
  函数 _android_ask_redraw()
  函数 install_android()
    ```
    Install hooks for the android platform.
    
    * Automatically sleep when the device is paused.
    * Automatically kill the application when the return key is pressed.
    ```
  函数 install_twisted_reactor()
    ```
    Installs a threaded twisted reactor, which will schedule one
    reactor iteration before the next frame only when twisted needs
    to do some work.
    
    Any arguments or keyword arguments passed to this function will be
    passed on the the threadedselect reactors interleave function. These
    are the arguments one would usually pass to twisted's reactor.startRunning.
    
    Unlike the default twisted reactor, the installed reactor will not handle
    any signals unless you set the 'installSignalHandlers' keyword argument
    to 1 explicitly. This is done to allow kivy to handle the signals as
    usual unless you specifically want the twisted reactor to handle the
    signals (e.g. SIGINT).
    
    .. note::
        Twisted is not included in iOS build by default. To use it on iOS,
        put the twisted distribution (and zope.interface dependency) in your
        application directory.
    ```
  函数 uninstall_twisted_reactor()
    ```
    Uninstalls the Kivy's threaded Twisted Reactor. No more Twisted
    tasks will run after this got called. Use this to clean the
    `twisted.internet.reactor` .
    
    .. versionadded:: 1.9.0
    ```
  函数 _gobject_iteration()
  函数 android_check_pause()
  函数 reactor_wake(twisted_loop_next: )
    ```
    Wakeup the twisted reactor to start processing the task queue
            
    ```
  函数 reactor_work()
    ```
    Process the twisted reactor task queue
            
    ```
  函数 reactor_start()
    ```
    Start the twisted reactor main loop
            
    ```
  函数 reactor_stop()
    ```
    Shutdown the twisted reactor main loop
            
    ```
  分析文件: vector.py
  类 Vector:
    ```
    Vector class. See module documentation for more information.
        
    ```
    基类: Name(id='list', ctx=Load())
    函数 __init__(self: )
    函数 _get_x(self: )
    函数 _set_x(self: , x: )
    函数 _get_y(self: )
    函数 _set_y(self: , y: )
    函数 __getslice__(self: , i: , j: )
    函数 __add__(self: , val: )
    函数 __iadd__(self: , val: )
    函数 __neg__(self: )
    函数 __sub__(self: , val: )
    函数 __isub__(self: , val: )
    函数 __mul__(self: , val: )
    函数 __imul__(self: , val: )
    函数 __rmul__(self: , val: )
    函数 __truediv__(self: , val: )
    函数 __div__(self: , val: )
    函数 __rtruediv__(self: , val: )
    函数 __rdiv__(self: , val: )
    函数 __idiv__(self: , val: )
    函数 length(self: )
      ```
      Returns the length of a vector.
      
      >>> Vector(10, 10).length()
      14.142135623730951
      >>> pos = (10, 10)
      >>> Vector(pos).length()
      14.142135623730951
      ```
    函数 length2(self: )
      ```
      Returns the length of a vector squared.
      
      >>> Vector(10, 10).length2()
      200
      >>> pos = (10, 10)
      >>> Vector(pos).length2()
      200
      ```
    函数 distance(self: , to: )
      ```
      Returns the distance between two points.
      
      >>> Vector(10, 10).distance((5, 10))
      5.
      >>> a = (90, 33)
      >>> b = (76, 34)
      >>> Vector(a).distance(b)
      14.035668847618199
      ```
    函数 distance2(self: , to: )
      ```
      Returns the distance between two points squared.
      
      >>> Vector(10, 10).distance2((5, 10))
      25
      ```
    函数 normalize(self: )
      ```
      Returns a new vector that has the same direction as vec,
      but has a length of one.
      
      >>> v = Vector(88, 33).normalize()
      >>> v
      [0.93632917756904444, 0.3511234415883917]
      >>> v.length()
      1.0
      ```
    函数 dot(self: , a: )
      ```
      Computes the dot product of a and b.
      
      >>> Vector(2, 4).dot((2, 2))
      12
      ```
    函数 angle(self: , a: )
      ```
      Computes the angle between a and b, and returns the angle in
      degrees.
      
      >>> Vector(100, 0).angle((0, 100))
      -90.0
      >>> Vector(87, 23).angle((-77, 10))
      -157.7920283010705
      ```
    函数 rotate(self: , angle: )
      ```
      Rotate the vector with an angle in degrees.
      
      >>> v = Vector(100, 0)
      >>> v.rotate(45)
      [70.71067811865476, 70.71067811865474]
      ```
    函数 line_intersection(v1: , v2: , v3: , v4: )
      ```
      Finds the intersection point between the lines (1)v1->v2 and (2)v3->v4
      and returns it as a vector object.
      
      >>> a = (98, 28)
      >>> b = (72, 33)
      >>> c = (10, -5)
      >>> d = (20, 88)
      >>> Vector.line_intersection(a, b, c, d)
      [15.25931928687196, 43.911669367909241]
      
      .. warning::
      
          This is a line intersection method, not a segment intersection.
      
      For math see: http://en.wikipedia.org/wiki/Line-line_intersection
      ```
    函数 segment_intersection(v1: , v2: , v3: , v4: )
      ```
      Finds the intersection point between segments (1)v1->v2 and (2)v3->v4
      and returns it as a vector object.
      
      >>> a = (98, 28)
      >>> b = (72, 33)
      >>> c = (10, -5)
      >>> d = (20, 88)
      >>> Vector.segment_intersection(a, b, c, d)
      None
      
      >>> a = (0, 0)
      >>> b = (10, 10)
      >>> c = (0, 10)
      >>> d = (10, 0)
      >>> Vector.segment_intersection(a, b, c, d)
      [5, 5]
      ```
    函数 in_bbox(point: , a: , b: )
      ```
      Return True if `point` is in the bounding box defined by `a`
      and `b`.
      
      >>> bmin = (0, 0)
      >>> bmax = (100, 100)
      >>> Vector.in_bbox((50, 50), bmin, bmax)
      True
      >>> Vector.in_bbox((647, -10), bmin, bmax)
      False
      ```
  分析文件: event.py
  分析文件: factory_registers.py
  分析文件: context.py
  类 ProxyContext:
    基类: Name(id='object', ctx=Load())
    函数 __init__(self: , obj: )
    函数 __getattribute__(self: , name: )
    函数 __delattr__(self: , name: )
    函数 __setattr__(self: , name: , value: )
    函数 __bool__(self: )
    函数 __str__(self: )
    函数 __repr__(self: )
  类 Context:
    基类: Name(id='dict', ctx=Load())
    函数 push(self: )
    函数 pop(self: )
  函数 register_context(name: , cls: )
    ```
    Register a new context.
        
    ```
  函数 get_current_context()
    ```
    Return the current context.
        
    ```
  eventmanager/
    分析文件: __init__.py
    类 EventManagerBase:
      ```
      Abstract class with methods :meth:`start`, :meth:`stop` and
      :meth:`dispatch` for specific class to implement.
      
      Example of the manager receiving touch and hover events::
      
          class TouchHoverManager(EventManagerBase):
      
              type_ids = ('touch', 'hover')
      
              def start(self):
                  # Create additional resources, bind callbacks to self.window
      
              def dispatch(self, etype, me):
                  if me.type_id == 'touch':
                      # Handle touch event
                  elif me.type_id == 'hover'
                      # Handle hover event
      
              def stop(self):
                  # Release resources
      ```
      基类: Name(id='object', ctx=Load())
      函数 start(self: )
        ```
        Start the manager, bind callbacks to the objects and create
        additional resources. Attribute :attr:`window` is assigned when this
        method is called.
        
        .. versionadded:: 2.1.0
        ```
      函数 dispatch(self: , etype: , me: )
        ```
        Dispatch event `me` to the widgets in the :attr:`window`.
        
        :Parameters:
            `etype`: `str`
                One of "begin", "update" or "end"
            `me`: :class:`~kivy.input.motionevent.MotionEvent`
                The Motion Event currently dispatched.
        :Returns: `bool`
            `True` to stop event dispatching
        
        .. versionadded:: 2.1.0
        ```
      函数 stop(self: )
        ```
        Stop the manager, unbind from any objects and release any allocated
        resources.
        
        .. versionadded:: 2.1.0
        ```
  分析文件: geometry.py
  函数 circumcircle(a: , b: , c: )
    ```
    Computes the circumcircle of a triangle defined by a, b, c.
    See: http://en.wikipedia.org/wiki/Circumscribed_circle
    
    :Parameters:
        `a`: iterable containing at least 2 values (for x and y)
            The 1st point of the triangle.
        `b`: iterable containing at least 2 values (for x and y)
            The 2nd point of the triangle.
        `c`: iterable containing at least 2 values (for x and y)
            The 3rd point of the triangle.
    
    :Return:
        A tuple that defines the circle :
         * The first element in the returned tuple is the center as (x, y)
         * The second is the radius (float)
    ```
  函数 minimum_bounding_circle(points: )
    ```
    Returns the minimum bounding circle for a set of points.
    
    For a description of the problem being solved, see the `Smallest Circle
    Problem <http://en.wikipedia.org/wiki/Smallest_circle_problem>`_.
    
    The function uses Applet's Algorithm, the runtime is ``O(h^3, *n)``,
    where h is the number of points in the convex hull of the set of points.
    **But** it runs in linear time in almost all real world cases.
    See: http://tinyurl.com/6e4n5yb
    
    :Parameters:
        `points`: iterable
            A list of points (2 tuple with x,y coordinates)
    
    :Return:
        A tuple that defines the circle:
            * The first element in the returned tuple is the center (x, y)
            * The second the radius (float)
    ```
  函数 x_axis_angle(q: )
  函数 angle_pq(r: )
  分析文件: utils.py
  函数 boundary(value: , minvalue: , maxvalue: )
    ```
    Limit a value between a minvalue and maxvalue.
    ```
  函数 intersection(set1: , set2: )
    ```
    Return the intersection of 2 lists.
    ```
  函数 difference(set1: , set2: )
    ```
    Return the difference between 2 lists.
    ```
  函数 interpolate(value_from: , value_to: , step: )
    ```
    Interpolate between two values. This can be useful for smoothing some
    transitions. For example::
    
        # instead of setting directly
        self.pos = pos
    
        # use interpolate, and you'll have a nicer transition
        self.pos = interpolate(self.pos, new_pos)
    
    .. warning::
        These interpolations work only on lists/tuples/doubles with the same
        dimensions. No test is done to check the dimensions are the same.
    ```
  函数 strtotuple(s: )
    ```
    Convert a tuple string into a tuple
    with some security checks. Designed to be used
    with the eval() function::
    
        a = (12, 54, 68)
        b = str(a)         # return '(12, 54, 68)'
        c = strtotuple(b)  # return (12, 54, 68)
    ```
  函数 rgba(s: )
    ```
    Return a Kivy color (4 value from 0-1 range) from either a hex string or
    a list of 0-255 values.
    
    .. versionadded:: 1.10.0
    ```
  函数 get_color_from_hex(s: )
    ```
    Transform a hex string color to a kivy
    :class:`~kivy.graphics.Color`.
    ```
  函数 get_hex_from_color(color: )
    ```
    Transform a kivy :class:`~kivy.graphics.Color` to a hex value::
    
        >>> get_hex_from_color((0, 1, 0))
        '#00ff00'
        >>> get_hex_from_color((.25, .77, .90, .5))
        '#3fc4e57f'
    
    .. versionadded:: 1.5.0
    ```
  函数 get_random_color(alpha: )
    ```
    Returns a random color (4 tuple).
    
    :Parameters:
        `alpha`: float, defaults to 1.0
            If alpha == 'random', a random alpha value is generated.
    ```
  函数 is_color_transparent(c: )
    ```
    Return True if the alpha channel is 0.
    ```
  函数 deprecated(func: , msg: )
    ```
    This is a decorator which can be used to mark functions
    as deprecated. It will result in a warning being emitted the first time
    the function is used.
    ```
  类 SafeList:
    ```
    List with a clear() method.
    
    .. warning::
        Usage of the iterate() function will decrease your performance.
    ```
    基类: Name(id='list', ctx=Load())
    函数 __init__(self: )
    函数 clear(self: )
    函数 iterate(self: , reverse: )
  类 QueryDict:
    ```
    QueryDict is a dict() that can be queried with dot.
    
    ::
    
        d = QueryDict()
        # create a key named toto, with the value 1
        d.toto = 1
        # it's the same as
        d['toto'] = 1
    
    .. versionadded:: 1.0.4
    ```
    基类: Name(id='dict', ctx=Load())
    函数 __getattr__(self: , attr: )
    函数 __setattr__(self: , attr: , value: )
  函数 format_bytes_to_human(size: , precision: )
    ```
    Format a byte value to a human readable representation (B, KB, MB...).
    
    .. versionadded:: 1.0.8
    
    :Parameters:
        `size`: int
            Number that represents the bytes value
        `precision`: int, defaults to 2
            Precision after the comma
    
    Examples::
    
        >>> format_bytes_to_human(6463)
        '6.31 KB'
        >>> format_bytes_to_human(646368746541)
        '601.98 GB'
    ```
  函数 _get_platform()
  函数 escape_markup(text: )
    ```
    Escape markup characters found in the text. Intended to be used when markup
    text is activated on the Label::
    
        untrusted_text = escape_markup('Look at the example [1]')
        text = '[color=ff0000]' + untrusted_text + '[/color]'
        w = Label(text=text, markup=True)
    
    .. versionadded:: 1.3.0
    ```
  类 reify:
    ```
    Put the result of a method which uses this (non-data) descriptor decorator
    in the instance dict after the first call, effectively replacing the
    decorator with an instance variable.
    
    It acts like @property, except that the function is only ever called once;
    after that, the value is cached as a regular attribute. This gives you lazy
    attribute creation on objects that are meant to be immutable.
    
    Taken from the `Pyramid project <https://pypi.python.org/pypi/pyramid/>`_.
    
    To use this as a decorator::
    
         @reify
         def lazy(self):
              ...
              return hard_to_compute_int
         first_time = self.lazy   # lazy is reify obj, reify.__get__() runs
         second_time = self.lazy  # lazy is hard_to_compute_int
    ```
    基类: Name(id='object', ctx=Load())
    函数 __get__(self: , inst: , cls: )
  函数 _get_pi_version()
    ```
    Detect the version of the Raspberry Pi by reading the revision field value from '/proc/cpuinfo'
    See: https://www.raspberrypi.org/documentation/hardware/raspberrypi/revision-codes/README.md
    Based on: https://github.com/adafruit/Adafruit_Python_GPIO/blob/master/Adafruit_GPIO/Platform.py
    ```
  函数 new_func()
  分析文件: clock.py
  函数 _get_sleep_obj()
  类 ClockBaseBehavior:
    ```
    The base of the kivy clock.
    
    :parameters:
    
        `async_lib`: string
            The async library to use when the clock is run asynchronously.
            Can be one of, `"asyncio"` when the standard library asyncio
            should be used, or `"trio"` if the trio library should be used.
    
            It defaults to `'asyncio'` or the value in the environmental
            variable `KIVY_EVENTLOOP` if set. :meth:`init_async_lib` can also
            be called directly to set the library.
    ```
    基类: Name(id='object', ctx=Load())
    函数 __init__(self: , async_lib: )
    函数 init_async_lib(self: , lib: )
      ```
      Manually sets the async library to use internally, when running in
      a asynchronous manner.
      
      This can be called anytime before the kivy event loop has started,
      but not once the kivy App is running.
      
      :parameters:
      
          `lib`: string
              The async library to use when the clock is run asynchronously.
              Can be one of, `"asyncio"` when the standard library asyncio
              should be used, or `"trio"` if the trio library should be used.
      ```
    函数 frametime(self: )
      ```
      Time spent between the last frame and the current frame
      (in seconds).
      
      .. versionadded:: 1.8.0
      ```
    函数 frames(self: )
      ```
      Number of internal frames (not necessarily drawn) from the start of
      the clock.
      
      .. versionadded:: 1.8.0
      ```
    函数 frames_displayed(self: )
      ```
      Number of displayed frames from the start of the clock.
              
      ```
    函数 usleep(self: , microseconds: )
      ```
      Sleeps for the number of microseconds.
              
      ```
    函数 idle(self: )
      ```
      (internal) waits here until the next frame.
              
      ```
    函数 _check_ready(self: , fps: , min_sleep: , undershoot: )
    函数 tick(self: )
      ```
      Advance the clock to the next step. Must be called every frame.
      The default clock has a tick() function called by the core Kivy
      framework.
      ```
    函数 pre_idle(self: )
      ```
      Called before :meth:`idle` by :meth:`tick`.
              
      ```
    函数 post_idle(self: , ts: , current: )
      ```
      Called after :meth:`idle` by :meth:`tick`.
              
      ```
    函数 tick_draw(self: )
      ```
      Tick the drawing counter.
              
      ```
    函数 get_fps(self: )
      ```
      Get the current average FPS calculated by the clock.
              
      ```
    函数 get_rfps(self: )
      ```
      Get the current "real" FPS calculated by the clock.
      This counter reflects the real framerate displayed on the screen.
      
      In contrast to get_fps(), this function returns a counter of the
      number of frames, not the average of frames per second.
      ```
    函数 get_time(self: )
      ```
      Get the last tick made by the clock.
      ```
    函数 get_boottime(self: )
      ```
      Get the time in seconds from the application start.
      ```
    函数 handle_exception(self: , e: )
  类 ClockBaseInterruptBehavior:
    ```
    A kivy clock which can be interrupted during a frame to execute events.
        
    ```
    基类: Name(id='ClockBaseBehavior', ctx=Load())
    函数 on_schedule(self: , event: )
  类 ClockBaseInterruptFreeBehavior:
    ```
    A base class for the clock that interrupts the sleep interval for
    free events.
    ```
    基类: Name(id='ClockBaseInterruptBehavior', ctx=Load())
  类 ClockBase:
    ```
    The ``default`` kivy clock. See module for details.
        
    ```
    基类: Name(id='ClockBaseBehavior', ctx=Load())
    基类: Name(id='CyClockBase', ctx=Load())
  类 ClockBaseInterrupt:
    ```
    The ``interrupt`` kivy clock. See module for details.
        
    ```
    基类: Name(id='ClockBaseInterruptBehavior', ctx=Load())
    基类: Name(id='CyClockBase', ctx=Load())
  类 ClockBaseFreeInterruptAll:
    ```
    The ``free_all`` kivy clock. See module for details.
        
    ```
    基类: Name(id='ClockBaseInterruptFreeBehavior', ctx=Load())
    基类: Name(id='CyClockBaseFree', ctx=Load())
  类 ClockBaseFreeInterruptOnly:
    ```
    The ``free_only`` kivy clock. See module for details.
        
    ```
    基类: Name(id='ClockBaseInterruptFreeBehavior', ctx=Load())
    基类: Name(id='CyClockBaseFree', ctx=Load())
  函数 mainthread(func: )
    ```
    Decorator that will schedule the call of the function for the next
    available frame in the mainthread. It can be useful when you use
    :class:`~kivy.network.urlrequest.UrlRequest` or when you do Thread
    programming: you cannot do any OpenGL-related work in a thread.
    
    Please note that this method will return directly and no result can be
    returned::
    
        @mainthread
        def callback(self, *args):
            print('The request succeeded!',
                  'This callback is called in the main thread.')
    
    
        self.req = UrlRequest(url='http://...', on_success=callback)
    
    .. versionadded:: 1.8.0
    ```
  函数 triggered(timeout: , interval: )
    ```
    Decorator that will trigger the call of the function at the specified
    timeout, through the method :meth:`CyClockBase.create_trigger`. Subsequent
    calls to the decorated function (while the timeout is active) are ignored.
    
    It can be helpful when an expensive function (i.e. call to a server) can be
    triggered by different methods. Setting a proper timeout will delay the
    calling and only one of them will be triggered.
    
        @triggered(timeout, interval=False)
        def callback(id):
            print('The callback has been called with id=%d' % id)
    
        >> callback(id=1)
        >> callback(id=2)
        The callback has been called with id=2
    
    The decorated callback can also be unscheduled using:
    
        >> callback.cancel()
    
    .. versionadded:: 1.10.1
    ```
  函数 delayed_func()
  函数 wrapper_triggered(func: )
  函数 _usleep(microseconds: , obj: )
  函数 callback_func(dt: )
  函数 cb_function(dt: )
  函数 trigger_function()
  函数 trigger_cancel()
  函数 _libc_clock_gettime_wrapper()
  类 struct_tv:
    基类: Attribute(value=Name(id='ctypes', ctx=Load()), attr='Structure', ctx=Load())
  函数 _time()
  include/
  lang/
    分析文件: parser.py
    类 ProxyApp:
      基类: Name(id='object', ctx=Load())
      函数 __init__(self: )
      函数 _ensure_app(self: )
      函数 __getattribute__(self: , name: )
      函数 __delattr__(self: , name: )
      函数 __setattr__(self: , name: , value: )
      函数 __bool__(self: )
      函数 __str__(self: )
      函数 __repr__(self: )
    类 ParserException:
      ```
      Exception raised when something wrong happened in a kv file.
          
      ```
      基类: Name(id='Exception', ctx=Load())
    类 ParserRuleProperty:
      ```
      Represent a property inside a rule.
          
      ```
      基类: Name(id='object', ctx=Load())
      函数 precompile(self: )
      函数 get_names_from_expression(cls: , node: )
        ```
        Look for all the symbols used in an ast node.
        ```
    类 ParserRule:
      ```
      Represents a rule, in terms of the Kivy internal language.
          
      ```
      基类: Name(id='object', ctx=Load())
      函数 create_missing(self: , widget: )
      函数 _forbid_selectors(self: )
      函数 _detect_selectors(self: )
      函数 _build_rule(self: )
      函数 _build_template(self: )
    类 Parser:
      ```
      Create a Parser object to parse a Kivy language file or Kivy content.
          
      ```
      基类: Name(id='object', ctx=Load())
      函数 execute_directives(self: )
      函数 parse(self: , content: )
        ```
        Parse the contents of a Parser file and return a list
        of root objects.
        ```
      函数 strip_comments(self: , lines: )
        ```
        Remove all comments from all lines in-place.
        Comments need to be on a single line and not at the end of a line.
        i.e. a comment line's first non-whitespace character must be a #.
        ```
      函数 parse_level(self: , level: , lines: , spaces: )
        ```
        Parse the current level (level * spaces) indentation.
                
        ```
    类 ParserSelector:
      基类: Name(id='object', ctx=Load())
      函数 match(self: , widget: )
    类 ParserSelectorClass:
      基类: Name(id='ParserSelector', ctx=Load())
    类 ParserSelectorName:
      基类: Name(id='ParserSelector', ctx=Load())
      函数 get_bases(self: , cls: )
      函数 match_rule_name(self: , rule_name: )
    分析文件: builder.py
    类 BuilderException:
      ```
      Exception raised when the Builder fails to apply a rule on a widget.
          
      ```
      基类: Name(id='ParserException', ctx=Load())
    函数 get_proxy(widget: )
    函数 custom_callback(__kvlang__: , idmap: )
    函数 call_fn(args: , instance: , v: )
    函数 delayed_call_fn(args: , instance: , v: )
    函数 update_intermediates(base: , keys: , bound: , s: , fn: , args: , instance: , value: )
      ```
      Function that is called when an intermediate property is updated
      and `rebind` of that property is True. In that case, we unbind
      all bound funcs that were bound to attrs of the old value of the
      property and rebind them to the new value of the property.
      
      For example, if the rule is `self.a.b.c.d`, then when b is changed, we
      unbind from `b`, `c` and `d`, if they were bound before (they were not
      None and `rebind` of the respective properties was True) and we rebind
      to the new values of the attrs `b`, `c``, `d` that are not None and
      `rebind` is True.
      
      :Parameters:
          `base`
              A (proxied) ref to the base widget, `self` in the example
              above.
          `keys`
              A list of the name off the attrs of `base` being watched. In
              the example above it'd be `['a', 'b', 'c', 'd']`.
          `bound`
              A list 4-tuples, each tuple being (widget, attr, callback, uid)
              representing callback functions bound to the attributed `attr`
              of `widget`. `uid` is returned by `fbind` when binding.
              The callback may be None, in which case the attr
              was not bound, but is there to be able to walk the attr tree.
              E.g. in the example above, if `b` was not an eventdispatcher,
              `(_b_ref_, `c`, None)` would be added to the list so we can get
              to `c` and `d`, which may be eventdispatchers and their attrs.
          `s`
              The index in `keys` of the of the attr that needs to be
              updated. That is all the keys from `s` and further will be
              rebound, since the `s` key was changed. In bound, the
              corresponding index is `s - 1`. If `s` is None, we start from
              1 (first attr).
          `fn`
              The function to be called args, `args` on bound callback.
      ```
    函数 create_handler(iself: , element: , key: , value: , rule: , idmap: , delayed: )
    类 BuilderBase:
      ```
      The Builder is responsible for creating a :class:`Parser` for parsing a
      kv file, merging the results into its internal rules, templates, etc.
      
      By default, :class:`Builder` is a global Kivy instance used in widgets
      that you can use to load other kv files in addition to the default ones.
      ```
      基类: Name(id='object', ctx=Load())
      函数 __init__(self: )
      函数 create_from(cls: , builder: )
        ```
        Creates a instance of the class, and initializes to the state of
        ``builder``.
        
        :param builder: The builder to initialize from.
        :return: A new instance of this class.
        ```
      函数 load_file(self: , filename: , encoding: )
        ```
        Insert a file into the language builder and return the root widget
        (if defined) of the kv file.
        
        :parameters:
            `rulesonly`: bool, defaults to False
                If True, the Builder will raise an exception if you have a root
                widget inside the definition.
        
            `encoding`: File character encoding. Defaults to utf-8,
        ```
      函数 unload_file(self: , filename: )
        ```
        Unload all rules associated with a previously imported file.
        
        .. versionadded:: 1.0.8
        
        .. warning::
        
            This will not remove rules or templates already applied/used on
            current widgets. It will only effect the next widgets creation or
            template invocation.
        ```
      函数 load_string(self: , string: )
        ```
        Insert a string into the Language Builder and return the root widget
        (if defined) of the kv string.
        
        :Parameters:
            `rulesonly`: bool, defaults to False
                If True, the Builder will raise an exception if you have a root
                widget inside the definition.
            `filename`: str, defaults to None
                If specified, the filename used to index the kv rules.
        
        The filename parameter can be used to unload kv strings in the same way
        as you unload kv files. This can be achieved using pseudo file names
        e.g.::
        
            Build.load_string("""
                <MyRule>:
                    Label:
                        text="Hello"
            """, filename="myrule.kv")
        
        can be unloaded via::
        
            Build.unload_file("myrule.kv")
        ```
      函数 template(self: )
        ```
        Create a specialized template using a specific context.
        
        .. versionadded:: 1.0.5
        
        With templates, you can construct custom widgets from a kv lang
        definition by giving them a context. Check :ref:`Template usage
        <template_usage>`.
        ```
      函数 apply_rules(self: , widget: , rule_name: , ignored_consts: , rule_children: , dispatch_kv_post: )
        ```
        Search all the rules that match the name `rule_name`
        and apply them to `widget`.
        
        .. versionadded:: 1.10.0
        
        :Parameters:
        
            `widget`: :class:`~kivy.uix.widget.Widget`
                The widget to whom the matching rules should be applied to.
            `ignored_consts`: set
                A set or list type whose elements are property names for which
                constant KV rules (i.e. those that don't create bindings) of
                that widget will not be applied. This allows e.g. skipping
                constant rules that overwrite a value initialized in python.
            `rule_children`: list
                If not ``None``, it should be a list that will be populated
                with all the widgets created by the kv rules being applied.
        
                .. versionchanged:: 1.11.0
        
            `dispatch_kv_post`: bool
                Normally the class `Widget` dispatches the `on_kv_post` event
                to widgets created during kv rule application.
                But if the rules are manually applied by calling :meth:`apply`,
                that may not happen, so if this is `True`, we will dispatch the
                `on_kv_post` event where needed after applying the rules to
                `widget` (we won't dispatch it for `widget` itself).
        
                Defaults to False.
        
                .. versionchanged:: 1.11.0
        ```
      函数 apply(self: , widget: , ignored_consts: , rule_children: , dispatch_kv_post: )
        ```
        Search all the rules that match the widget and apply them.
        
        :Parameters:
        
            `widget`: :class:`~kivy.uix.widget.Widget`
                The widget whose class rules should be applied to this widget.
            `ignored_consts`: set
                A set or list type whose elements are property names for which
                constant KV rules (i.e. those that don't create bindings) of
                that widget will not be applied. This allows e.g. skipping
                constant rules that overwrite a value initialized in python.
            `rule_children`: list
                If not ``None``, it should be a list that will be populated
                with all the widgets created by the kv rules being applied.
        
                .. versionchanged:: 1.11.0
        
            `dispatch_kv_post`: bool
                Normally the class `Widget` dispatches the `on_kv_post` event
                to widgets created during kv rule application.
                But if the rules are manually applied by calling :meth:`apply`,
                that may not happen, so if this is `True`, we will dispatch the
                `on_kv_post` event where needed after applying the rules to
                `widget` (we won't dispatch it for `widget` itself).
        
                Defaults to False.
        
                .. versionchanged:: 1.11.0
        ```
      函数 _clear_matchcache(self: )
      函数 _apply_rule(self: , widget: , rule: , rootrule: , template_ctx: , ignored_consts: , rule_children: )
      函数 match(self: , widget: )
        ```
        Return a list of :class:`ParserRule` objects matching the widget.
                
        ```
      函数 match_rule_name(self: , rule_name: )
        ```
        Return a list of :class:`ParserRule` objects matching the widget.
                
        ```
      函数 sync(self: )
        ```
        Execute all the waiting operations, such as the execution of all the
        expressions related to the canvas.
        
        .. versionadded:: 1.7.0
        ```
      函数 unbind_widget(self: , uid: )
        ```
        Unbind all the handlers created by the KV rules of the
        widget. The :attr:`kivy.uix.widget.Widget.uid` is passed here
        instead of the widget itself, because Builder is using it in the
        widget destructor.
        
        This effectively clears all the KV rules associated with this widget.
        For example:
        
        .. code-block:: python
        
            >>> w = Builder.load_string('''
            ... Widget:
            ...     height: self.width / 2. if self.disabled else self.width
            ...     x: self.y + 50
            ... ''')
            >>> w.size
            [100, 100]
            >>> w.pos
            [50, 0]
            >>> w.width = 500
            >>> w.size
            [500, 500]
            >>> Builder.unbind_widget(w.uid)
            >>> w.width = 222
            >>> w.y = 500
            >>> w.size
            [222, 500]
            >>> w.pos
            [50, 500]
        
        .. versionadded:: 1.7.2
        ```
      函数 unbind_property(self: , widget: , name: )
        ```
        Unbind the handlers created by all the rules of the widget that set
        the name.
        
        This effectively clears all the rules of widget that take the form::
        
            name: rule
        
        For example:
        
        .. code-block:: python
        
            >>> w = Builder.load_string('''
            ... Widget:
            ...     height: self.width / 2. if self.disabled else self.width
            ...     x: self.y + 50
            ... ''')
            >>> w.size
            [100, 100]
            >>> w.pos
            [50, 0]
            >>> w.width = 500
            >>> w.size
            [500, 500]
            >>> Builder.unbind_property(w, 'height')
            >>> w.width = 222
            >>> w.size
            [222, 500]
            >>> w.y = 500
            >>> w.pos
            [550, 500]
        
        .. versionadded:: 1.9.1
        ```
      函数 _build_canvas(self: , canvas: , widget: , rule: , rootrule: )
    函数 match_rule(fn: , index: , rule: )
    函数 dump_builder_stats()
    分析文件: __init__.py
  storage/
    分析文件: redisstore.py
    类 RedisStore:
      ```
      Store implementation using a Redis database.
      See the :mod:`kivy.storage` module documentation for more information.
      ```
      基类: Name(id='AbstractStore', ctx=Load())
      函数 __init__(self: , redis_params: )
      函数 store_load(self: )
      函数 store_sync(self: )
      函数 store_exists(self: , key: )
      函数 store_get(self: , key: )
      函数 store_put(self: , key: , values: )
      函数 store_delete(self: , key: )
      函数 store_keys(self: )
      函数 store_find(self: , filters: )
    分析文件: dictstore.py
    类 DictStore:
      ```
      Store implementation using a pickled `dict`.
      See the :mod:`kivy.storage` module documentation for more information.
      ```
      基类: Name(id='AbstractStore', ctx=Load())
      函数 __init__(self: , filename: , data: )
      函数 store_load(self: )
      函数 store_sync(self: )
      函数 store_exists(self: , key: )
      函数 store_get(self: , key: )
      函数 store_put(self: , key: , value: )
      函数 store_delete(self: , key: )
      函数 store_find(self: , filters: )
      函数 store_count(self: )
      函数 store_keys(self: )
    分析文件: jsonstore.py
    类 JsonStore:
      ```
      Store implementation using a json file for storing the key-value pairs.
      See the :mod:`kivy.storage` module documentation for more information.
      ```
      基类: Name(id='AbstractStore', ctx=Load())
      函数 __init__(self: , filename: , indent: , sort_keys: )
      函数 store_load(self: )
      函数 store_sync(self: )
      函数 store_exists(self: , key: )
      函数 store_get(self: , key: )
      函数 store_put(self: , key: , value: )
      函数 store_delete(self: , key: )
      函数 store_find(self: , filters: )
      函数 store_count(self: )
      函数 store_keys(self: )
    分析文件: __init__.py
    类 AbstractStore:
      ```
      Abstract class used to implement a Store
          
      ```
      基类: Name(id='EventDispatcher', ctx=Load())
      函数 __init__(self: )
      函数 exists(self: , key: )
        ```
        Check if a key exists in the store.
                
        ```
      函数 async_exists(self: , callback: , key: )
        ```
        Asynchronous version of :meth:`exists`.
        
        :Callback arguments:
            `store`: :class:`AbstractStore` instance
                Store instance
            `key`: string
                Name of the key to search for
            `result`: boo
                Result of the query, None if any error
        ```
      函数 get(self: , key: )
        ```
        Get the key-value pairs stored at `key`. If the key is not found, a
        `KeyError` exception will be thrown.
        ```
      函数 async_get(self: , callback: , key: )
        ```
        Asynchronous version of :meth:`get`.
        
        :Callback arguments:
            `store`: :class:`AbstractStore` instance
                Store instance
            `key`: string
                Name of the key to search for
            `result`: dict
                Result of the query, None if any error
        ```
      函数 put(self: , key: )
        ```
        Put new key-value pairs (given in *values*) into the storage. Any
        existing key-value pairs will be removed.
        ```
      函数 async_put(self: , callback: , key: )
        ```
        Asynchronous version of :meth:`put`.
        
        :Callback arguments:
            `store`: :class:`AbstractStore` instance
                Store instance
            `key`: string
                Name of the key to search for
            `result`: bool
                Indicate True if the storage has been updated, or False if
                nothing has been done (no changes). None if any error.
        ```
      函数 delete(self: , key: )
        ```
        Delete a key from the storage. If the key is not found, a `KeyError`
        exception will be thrown.
        ```
      函数 async_delete(self: , callback: , key: )
        ```
        Asynchronous version of :meth:`delete`.
        
        :Callback arguments:
            `store`: :class:`AbstractStore` instance
                Store instance
            `key`: string
                Name of the key to search for
            `result`: bool
                Indicate True if the storage has been updated, or False if
                nothing has been done (no changes). None if any error.
        ```
      函数 find(self: )
        ```
        Return all the entries matching the filters. The entries are
        returned through a generator as a list of (key, entry) pairs
        where *entry* is a dict of key-value pairs ::
        
            for key, entry in store.find(name='Mathieu'):
                print('key:', key, ', entry:', entry)
        
        Because it's a generator, you cannot directly use it as a list. You can
        do::
        
            # get all the (key, entry) availables
            entries = list(store.find(name='Mathieu'))
            # get only the entry from (key, entry)
            entries = list((x[1] for x in store.find(name='Mathieu')))
        ```
      函数 async_find(self: , callback: )
        ```
        Asynchronous version of :meth:`find`.
        
        The callback will be called for each entry in the result.
        
        :Callback arguments:
            `store`: :class:`AbstractStore` instance
                Store instance
            `key`: string
                Name of the key to search for, or None if we reach the end of
                the results
            `result`: bool
                Indicate True if the storage has been updated, or False if
                nothing has been done (no changes). None if any error.
        ```
      函数 keys(self: )
        ```
        Return a list of all the keys in the storage.
                
        ```
      函数 async_keys(self: , callback: )
        ```
        Asynchronously return all the keys in the storage.
                
        ```
      函数 count(self: )
        ```
        Return the number of entries in the storage.
                
        ```
      函数 async_count(self: , callback: )
        ```
        Asynchronously return the number of entries in the storage.
                
        ```
      函数 clear(self: )
        ```
        Wipe the whole storage.
                
        ```
      函数 async_clear(self: , callback: )
        ```
        Asynchronous version of :meth:`clear`.
                
        ```
      函数 __setitem__(self: , key: , values: )
      函数 __getitem__(self: , key: )
      函数 __delitem__(self: , key: )
      函数 __contains__(self: , key: )
      函数 __len__(self: )
      函数 __iter__(self: )
      函数 store_load(self: )
      函数 store_sync(self: )
      函数 store_get(self: , key: )
      函数 store_put(self: , key: , value: )
      函数 store_exists(self: , key: )
      函数 store_delete(self: , key: )
      函数 store_find(self: , filters: )
      函数 store_keys(self: )
      函数 store_count(self: )
      函数 store_clear(self: )
      函数 store_get_async(self: , key: , callback: )
      函数 store_put_async(self: , key: , value: , callback: )
      函数 store_exists_async(self: , key: , callback: )
      函数 store_delete_async(self: , key: , callback: )
      函数 store_find_async(self: , filters: , callback: )
      函数 store_count_async(self: , callback: )
      函数 store_keys_async(self: , callback: )
      函数 store_clear_async(self: , callback: )
      函数 _schedule(self: , cb: )
  modules/
    分析文件: console.py
    函数 ignore_exception(f: )
    类 TreeViewProperty:
      基类: Name(id='BoxLayout', ctx=Load())
      基类: Name(id='TreeViewNode', ctx=Load())
      函数 _get_widget(self: )
    类 ConsoleButton:
      ```
      Button specialized for the Console
      ```
      基类: Name(id='Button', ctx=Load())
    类 ConsoleToggleButton:
      ```
      ToggleButton specialized for the Console
      ```
      基类: Name(id='ToggleButton', ctx=Load())
    类 ConsoleLabel:
      ```
      LabelButton specialized for the Console
      ```
      基类: Name(id='Label', ctx=Load())
    类 ConsoleAddonSeparator:
      基类: Name(id='Widget', ctx=Load())
    类 ConsoleAddon:
      ```
      Base class for implementing addons
      ```
      基类: Name(id='object', ctx=Load())
      函数 __init__(self: , console: )
      函数 init(self: )
        ```
        Method called when the addon is instantiated by the Console
                
        ```
      函数 activate(self: )
        ```
        Method called when the addon is activated by the console
        (when the console is displayed)
        ```
      函数 deactivate(self: )
        ```
        Method called when the addon is deactivated by the console
        (when the console is hidden)
        ```
    类 ConsoleAddonMode:
      基类: Name(id='ConsoleAddon', ctx=Load())
    类 ConsoleAddonSelect:
      基类: Name(id='ConsoleAddon', ctx=Load())
      函数 on_inspect_enabled(self: , instance: , value: )
      函数 on_button_state(self: , instance: , value: )
    类 ConsoleAddonFps:
      基类: Name(id='ConsoleAddon', ctx=Load())
      函数 deactivated(self: )
      函数 update_fps(self: )
    类 ConsoleAddonBreadcrumbView:
      基类: Name(id='RelativeLayout', ctx=Load())
      函数 on_widget(self: , instance: , value: )
      函数 highlight_widget(self: , instance: )
    类 ConsoleAddonBreadcrumb:
      基类: Name(id='ConsoleAddon', ctx=Load())
      函数 update_content(self: )
    类 ConsoleAddonWidgetPanel:
      基类: Name(id='ConsoleAddon', ctx=Load())
      函数 panel_activate(self: )
      函数 show_property(self: , instance: , value: , key: , index: )
      函数 save_property_numeric(self: , widget: , key: , index: , instance: , value: )
      函数 save_property_text(self: , widget: , key: , index: , instance: , value: )
      函数 save_property_boolean(self: , widget: , key: , index: , instance: )
      函数 save_property_option(self: , widget: , key: , instance: )
    类 TreeViewWidget:
      基类: Name(id='Label', ctx=Load())
      基类: Name(id='TreeViewNode', ctx=Load())
    类 ConsoleAddonWidgetTreeImpl:
      基类: Name(id='TreeView', ctx=Load())
      函数 find_node_by_widget(self: , widget: )
      函数 update_selected_widget(self: , widget: )
      函数 on_selected_widget(self: , inst: , widget: )
      函数 select_node(self: , node: , select_widget: )
      函数 on_select_widget(self: , widget: )
      函数 _update_scroll(self: )
    类 ConsoleAddonWidgetTreeView:
      基类: Name(id='RelativeLayout', ctx=Load())
      函数 _update_widget_tree_node(self: , node: , widget: , is_open: )
      函数 update_widget_tree(self: )
    类 ConsoleAddonWidgetTree:
      基类: Name(id='ConsoleAddon', ctx=Load())
      函数 panel_refresh(self: )
    类 Console:
      ```
      Console interface
      
      This widget is created by create_console(), when the module is loaded.
      During that time, you can add addons on the console to extend the
      functionalities, or add your own application stats / debugging module.
      ```
      基类: Name(id='RelativeLayout', ctx=Load())
      函数 _init_toolbar(self: )
      函数 register_addon(cls: , addon: )
      函数 add_toolbar_widget(self: , widget: , right: )
        ```
        Add a widget in the top left toolbar of the Console.
        Use `right=True` if you wanna add the widget at the right instead.
        ```
      函数 remove_toolbar_widget(self: , widget: )
        ```
        Remove a widget from the toolbar
                
        ```
      函数 add_panel(self: , name: , cb_activate: , cb_deactivate: , cb_refresh: )
        ```
        Add a new panel in the Console.
        
        - `cb_activate` is a callable that will be called when the panel is
          activated by the user.
        
        - `cb_deactivate` is a callable that will be called when the panel is
          deactivated or when the console will hide.
        
        - `cb_refresh` is an optional callable that is called if the user
          click again on the button for display the panel
        
        When activated, it's up to the panel to display a content in the
        Console by using :meth:`set_content`.
        ```
      函数 _activate_panel(self: , instance: )
      函数 set_content(self: , content: )
        ```
        Replace the Console content with a new one.
                
        ```
      函数 on_touch_down(self: , touch: )
      函数 on_touch_move(self: , touch: )
      函数 on_touch_up(self: , touch: )
      函数 on_window_children(self: , win: , children: )
      函数 highlight_at(self: , x: , y: )
        ```
        Select a widget from a x/y window coordinate.
        This is mostly used internally when Select mode is activated
        ```
      函数 update_widget_graphics(self: )
      函数 pick(self: , widget: , x: , y: )
        ```
        Pick a widget at x/y, given a root `widget`
                
        ```
      函数 on_activated(self: , instance: , activated: )
      函数 _activate_console(self: )
      函数 _deactivate_console(self: )
      函数 keyboard_shortcut(self: , win: , scancode: )
    函数 create_console(win: , ctx: )
    函数 start(win: , ctx: )
      ```
      Create an Console instance attached to the *ctx* and bound to the
      Window's :meth:`~kivy.core.window.WindowBase.on_keyboard` event for
      capturing the keyboard shortcut.
      
          :Parameters:
              `win`: A :class:`Window <kivy.core.window.WindowBase>`
                  The application Window to bind to.
              `ctx`: A :class:`~kivy.uix.widget.Widget` or subclass
                  The Widget to be inspected.
      ```
    函数 stop(win: , ctx: )
      ```
      Stop and unload any active Inspectors for the given *ctx*.
      ```
    函数 f2()
    分析文件: screen.py
    函数 start(win: , ctx: )
    函数 stop(win: , ctx: )
    函数 apply_device(device: , scale: , orientation: )
    函数 usage(device: )
    函数 configure(ctx: )
    分析文件: keybinding.py
    函数 _on_keyboard_handler(instance: , key: , scancode: , codepoint: , modifiers: )
    函数 start(win: , ctx: )
    函数 stop(win: , ctx: )
    分析文件: cursor.py
    函数 _mouse_move(texture: , size: , offset: , win: , pos: )
    函数 start(win: , ctx: )
    函数 stop(win: , ctx: )
    分析文件: joycursor.py
    类 JoyCursor:
      基类: Name(id='Widget', ctx=Load())
      函数 __init__(self: )
      函数 on_window_children(self: , win: )
      函数 on_activated(self: , instance: , activated: )
      函数 set_cursor(self: )
      函数 check_cursor(self: , win: , stickid: , axisid: , value: )
      函数 set_intensity(self: , win: , stickid: , buttonid: )
      函数 check_dispatch(self: , win: , stickid: , buttonid: )
      函数 move_cursor(self: )
      函数 stop_cursor(self: , instance: , mouse_pos: )
      函数 on_pos(self: , instance: , new_pos: )
      函数 keyboard_shortcuts(self: , win: , scancode: )
      函数 joystick_shortcuts(self: , win: , stickid: , buttonid: )
    函数 create_joycursor(win: , ctx: )
      ```
      Create a JoyCursor instance attached to the *ctx* and bound to the
      Window's :meth:`~kivy.core.window.WindowBase.on_keyboard` event for
      capturing the keyboard shortcuts.
      
          :Parameters:
              `win`: A :class:`Window <kivy.core.window.WindowBase>`
                  The application Window to bind to.
              `ctx`: A :class:`~kivy.uix.widget.Widget` or subclass
                  The Widget for JoyCursor to attach to.
      ```
    函数 start(win: , ctx: )
    函数 stop(win: , ctx: )
      ```
      Stop and unload any active JoyCursors for the given *ctx*.
          
      ```
    分析文件: webdebugger.py
    分析文件: inspector.py
    类 TreeViewProperty:
      基类: Attribute(value=Name(id='Factory', ctx=Load()), attr='BoxLayout', ctx=Load())
      基类: Attribute(value=Name(id='Factory', ctx=Load()), attr='TreeViewNode', ctx=Load())
      函数 _get_widget(self: )
    类 TreeViewWidget:
      基类: Attribute(value=Name(id='Factory', ctx=Load()), attr='Label', ctx=Load())
      基类: Attribute(value=Name(id='Factory', ctx=Load()), attr='TreeViewNode', ctx=Load())
    类 WidgetTree:
      基类: Attribute(value=Name(id='Factory', ctx=Load()), attr='TreeView', ctx=Load())
      函数 __init__(self: )
      函数 find_node_by_widget(self: , widget: )
      函数 update_selected_widget(self: , widget: )
      函数 on_selected_widget(self: , inst: , widget: )
      函数 select_node(self: , node: , select_widget: )
      函数 on_select_widget(self: , widget: )
      函数 _update_scroll(self: )
    类 Inspector:
      基类: Attribute(value=Name(id='Factory', ctx=Load()), attr='FloatLayout', ctx=Load())
      函数 on_touch_down(self: , touch: )
      函数 on_touch_move(self: , touch: )
      函数 on_touch_up(self: , touch: )
      函数 on_window_children(self: , win: , children: )
      函数 highlight_at(self: , x: , y: )
      函数 highlight_widget(self: , widget: , info: )
      函数 update_widget_graphics(self: )
      函数 toggle_position(self: , button: )
      函数 pick(self: , widget: , x: , y: )
      函数 on_activated(self: , instance: , activated: )
      函数 animation_close(self: , instance: , value: )
      函数 show_widget_info(self: )
      函数 update_node_content(self: , node: )
      函数 keyboard_shortcut(self: , win: , scancode: )
      函数 show_property(self: , instance: , value: , key: , index: )
      函数 save_property_numeric(self: , widget: , key: , index: , instance: , value: )
      函数 save_property_text(self: , widget: , key: , index: , instance: , value: )
      函数 save_property_boolean(self: , widget: , key: , index: , instance: )
      函数 save_property_option(self: , widget: , key: , instance: )
      函数 _update_widget_tree_node(self: , node: , widget: , is_open: )
      函数 update_widget_tree(self: )
    函数 create_inspector(win: , ctx: )
      ```
      Create an Inspector instance attached to the *ctx* and bound to the
      Window's :meth:`~kivy.core.window.WindowBase.on_keyboard` event for
      capturing the keyboard shortcut.
      
          :Parameters:
              `win`: A :class:`Window <kivy.core.window.WindowBase>`
                  The application Window to bind to.
              `ctx`: A :class:`~kivy.uix.widget.Widget` or subclass
                  The Widget to be inspected.
      ```
    函数 start(win: , ctx: )
    函数 stop(win: , ctx: )
      ```
      Stop and unload any active Inspectors for the given *ctx*.
      ```
    分析文件: recorder.py
    函数 replay(recorder: )
    函数 on_recorder_key(recorder: , window: , key: )
    函数 start(win: , ctx: )
    函数 stop(win: , ctx: )
    分析文件: monitor.py
    函数 update_fps(ctx: )
    函数 update_stats(win: , ctx: )
    函数 _update_monitor_canvas(win: , ctx: )
    类 StatsInput:
      基类: Name(id='object', ctx=Load())
      函数 process(self: , events: )
    函数 start(win: , ctx: )
    函数 stop(win: , ctx: )
    分析文件: _webdebugger.py
    类 MissingOrderedDict:
      基类: Name(id='OrderedDict', ctx=Load())
      函数 __missing__(self: , key: )
    函数 index()
    函数 metrics_json()
    函数 getfile(name: )
    类 FlaskThread:
      基类: Attribute(value=Name(id='threading', ctx=Load()), attr='Thread', ctx=Load())
      函数 run(self: )
      函数 dump_metrics(self: , dt: )
    函数 start(win: , ctx: )
    函数 stop(win: , ctx: )
    分析文件: showborder.py
    函数 start(win: , ctx: )
    函数 stop(win: , ctx: )
    分析文件: touchring.py
    函数 _touch_down(win: , touch: )
    函数 _touch_move(win: , touch: )
    函数 _touch_up(win: , touch: )
    函数 start(win: , ctx: )
    函数 stop(win: , ctx: )
    分析文件: __init__.py
    类 ModuleContext:
      ```
      Context of a module
      
      You can access to the config with self.config.
      ```
      函数 __init__(self: )
      函数 __repr__(self: )
    类 ModuleBase:
      ```
      Handle Kivy modules. It will automatically load and instantiate the
      module for the general window.
      ```
      函数 add_path(self: , path: )
        ```
        Add a path to search for modules in
        ```
      函数 list(self: )
        ```
        Return the list of available modules
        ```
      函数 import_module(self: , name: )
      函数 activate_module(self: , name: , win: )
        ```
        Activate a module on a window
        ```
      函数 deactivate_module(self: , name: , win: )
        ```
        Deactivate a module from a window
        ```
      函数 register_window(self: , win: )
        ```
        Add the window to the window list
        ```
      函数 unregister_window(self: , win: )
        ```
        Remove the window from the window list
        ```
      函数 update(self: )
        ```
        Update the status of the module for each window
        ```
      函数 configure(self: )
        ```
        (internal) Configure all the modules before using them.
                
        ```
      函数 _configure_module(self: , name: )
      函数 usage_list(self: )
  分析文件: setupconfig.py
  分析文件: base.py
  类 ExceptionHandler:
    ```
    Base handler that catches exceptions in :func:`runTouchApp`.
    You can subclass and extend it as follows::
    
        class E(ExceptionHandler):
            def handle_exception(self, inst):
                Logger.exception('Exception caught by ExceptionHandler')
                return ExceptionManager.PASS
    
        ExceptionManager.add_handler(E())
    
    Then, all exceptions will be set to PASS, and logged to the console!
    ```
    基类: Name(id='object', ctx=Load())
    函数 handle_exception(self: , exception: )
      ```
      Called by :class:`ExceptionManagerBase` to handle a exception.
      
      Defaults to returning :attr:`ExceptionManager.RAISE` that re-raises the
      exception. Return :attr:`ExceptionManager.PASS` to indicate that the
      exception was handled and should be ignored.
      
      This may be called multiple times with the same exception, if
      :attr:`ExceptionManager.RAISE` is returned as the exception bubbles
      through multiple kivy exception handling levels.
      ```
  类 ExceptionManagerBase:
    ```
    ExceptionManager manages exceptions handlers.
    ```
    函数 __init__(self: )
    函数 add_handler(self: , cls: )
      ```
      Add a new exception handler to the stack.
      ```
    函数 remove_handler(self: , cls: )
      ```
      Remove the exception handler from the stack.
      ```
  类 EventLoopBase:
    ```
    Main event loop. This loop handles the updating of input and
    dispatching events.
    ```
    基类: Name(id='EventDispatcher', ctx=Load())
    函数 touches(self: )
      ```
      Return the list of all touches currently in down or move states.
              
      ```
    函数 ensure_window(self: )
      ```
      Ensure that we have a window.
              
      ```
    函数 set_window(self: , window: )
      ```
      Set the window used for the event loop.
              
      ```
    函数 add_input_provider(self: , provider: , auto_remove: )
      ```
      Add a new input provider to listen for touch events.
              
      ```
    函数 remove_input_provider(self: , provider: )
      ```
      Remove an input provider.
      
      .. versionchanged:: 2.1.0
          Provider will be also removed if it exist in auto-remove list.
      ```
    函数 add_event_listener(self: , listener: )
      ```
      Add a new event listener for getting touch events.
              
      ```
    函数 remove_event_listener(self: , listener: )
      ```
      Remove an event listener from the list.
              
      ```
    函数 start(self: )
      ```
      Must be called before :meth:`EventLoopBase.run()`. This starts all
      configured input providers.
      
      .. versionchanged:: 2.1.0
          Method can be called multiple times, but event loop will start only
          once.
      ```
    函数 close(self: )
      ```
      Exit from the main loop and stop all configured
      input providers.
      ```
    函数 stop(self: )
      ```
      Stop all input providers and call callbacks registered using
      `EventLoop.add_stop_callback()`.
      
      .. versionchanged:: 2.1.0
          Method can be called multiple times, but event loop will stop only
          once.
      ```
    函数 add_postproc_module(self: , mod: )
      ```
      Add a postproc input module (DoubleTap, TripleTap, DeJitter
      RetainTouch are defaults).
      ```
    函数 remove_postproc_module(self: , mod: )
      ```
      Remove a postproc module.
      ```
    函数 remove_android_splash(self: )
      ```
      Remove android presplash in SDL2 bootstrap.
      ```
    函数 post_dispatch_input(self: , etype: , me: )
      ```
      This function is called by :meth:`EventLoopBase.dispatch_input()`
      when we want to dispatch an input event. The event is dispatched to
      all listeners and if grabbed, it's dispatched to grabbed widgets.
      ```
    函数 _dispatch_input(self: )
    函数 dispatch_input(self: )
      ```
      Called by :meth:`EventLoopBase.idle()` to read events from input
      providers, pass events to postproc, and dispatch final events.
      ```
    函数 mainloop(self: )
    函数 idle(self: )
      ```
      This function is called after every frame. By default:
      
      * it "ticks" the clock to the next frame.
      * it reads all input and dispatches events.
      * it dispatches `on_update`, `on_draw` and `on_flip` events to the
        window.
      ```
    函数 run(self: )
      ```
      Main loop
      ```
    函数 exit(self: )
      ```
      Close the main loop and close the window.
      ```
    函数 on_stop(self: )
      ```
      Event handler for `on_stop` events which will be fired right
      after all input providers have been stopped.
      ```
    函数 on_pause(self: )
      ```
      Event handler for `on_pause` which will be fired when
      the event loop is paused.
      ```
    函数 on_start(self: )
      ```
      Event handler for `on_start` which will be fired right
      after all input providers have been started.
      ```
  函数 _runTouchApp_prepare(widget: )
  函数 runTouchApp(widget: , embedded: )
    ```
    Static main function that starts the application loop.
    You can access some magic via the following arguments:
    
    See :mod:`kivy.app` for example usage.
    
    :Parameters:
        `<empty>`
            To make dispatching work, you need at least one
            input listener. If not, application will leave.
            (MTWindow act as an input listener)
    
        `widget`
            If you pass only a widget, a MTWindow will be created
            and your widget will be added to the window as the root
            widget.
    
        `embedded`
            No event dispatching is done. This will be your job.
    
        `widget + embedded`
            No event dispatching is done. This will be your job but
            we try to get the window (must be created by you beforehand)
            and add the widget to it. Very useful for embedding Kivy
            in another toolkit. (like Qt, check kivy-designed)
    ```
  函数 stopTouchApp()
    ```
    Stop the current application by leaving the main loop.
    
    See :mod:`kivy.app` for example usage.
    ```
  分析文件: weakmethod.py
  类 WeakMethod:
    ```
    Implementation of a
    `weakref <http://en.wikipedia.org/wiki/Weak_reference>`_
    for functions and bound methods.
    ```
    函数 __init__(self: , method: )
    函数 __call__(self: )
      ```
      Return a new bound-method like the original, or the
      original function if it was just a function or unbound
      method.
      Returns None if the original object doesn't exist.
      ```
    函数 is_dead(self: )
      ```
      Returns True if the referenced callable was a bound method and
      the instance no longer exists. Otherwise, return False.
      ```
    函数 __eq__(self: , other: )
    函数 __repr__(self: )
  分析文件: cache.py
  类 Cache:
    ```
    See module documentation for more information.
        
    ```
    基类: Name(id='object', ctx=Load())
    函数 register(category: , limit: , timeout: )
      ```
      Register a new category in the cache with the specified limit.
      
      :Parameters:
          `category`: str
              Identifier of the category.
          `limit`: int (optional)
              Maximum number of objects allowed in the cache.
              If None, no limit is applied.
          `timeout`: double (optional)
              Time after which to delete the object if it has not been used.
              If None, no timeout is applied.
      ```
    函数 append(category: , key: , obj: , timeout: )
      ```
      Add a new object to the cache.
      
      :Parameters:
          `category`: str
              Identifier of the category.
          `key`: str
              Unique identifier of the object to store.
          `obj`: object
              Object to store in cache.
          `timeout`: double (optional)
              Time after which to delete the object if it has not been used.
              If None, no timeout is applied.
      
      :raises:
          `ValueError`: If `None` is used as `key`.
      
      .. versionchanged:: 2.0.0
          Raises `ValueError` if `None` is used as `key`.
      ```
    函数 get(category: , key: , default: )
      ```
      Get a object from the cache.
      
      :Parameters:
          `category`: str
              Identifier of the category.
          `key`: str
              Unique identifier of the object in the store.
          `default`: anything, defaults to None
              Default value to be returned if the key is not found.
      ```
    函数 get_timestamp(category: , key: , default: )
      ```
      Get the object timestamp in the cache.
      
      :Parameters:
          `category`: str
              Identifier of the category.
          `key`: str
              Unique identifier of the object in the store.
          `default`: anything, defaults to None
              Default value to be returned if the key is not found.
      ```
    函数 get_lastaccess(category: , key: , default: )
      ```
      Get the objects last access time in the cache.
      
      :Parameters:
          `category`: str
              Identifier of the category.
          `key`: str
              Unique identifier of the object in the store.
          `default`: anything, defaults to None
              Default value to be returned if the key is not found.
      ```
    函数 remove(category: , key: )
      ```
      Purge the cache.
      
      :Parameters:
          `category`: str
              Identifier of the category.
          `key`: str (optional)
              Unique identifier of the object in the store. If this
              argument is not supplied, the entire category will be purged.
      ```
    函数 _purge_oldest(category: , maxpurge: )
    函数 _purge_by_timeout(dt: )
    函数 print_usage()
      ```
      Print the cache usage to the console.
      ```
  network/
    分析文件: urlrequest.py
    类 UrlRequestBase:
      ```
      A UrlRequest. See module documentation for usage.
      
      .. versionchanged:: 1.5.1
          Add `debug` parameter
      
      .. versionchanged:: 1.0.10
          Add `method` parameter
      
      .. versionchanged:: 1.8.0
      
          Parameter `decode` added.
          Parameter `file_path` added.
          Parameter `on_redirect` added.
          Parameter `on_failure` added.
      
      .. versionchanged:: 1.9.1
      
          Parameter `ca_file` added.
          Parameter `verify` added.
      
      .. versionchanged:: 1.10.0
      
          Parameters `proxy_host`, `proxy_port` and `proxy_headers` added.
      
      .. versionchanged:: 1.11.0
      
          Parameters `on_cancel` added.
      
      .. versionchanged:: 2.2.0
      
          Parameters `on_finish` added.
          Parameters `auth` added.
      
      :Parameters:
          `url`: str
              Complete url string to call.
          `on_success`: callback(request, result)
              Callback function to call when the result has been fetched.
          `on_redirect`: callback(request, result)
              Callback function to call if the server returns a Redirect.
          `on_failure`: callback(request, result)
              Callback function to call if the server returns a Client or
              Server Error.
          `on_error`: callback(request, error)
              Callback function to call if an error occurs.
          `on_progress`: callback(request, current_size, total_size)
              Callback function that will be called to report progression of the
              download. `total_size` might be -1 if no Content-Length has been
              reported in the http response.
              This callback will be called after each `chunk_size` is read.
          `on_cancel`: callback(request)
              Callback function to call if user requested to cancel the download
              operation via the .cancel() method.
          `on_finish`: callback(request)
              Additional callback function to call if request is done.
          `req_body`: str, defaults to None
              Data to sent in the request. If it's not None, a POST will be done
              instead of a GET.
          `req_headers`: dict, defaults to None
              Custom headers to add to the request.
          `chunk_size`: int, defaults to 8192
              Size of each chunk to read, used only when `on_progress` callback
              has been set. If you decrease it too much, a lot of on_progress
              callbacks will be fired and will slow down your download. If you
              want to have the maximum download speed, increase the chunk_size
              or don't use ``on_progress``.
          `timeout`: int, defaults to None
              If set, blocking operations will timeout after this many seconds.
          `method`: str, defaults to 'GET' (or 'POST' if ``body`` is specified)
              The HTTP method to use.
          `decode`: bool, defaults to True
              If False, skip decoding of the response.
          `debug`: bool, defaults to False
              If True, it will use the Logger.debug to print information
              about url access/progression/errors.
          `file_path`: str, defaults to None
              If set, the result of the UrlRequest will be written to this path
              instead of in memory.
          `ca_file`: str, defaults to None
              Indicates a SSL CA certificate file path to validate HTTPS
              certificates against
          `verify`: bool, defaults to True
              If False, disables SSL CA certificate verification
          `proxy_host`: str, defaults to None
              If set, the proxy host to use for this connection.
          `proxy_port`: int, defaults to None
              If set, and `proxy_host` is also set, the port to use for
              connecting to the proxy server.
          `proxy_headers`: dict, defaults to None
              If set, and `proxy_host` is also set, the headers to send to the
              proxy server in the ``CONNECT`` request.
          `auth`: HTTPBasicAuth, defaults to None
              If set, request will use basicauth to authenticate.
              Only used in "Requests" implementation
      ```
      基类: Name(id='Thread', ctx=Load())
      函数 __init__(self: , url: , on_success: , on_redirect: , on_failure: , on_error: , on_progress: , req_body: , req_headers: , chunk_size: , timeout: , method: , decode: , debug: , file_path: , ca_file: , verify: , proxy_host: , proxy_port: , proxy_headers: , user_agent: , on_cancel: , on_finish: , cookies: , auth: )
      函数 run(self: )
      函数 _fetch_url(self: , url: , body: , headers: , q: )
      函数 decode_result(self: , result: , resp: )
        ```
        Decode the result fetched from url according to his Content-Type.
        Currently supports only application/json.
        ```
      函数 _dispatch_result(self: , dt: )
      函数 is_finished(self: )
        ```
        Return True if the request has finished, whether it's a
        success or a failure.
        ```
      函数 result(self: )
        ```
        Return the result of the request.
        This value is not determined until the request is finished.
        ```
      函数 resp_headers(self: )
        ```
        If the request has been completed, return a dictionary containing
        the headers of the response. Otherwise, it will return None.
        ```
      函数 resp_status(self: )
        ```
        Return the status code of the response if the request is complete,
        otherwise return None.
        ```
      函数 error(self: )
        ```
        Return the error of the request.
        This value is not determined until the request is completed.
        ```
      函数 chunk_size(self: )
        ```
        Return the size of a chunk, used only in "progress" mode (when
        on_progress callback is set.)
        ```
      函数 wait(self: , delay: )
        ```
        Wait for the request to finish (until :attr:`resp_status` is not
        None)
        
        .. note::
            This method is intended to be used in the main thread, and the
            callback will be dispatched from the same thread
            from which you're calling.
        
        .. versionadded:: 1.1.0
        ```
      函数 cancel(self: )
        ```
        Cancel the current request. It will be aborted, and the result
        will not be dispatched. Once cancelled, the callback on_cancel will
        be called.
        
        .. versionadded:: 1.11.0
        ```
    类 UrlRequestUrllib:
      基类: Name(id='UrlRequestBase', ctx=Load())
      函数 get_chunks(self: , resp: , chunk_size: , total_size: , report_progress: , q: , trigger: , fd: )
      函数 get_response(self: , resp: )
      函数 get_total_size(self: , resp: )
      函数 get_content_type(self: , resp: )
      函数 get_status_code(self: , resp: )
      函数 get_all_headers(self: , resp: )
      函数 close_connection(self: , req: )
      函数 _parse_url(self: , url: )
      函数 _get_connection_for_scheme(self: , scheme: )
        ```
        Return the Connection class for a particular scheme.
        This is an internal function that can be expanded to support custom
        schemes.
        
        Actual supported schemes: http, https.
        ```
      函数 call_request(self: , body: , headers: )
    类 UrlRequestRequests:
      基类: Name(id='UrlRequestBase', ctx=Load())
    分析文件: __init__.py
  分析文件: metrics.py
  函数 pt(value: )
    ```
    Convert from points to pixels
        
    ```
  函数 inch(value: )
    ```
    Convert from inches to pixels
        
    ```
  函数 cm(value: )
    ```
    Convert from centimeters to pixels
        
    ```
  函数 mm(value: )
    ```
    Convert from millimeters to pixels
        
    ```
  函数 dp(value: )
    ```
    Convert from density-independent pixels to pixels
        
    ```
  函数 sp(value: )
    ```
    Convert from scale-independent pixels to pixels
        
    ```
  类 MetricsBase:
    ```
    Class that contains the default attributes for Metrics. Don't use this
    class directly, but use the `Metrics` instance.
    ```
    基类: Name(id='EventDispatcher', ctx=Load())
    函数 __init__(self: )
    函数 get_dpi(self: , force_recompute: )
    函数 set_dpi(self: , value: )
    函数 get_dpi_rounded(self: )
    函数 get_density(self: , force_recompute: )
    函数 set_density(self: , value: )
    函数 get_fontscale(self: , force_recompute: )
    函数 set_fontscale(self: , value: )
    函数 get_in(self: )
    函数 get_dp(self: )
    函数 get_sp(self: )
    函数 get_pt(self: )
    函数 get_cm(self: )
    函数 get_mm(self: )
    函数 reset_metrics(self: )
      ```
      Resets the dpi/density/fontscale to the platform values, overwriting
      any manually set values.
      ```
    函数 reset_dpi(self: )
      ```
      Resets the dpi (and possibly density) to the platform values,
      overwriting any manually set values.
      ```
    函数 _set_cached_scaling(self: )
  extras/
    分析文件: highlight.py
    类 KivyLexer:
      基类: Name(id='RegexLexer', ctx=Load())
    分析文件: __init__.py
  分析文件: logger.py
  类 FileHandler:
    基类: Attribute(value=Name(id='logging', ctx=Load()), attr='Handler', ctx=Load())
    函数 purge_logs(self: )
      ```
      Purge logs which exceed the maximum amount of log files,
      starting with the oldest creation timestamp (or edit-timestamp on Linux)
      ```
    函数 _configure(self: )
    函数 _write_message(self: , record: )
    函数 emit(self: , message: )
  类 LoggerHistory:
    基类: Attribute(value=Name(id='logging', ctx=Load()), attr='Handler', ctx=Load())
    函数 clear_history(cls: )
    函数 flush(self: )
  类 ConsoleHandler:
    ```
    Emits records to a stream (by default, stderr).
    
    However, if the msg starts with "stderr:" it is not formatted, but
    written straight to the stream.
    
    .. versionadded:: 2.2.0
    ```
    基类: Attribute(value=Name(id='logging', ctx=Load()), attr='StreamHandler', ctx=Load())
    函数 filter(self: , record: )
  类 ProcessingStream:
    ```
    Stream-like object that takes each completed line written to it,
    adds a given prefix, and applies the given function to it.
    
    .. versionadded:: 2.2.0
    ```
    基类: Name(id='object', ctx=Load())
    函数 __init__(self: , channel: , func: )
    函数 write(self: , s: )
    函数 isatty(self: )
  函数 logger_config_update(section: , key: , value: )
  类 ColonSplittingLogRecord:
    ```
    Clones an existing logRecord, but reformats the message field
    if it contains a colon.
    
    .. versionadded:: 2.2.0
    ```
    基类: Attribute(value=Name(id='logging', ctx=Load()), attr='LogRecord', ctx=Load())
  类 ColoredLogRecord:
    ```
    Clones an existing logRecord, but reformats the levelname to add
    color, and the message to add bolding (where indicated by $BOLD
    and $RESET in the message).
    
    .. versionadded:: 2.2.0
    ```
    基类: Attribute(value=Name(id='logging', ctx=Load()), attr='LogRecord', ctx=Load())
    函数 _format_message(cls: , message: )
    函数 _format_levelname(cls: , levelname: )
  类 UncoloredLogRecord:
    ```
    Clones an existing logRecord, but reformats the message
    to remove $BOLD/$RESET markup.
    
    .. versionadded:: 2.2.0
    ```
    基类: Attribute(value=Name(id='logging', ctx=Load()), attr='LogRecord', ctx=Load())
  类 KivyFormatter:
    ```
    Split out first field in message marked with a colon,
    and either apply terminal color codes to the record, or strip
    out color markup if colored logging is not available.
    
    .. versionadded:: 2.2.0
    ```
    基类: Attribute(value=Name(id='logging', ctx=Load()), attr='Formatter', ctx=Load())
    函数 format(self: , record: )
  函数 is_color_terminal()
    ```
    Detect whether the environment supports color codes in output.
    
    .. versionadded:: 2.2.0
    ```
  函数 add_kivy_handlers(logger: )
    ```
    Add Kivy-specific handlers to a logger.
    
    .. versionadded:: 2.2.0
    ```
  garden/
    分析文件: __init__.py
    类 GardenImporter:
      基类: Name(id='object', ctx=Load())
      函数 find_module(self: , fullname: , path: )
      函数 load_module(self: , fullname: )
      函数 _load_module(self: , fullname: , moddir: )
  input/
    postproc/
      分析文件: retaintouch.py
      类 InputPostprocRetainTouch:
        ```
        InputPostprocRetainTouch is a post-processor to delay the 'up' event of a
        touch, to reuse it under certains conditions. This module is designed to
        prevent lost finger touches on some hardware/setups.
        
        Retain touch can be configured in the Kivy config file::
        
            [postproc]
                retain_time = 100
                retain_distance = 50
        
        The distance parameter is in the range 0-1000 and time is in milliseconds.
        ```
        基类: Name(id='object', ctx=Load())
        函数 __init__(self: )
        函数 process(self: , events: )
      分析文件: doubletap.py
      类 InputPostprocDoubleTap:
        ```
        InputPostProcDoubleTap is a post-processor to check if
        a touch is a double tap or not.
        Double tap can be configured in the Kivy config file::
        
            [postproc]
            double_tap_time = 250
            double_tap_distance = 20
        
        Distance parameter is in the range 0-1000 and time is in milliseconds.
        ```
        基类: Name(id='object', ctx=Load())
        函数 __init__(self: )
        函数 find_double_tap(self: , ref: )
          ```
          Find a double tap touch within self.touches.
          The touch must be not a previous double tap and the distance must be
          within the specified threshold. Additionally, the touch profiles
          must be the same kind of touch.
          ```
        函数 process(self: , events: )
      分析文件: dejitter.py
      类 InputPostprocDejitter:
        ```
        Get rid of jitterish BLOBs.
        Example::
        
            [postproc]
            jitter_distance = 0.004
            jitter_ignore_devices = mouse,mactouch
        
        :Configuration:
            `jitter_distance`: float
                A float in range 0-1.
            `jitter_ignore_devices`: string
                A comma-separated list of device identifiers that
                should not be processed by dejitter (because they're
                very precise already).
        ```
        基类: Name(id='object', ctx=Load())
        函数 __init__(self: )
        函数 taxicab_distance(self: , p: , q: )
        函数 process(self: , events: )
      分析文件: tripletap.py
      类 InputPostprocTripleTap:
        ```
        InputPostProcTripleTap is a post-processor to check if
        a touch is a triple tap or not.
        Triple tap can be configured in the Kivy config file::
        
            [postproc]
            triple_tap_time = 250
            triple_tap_distance = 20
        
        The distance parameter is in the range 0-1000 and time is in milliseconds.
        ```
        基类: Name(id='object', ctx=Load())
        函数 __init__(self: )
        函数 find_triple_tap(self: , ref: )
          ```
          Find a triple tap touch within *self.touches*.
          The touch must be not be a previous triple tap and the distance
          must be be within the bounds specified. Additionally, the touch profile
          must be the same kind of touch.
          ```
        函数 process(self: , events: )
      分析文件: calibration.py
      类 InputPostprocCalibration:
        ```
        Recalibrate the inputs.
        
        The configuration must go within a section named `postproc:calibration`.
        Within the section, you must have a line like::
        
            devicename = param=value,param=value
        
        If you wish to match by provider, you must have a line like::
        
            (provider) = param=value,param=value
        
        :Parameters:
            `xratio`: float
                Value to multiply X
            `yratio`: float
                Value to multiply Y
            `xoffset`: float
                Value to add to X
            `yoffset`: float
                Value to add to Y
            `auto`: str
                If set, then the touch is transformed from screen-relative
                to window-relative The value is used as an indication of
                screen size, e.g for fullHD:
        
                    auto=1920x1080
        
                If present, this setting overrides all the others.
                This assumes the input device exactly covers the display
                area, if they are different, the computations will be wrong.
        
        .. versionchanged:: 1.11.0
            Added `auto` parameter
        ```
        基类: Name(id='object', ctx=Load())
        函数 __init__(self: )
        函数 _get_provider_map(self: )
          ```
          Iterates through all registered input provider names and finds the
          respective MotionEvent subclass for each. Returns a dict of MotionEvent
          subclasses mapped to their provider name.
          ```
        函数 _get_provider_key(self: , event: )
          ```
          Returns the provider key for the event if the provider is configured
          for calibration.
          ```
        函数 process(self: , events: )
        函数 auto_calibrate(self: , sx: , sy: , size: )
      分析文件: ignorelist.py
      类 InputPostprocIgnoreList:
        ```
        InputPostprocIgnoreList is a post-processor which removes touches in the
        Ignore list. The Ignore list can be configured in the Kivy config file::
        
            [postproc]
            # Format: [(xmin, ymin, xmax, ymax), ...]
            ignore = [(0.1, 0.1, 0.15, 0.15)]
        
        The Ignore list coordinates are in the range 0-1, not in screen pixels.
        ```
        基类: Name(id='object', ctx=Load())
        函数 __init__(self: )
        函数 collide_ignore(self: , touch: )
        函数 process(self: , events: )
      分析文件: __init__.py
    分析文件: provider.py
    类 MotionEventProvider:
      ```
      Base class for a provider.
          
      ```
      基类: Name(id='object', ctx=Load())
      函数 __init__(self: , device: , args: )
      函数 start(self: )
        ```
        Start the provider. This method is automatically called when the
        application is started and if the configuration uses the current
        provider.
        ```
      函数 stop(self: )
        ```
        Stop the provider.
                
        ```
      函数 update(self: , dispatch_fn: )
        ```
        Update the provider and dispatch all the new touch events though the
        `dispatch_fn` argument.
        ```
    分析文件: shape.py
    类 Shape:
      ```
      Abstract class for all implementations of a shape
      ```
      基类: Name(id='object', ctx=Load())
    类 ShapeRect:
      ```
      Class for the representation of a rectangle.
      ```
      基类: Name(id='Shape', ctx=Load())
      函数 __init__(self: )
    分析文件: recorder.py
    类 RecorderMotionEvent:
      基类: Name(id='MotionEvent', ctx=Load())
      函数 depack(self: , args: )
    类 Recorder:
      ```
      Recorder class. Please check module documentation for more information.
      
      :Events:
          `on_stop`:
              Fired when the playing stops.
      
      .. versionchanged:: 1.10.0
          Event `on_stop` added.
      ```
      基类: Name(id='EventDispatcher', ctx=Load())
      函数 __init__(self: )
      函数 on_motion(self: , window: , etype: , motionevent: )
      函数 on_keyboard(self: , etype: , window: , key: )
      函数 release(self: )
      函数 on_record(self: , instance: , value: )
      函数 stop(self: )
      函数 start(self: )
      函数 on_play(self: , instance: , value: )
      函数 on_stop(self: )
      函数 update(self: , dispatch_fn: )
    分析文件: motionevent.py
    类 EnhancedDictionary:
      基类: Name(id='dict', ctx=Load())
      函数 __getattr__(self: , attr: )
      函数 __setattr__(self: , attr: , value: )
    类 MotionEventMetaclass:
      基类: Name(id='type', ctx=Load())
      函数 __new__(mcs: , name: , bases: , attrs: )
    类 MotionEvent:
      ```
      Abstract class that represents an input event.
      
      :Parameters:
          `id`: str
              unique ID of the MotionEvent
          `args`: list
              list of parameters, passed to the depack() function
      ```
      基类: Name(id='MotionEventBase', ctx=Load())
      函数 __init__(self: , device: , id: , args: , is_touch: , type_id: )
      函数 depack(self: , args: )
        ```
        Depack `args` into attributes of the class
        ```
      函数 grab(self: , class_instance: , exclusive: )
        ```
        Grab this motion event.
        
        If this event is a touch you can grab it if you want to receive
        subsequent :meth:`~kivy.uix.widget.Widget.on_touch_move` and
        :meth:`~kivy.uix.widget.Widget.on_touch_up` events, even if the touch
        is not dispatched by the parent:
        
        .. code-block:: python
        
            def on_touch_down(self, touch):
                touch.grab(self)
        
            def on_touch_move(self, touch):
                if touch.grab_current is self:
                    # I received my grabbed touch
                else:
                    # it's a normal touch
        
            def on_touch_up(self, touch):
                if touch.grab_current is self:
                    # I receive my grabbed touch, I must ungrab it!
                    touch.ungrab(self)
                else:
                    # it's a normal touch
                    pass
        
        .. versionchanged:: 2.1.0
            Allowed grab for non-touch events.
        ```
      函数 ungrab(self: , class_instance: )
        ```
        Ungrab a previously grabbed motion event.
                
        ```
      函数 dispatch_done(self: )
        ```
        Notify that dispatch to the listeners is done.
        
        Called by the :meth:`EventLoopBase.post_dispatch_input`.
        
        .. versionadded:: 2.1.0
        ```
      函数 move(self: , args: )
        ```
        Move to another position.
                
        ```
      函数 scale_for_screen(self: , w: , h: , p: , rotation: , smode: , kheight: )
        ```
        Scale position for the screen.
        
        .. versionchanged:: 2.1.0
            Max value for `x`, `y` and `z` is changed respectively to `w` - 1,
            `h` - 1 and `p` - 1.
        ```
      函数 to_absolute_pos(self: , nx: , ny: , x_max: , y_max: , rotation: )
        ```
        Transforms normalized (0-1) coordinates `nx` and `ny` to absolute
        coordinates using `x_max`, `y_max` and `rotation`.
        
        :raises:
            `ValueError`: If `rotation` is not one of: 0, 90, 180 or 270
        
        .. versionadded:: 2.1.0
        ```
      函数 push(self: , attrs: )
        ```
        Push attribute values in `attrs` onto the stack.
                
        ```
      函数 pop(self: )
        ```
        Pop attributes values from the stack.
                
        ```
      函数 apply_transform_2d(self: , transform: )
        ```
        Apply a transformation on x, y, z, px, py, pz,
        ox, oy, oz, dx, dy, dz.
        ```
      函数 copy_to(self: , to: )
        ```
        Copy some attribute to another motion event object.
        ```
      函数 distance(self: , other_touch: )
        ```
        Return the distance between the two events.
                
        ```
      函数 update_time_end(self: )
      函数 dpos(self: )
        ```
        Return delta between last position and current position, in the
        screen coordinate system (self.dx, self.dy).
        ```
      函数 opos(self: )
        ```
        Return the initial position of the motion event in the screen
        coordinate system (self.ox, self.oy).
        ```
      函数 ppos(self: )
        ```
        Return the previous position of the motion event in the screen
        coordinate system (self.px, self.py).
        ```
      函数 spos(self: )
        ```
        Return the position in the 0-1 coordinate system (self.sx, self.sy).
                
        ```
      函数 __str__(self: )
      函数 __repr__(self: )
      函数 is_mouse_scrolling(self: )
        ```
        Returns True if the touch event is a mousewheel scrolling
        
        .. versionadded:: 1.6.0
        ```
    providers/
      分析文件: hidinput.py
      类 HIDMotionEvent:
        基类: Name(id='MotionEvent', ctx=Load())
        函数 __init__(self: )
        函数 depack(self: , args: )
        函数 __str__(self: )
      类 HIDInputMotionEventProvider:
        基类: Name(id='MotionEventProvider', ctx=Load())
        函数 start(self: )
        函数 _thread_run(self: )
        函数 update(self: , dispatch_fn: )
      函数 assign_coord(point: , value: , invert: , coords: )
      函数 assign_rel_coord(point: , value: , invert: , coords: )
      函数 process_as_multitouch(tv_sec: , tv_usec: , ev_type: , ev_code: , ev_value: )
      函数 process_as_mouse_or_keyboard(tv_sec: , tv_usec: , ev_type: , ev_code: , ev_value: )
      函数 process(points: )
      函数 normalize(value: , vmin: , vmax: )
      分析文件: wm_touch.py
      类 WM_MotionEvent:
        ```
        MotionEvent representing the WM_MotionEvent event.
        Supports pos, shape and size profiles.
        ```
        基类: Name(id='MotionEvent', ctx=Load())
        函数 __init__(self: )
        函数 depack(self: , args: )
        函数 __str__(self: )
      类 WM_MotionEventProvider:
        基类: Name(id='MotionEventProvider', ctx=Load())
        函数 start(self: )
        函数 update(self: , dispatch_fn: )
        函数 stop(self: )
        函数 _touch_wndProc(self: , hwnd: , msg: , wParam: , lParam: )
        函数 _touch_handler(self: , msg: , wParam: , lParam: )
        函数 _mouse_handler(self: , msg: , wparam: , lParam: )
      分析文件: probesysfs.py
      类 Input:
        基类: Name(id='object', ctx=Load())
        函数 __init__(self: , path: )
        函数 device(self: )
        函数 name(self: )
        函数 get_capabilities(self: )
        函数 has_capability(self: , capability: )
        函数 is_mouse(self: )
      函数 getout()
      函数 query_xinput()
      函数 get_inputs(path: )
      函数 read_line(path: )
      类 ProbeSysfsHardwareProbe:
        基类: Name(id='MotionEventProvider', ctx=Load())
        函数 __new__(self: , device: , args: )
        函数 should_use_mouse(self: )
        函数 probe(self: )
      分析文件: mactouch.py
      类 MacMotionEvent:
        ```
        MotionEvent representing a contact point on the touchpad. Supports pos
        and shape profiles.
        ```
        基类: Name(id='MotionEvent', ctx=Load())
        函数 __init__(self: )
        函数 depack(self: , args: )
        函数 __str__(self: )
      类 MacMotionEventProvider:
        基类: Name(id='MotionEventProvider', ctx=Load())
        函数 start(self: )
        函数 update(self: , dispatch_fn: )
        函数 stop(self: )
        函数 _mts_callback(device: , data_ptr: , n_fingers: , timestamp: , frame: )
      类 MTPoint:
        基类: Attribute(value=Name(id='ctypes', ctx=Load()), attr='Structure', ctx=Load())
      类 MTVector:
        基类: Attribute(value=Name(id='ctypes', ctx=Load()), attr='Structure', ctx=Load())
      类 MTData:
        基类: Attribute(value=Name(id='ctypes', ctx=Load()), attr='Structure', ctx=Load())
      分析文件: tuio.py
      类 TuioMotionEventProvider:
        ```
        The TUIO provider listens to a socket and handles some of the incoming
        OSC messages:
        
            * /tuio/2Dcur
            * /tuio/2Dobj
        
        You can easily extend the provider to handle new TUIO paths like so::
        
            # Create a class to handle the new TUIO type/path
            # Replace NEWPATH with the pathname you want to handle
            class TuioNEWPATHMotionEvent(MotionEvent):
        
                def depack(self, args):
                    # In this method, implement 'unpacking' for the received
                    # arguments. you basically translate from TUIO args to Kivy
                    # MotionEvent variables. If all you receive are x and y
                    # values, you can do it like this:
                    if len(args) == 2:
                        self.sx, self.sy = args
                        self.profile = ('pos', )
                    self.sy = 1 - self.sy
                    super().depack(args)
        
            # Register it with the TUIO MotionEvent provider.
            # You obviously need to replace the PATH placeholders appropriately.
            TuioMotionEventProvider.register('/tuio/PATH', TuioNEWPATHMotionEvent)
        
        .. note::
        
            The class name is of no technical importance. Your class will be
            associated with the path that you pass to the ``register()``
            function. To keep things simple, you should name your class after the
            path that it handles, though.
        ```
        基类: Name(id='MotionEventProvider', ctx=Load())
        函数 __init__(self: , device: , args: )
        函数 register(oscpath: , classname: )
          ```
          Register a new path to handle in TUIO provider
          ```
        函数 unregister(oscpath: , classname: )
          ```
          Unregister a path to stop handling it in the TUIO provider
          ```
        函数 create(oscpath: )
          ```
          Create a touch event from a TUIO path
          ```
        函数 start(self: )
          ```
          Start the TUIO provider
          ```
        函数 stop(self: )
          ```
          Stop the TUIO provider
          ```
        函数 update(self: , dispatch_fn: )
          ```
          Update the TUIO provider (pop events from the queue)
          ```
        函数 _osc_tuio_cb(self: , oscpath: , address: )
        函数 _update(self: , dispatch_fn: , value: )
      类 TuioMotionEvent:
        ```
        Abstraction for TUIO touches/fiducials.
        
        Depending on the tracking software you use (e.g. Movid, CCV, etc.) and its
        TUIO implementation, the TuioMotionEvent object can support multiple
        profiles such as:
        
            * Fiducial ID: profile name 'markerid', attribute ``.fid``
            * Position: profile name 'pos', attributes ``.x``, ``.y``
            * Angle: profile name 'angle', attribute ``.a``
            * Velocity vector: profile name 'mov', attributes ``.X``, ``.Y``
            * Rotation velocity: profile name 'rot', attribute ``.A``
            * Motion acceleration: profile name 'motacc', attribute ``.m``
            * Rotation acceleration: profile name 'rotacc', attribute ``.r``
        ```
        基类: Name(id='MotionEvent', ctx=Load())
      类 Tuio2dCurMotionEvent:
        ```
        A 2dCur TUIO touch.
        ```
        基类: Name(id='TuioMotionEvent', ctx=Load())
        函数 depack(self: , args: )
      类 Tuio2dObjMotionEvent:
        ```
        A 2dObj TUIO object.
            
        ```
        基类: Name(id='TuioMotionEvent', ctx=Load())
      类 Tuio2dBlbMotionEvent:
        ```
        A 2dBlb TUIO object.
        # FIXME 3d shape are not supported
        /tuio/2Dobj set s i x y a       X Y A m r
        /tuio/2Dblb set s   x y a w h f X Y A m r
        ```
        基类: Name(id='TuioMotionEvent', ctx=Load())
      分析文件: mtdev.py
      类 MTDMotionEvent:
        基类: Name(id='MotionEvent', ctx=Load())
        函数 __init__(self: )
        函数 depack(self: , args: )
        函数 __str__(self: )
      类 MTDMotionEventProvider:
        基类: Name(id='MotionEventProvider', ctx=Load())
        函数 start(self: )
        函数 _thread_run(self: )
        函数 update(self: , dispatch_fn: )
      函数 assign_coord(point: , value: , invert: , coords: )
      函数 process(points: )
      函数 normalize(value: , vmin: , vmax: )
      分析文件: leapfinger.py
      函数 normalize(value: , a: , b: )
      类 LeapFingerEvent:
        基类: Name(id='MotionEvent', ctx=Load())
        函数 __init__(self: )
        函数 depack(self: , args: )
      类 LeapFingerEventProvider:
        基类: Name(id='MotionEventProvider', ctx=Load())
        函数 start(self: )
        函数 update(self: , dispatch_fn: )
        函数 process_frame(self: , frame: )
      类 LeapMotionListener:
        基类: Attribute(value=Name(id='Leap', ctx=Load()), attr='Listener', ctx=Load())
        函数 on_init(self: , controller: )
        函数 on_connect(self: , controller: )
        函数 on_disconnect(self: , controller: )
        函数 on_frame(self: , controller: )
        函数 on_exit(self: , controller: )
      分析文件: wm_pen.py
      类 WM_Pen:
        ```
        MotionEvent representing the WM_Pen event. Supports the pos profile.
        ```
        基类: Name(id='MotionEvent', ctx=Load())
        函数 __init__(self: )
        函数 depack(self: , args: )
        函数 __str__(self: )
      类 WM_PenProvider:
        基类: Name(id='MotionEventProvider', ctx=Load())
        函数 _is_pen_message(self: , msg: )
        函数 _pen_handler(self: , msg: , wParam: , lParam: )
        函数 _pen_wndProc(self: , hwnd: , msg: , wParam: , lParam: )
        函数 start(self: )
        函数 update(self: , dispatch_fn: )
        函数 stop(self: )
      分析文件: mouse.py
      类 MouseMotionEvent:
        基类: Name(id='MotionEvent', ctx=Load())
        函数 __init__(self: )
        函数 depack(self: , args: )
        函数 update_graphics(self: , win: , create: )
        函数 clear_graphics(self: , win: )
      类 MouseMotionEventProvider:
        基类: Name(id='MotionEventProvider', ctx=Load())
        函数 _get_disable_hover(self: )
        函数 _set_disable_hover(self: , value: )
        函数 start(self: )
          ```
          Start the mouse provider
          ```
        函数 _start_hover_events(self: )
        函数 stop(self: )
          ```
          Stop the mouse provider
          ```
        函数 _stop_hover_events(self: )
        函数 test_activity(self: )
        函数 find_touch(self: , win: , x: , y: )
        函数 create_event_id(self: )
        函数 create_touch(self: , win: , nx: , ny: , is_double_tap: , do_graphics: , button: )
        函数 remove_touch(self: , win: , touch: )
        函数 create_hover(self: , win: , etype: )
        函数 on_mouse_motion(self: , win: , x: , y: , modifiers: )
        函数 on_mouse_press(self: , win: , x: , y: , button: , modifiers: )
        函数 on_mouse_release(self: , win: , x: , y: , button: , modifiers: )
        函数 update_touch_graphics(self: , win: )
        函数 begin_or_update_hover_event(self: , win: )
        函数 begin_hover_event(self: , win: )
        函数 update_hover_event(self: , win: )
        函数 end_hover_event(self: , win: )
        函数 update(self: , dispatch_fn: )
          ```
          Update the mouse provider (pop event from the queue)
          ```
      分析文件: linuxwacom.py
      类 LinuxWacomMotionEvent:
        基类: Name(id='MotionEvent', ctx=Load())
        函数 __init__(self: )
        函数 depack(self: , args: )
        函数 __str__(self: )
      类 LinuxWacomMotionEventProvider:
        基类: Name(id='MotionEventProvider', ctx=Load())
        函数 start(self: )
        函数 _thread_run(self: )
        函数 update(self: , dispatch_fn: )
      函数 process(points: )
      函数 normalize(value: , vmin: , vmax: )
      分析文件: wm_common.py
      类 RECT:
        基类: Name(id='RECT_BASE', ctx=Load())
      类 TOUCHINPUT:
        基类: Name(id='Structure', ctx=Load())
        函数 size(self: )
        函数 screen_x(self: )
        函数 screen_y(self: )
        函数 _event_type(self: )
      函数 SetWindowLong_WndProc_wrapper_generator(func: )
      函数 _closure(hWnd: , wndProc: )
      分析文件: androidjoystick.py
      类 AndroidMotionEvent:
        基类: Name(id='MotionEvent', ctx=Load())
        函数 __init__(self: )
        函数 depack(self: , args: )
      类 AndroidMotionEventProvider:
        基类: Name(id='MotionEventProvider', ctx=Load())
        函数 create_joystick(self: , index: )
        函数 start(self: )
        函数 stop(self: )
        函数 update(self: , dispatch_fn: )
      分析文件: __init__.py
    分析文件: __init__.py
    分析文件: factory.py
    类 MotionEventFactory:
      ```
      MotionEvent factory is a class that registers all availables input
      factories. If you create a new input factory, you need to register
      it here::
      
          MotionEventFactory.register('myproviderid', MyInputProvider)
      ```
      函数 register(name: , classname: )
        ```
        Register a input provider in the database
        ```
      函数 list()
        ```
        Get a list of all available providers
        ```
      函数 get(name: )
        ```
        Get a provider class from the provider id
        ```
  分析文件: loader.py
  类 ProxyImage:
    ```
    Image returned by the Loader.image() function.
    
    :Properties:
        `loaded`: bool, defaults to False
            This value may be True if the image is already cached.
    
    :Events:
        `on_load`
            Fired when the image is loaded or changed.
        `on_error`
            Fired when the image cannot be loaded.
            `error`: Exception data that occurred
    ```
    基类: Name(id='Image', ctx=Load())
    函数 __init__(self: , arg: )
    函数 on_load(self: )
    函数 on_error(self: , error: )
  类 LoaderBase:
    ```
    Common base for the Loader and specific implementations.
    By default, the Loader will be the best available loader implementation.
    
    The _update() function is called every 1 / 25.s or each frame if we have
    less than 25 FPS.
    ```
    基类: Name(id='object', ctx=Load())
    函数 __del__(self: )
    函数 _set_num_workers(self: , num: )
    函数 _get_num_workers(self: )
    函数 _set_max_upload_per_frame(self: , num: )
    函数 _get_max_upload_per_frame(self: )
    函数 _get_loading_image(self: )
    函数 _set_loading_image(self: , image: )
    函数 _get_error_image(self: )
    函数 _set_error_image(self: , image: )
    函数 start(self: )
      ```
      Start the loader thread/process.
      ```
    函数 run(self: )
      ```
      Main loop for the loader.
      ```
    函数 stop(self: )
      ```
      Stop the loader thread/process.
      ```
    函数 pause(self: )
      ```
      Pause the loader, can be useful during interactions.
      
      .. versionadded:: 1.6.0
      ```
    函数 resume(self: )
      ```
      Resume the loader, after a :meth:`pause`.
      
      .. versionadded:: 1.6.0
      ```
    函数 _wait_for_resume(self: )
    函数 _load(self: , kwargs: )
      ```
      (internal) Loading function, called by the thread.
      Will call _load_local() if the file is local,
      or _load_urllib() if the file is on Internet.
      ```
    函数 _load_local(self: , filename: , kwargs: )
      ```
      (internal) Loading a local file
      ```
    函数 _load_urllib(self: , filename: , kwargs: )
      ```
      (internal) Loading a network file. First download it, save it to a
      temporary file, and pass it to _load_local().
      ```
    函数 _update(self: )
      ```
      (internal) Check if a data is loaded, and pass to the client.
      ```
    函数 image(self: , filename: , load_callback: , post_callback: )
      ```
      Load a image using the Loader. A ProxyImage is returned with a
      loading image. You can use it as follows::
      
          from kivy.app import App
          from kivy.uix.image import Image
          from kivy.loader import Loader
      
          class TestApp(App):
              def _image_loaded(self, proxyImage):
                  if proxyImage.image.texture:
                      self.image.texture = proxyImage.image.texture
      
              def build(self):
                  proxyImage = Loader.image("myPic.jpg")
                  proxyImage.bind(on_load=self._image_loaded)
                  self.image = Image()
                  return self.image
      
          TestApp().run()
      
      In order to cancel all background loading, call *Loader.stop()*.
      ```
    函数 remove_from_cache(self: , filename: )
  类 _Worker:
    ```
    Thread executing tasks from a given tasks queue
            
    ```
    基类: Name(id='Thread', ctx=Load())
  类 _ThreadPool:
    ```
    Pool of threads consuming tasks from a queue
            
    ```
    基类: Name(id='object', ctx=Load())
    函数 add_task(self: , func: )
      ```
      Add a task to the queue
                  
      ```
  类 LoaderThreadPool:
    基类: Name(id='LoaderBase', ctx=Load())
  data/
    keyboards/
    logo/
    fonts/
    glsl/
    images/
  graphics/
    cgl_backend/
      分析文件: __init__.py
    分析文件: __init__.py
  分析文件: __init__.py
  函数 parse_kivy_version(version: )
    ```
    Parses the kivy version as described in :func:`require` into a 3-tuple
    of ([x, y, z], 'rc|a|b|dev|post', 'N') where N is the tag revision. The
    last two elements may be None.
    ```
  函数 require(version: )
    ```
    Require can be used to check the minimum version required to run a Kivy
    application. For example, you can start your application code like this::
    
        import kivy
        kivy.require('1.0.1')
    
    If a user attempts to run your application with a version of Kivy that is
    older than the specified version, an Exception is raised.
    
    The Kivy version string is built like this::
    
        X.Y.Z[tag[tagrevision]]
    
        X is the major version
        Y is the minor version
        Z is the bugfixes revision
    
    The tag is optional, but may be one of '.dev', '.post', 'a', 'b', or 'rc'.
    The tagrevision is the revision number of the tag.
    
    .. warning::
    
        You must not ask for a version with a tag, except -dev. Asking for a
        'dev' version will just warn the user if the current Kivy
        version is not a -dev, but it will never raise an exception.
        You must not ask for a version with a tagrevision.
    ```
  函数 kivy_configure()
    ```
    Call post-configuration of Kivy.
    This function must be called if you create the window yourself.
    ```
  函数 get_includes()
    ```
    Retrieves the directories containing includes needed to build new Cython
    modules with Kivy as a dependency. Currently returns the location of the
    kivy.graphics module.
    
    .. versionadded:: 1.9.1
    ```
  函数 kivy_register_post_configuration(callback: )
    ```
    Register a function to be called when kivy_configure() is called.
    
    .. warning::
        Internal use only.
    ```
  函数 kivy_usage()
    ```
    Kivy Usage: %s [KIVY OPTION...] [-- PROGRAM OPTIONS]::
    
        Options placed after a '-- ' separator, will not be touched by kivy,
        and instead passed to your program.
    
        Set KIVY_NO_ARGS=1 in your environment or before you import Kivy to
        disable Kivy's argument parser.
    
    -h, --help
        Prints this help message.
    -d, --debug
        Shows debug log.
    -a, --auto-fullscreen
        Force 'auto' fullscreen mode (no resolution change).
        Uses your display's resolution. This is most likely what you want.
    -c, --config section:key[:value]
        Set a custom [section] key=value in the configuration object.
    -f, --fullscreen
        Force running in fullscreen mode.
    -k, --fake-fullscreen
        Force 'fake' fullscreen mode (no window border/decoration).
        Uses the resolution specified by width and height in your config.
    -w, --windowed
        Force running in a window.
    -p, --provider id:provider[,options]
        Add an input provider (eg: ccvtable1:tuio,192.168.0.1:3333).
    -m mod, --module=mod
        Activate a module (use "list" to get a list of available modules).
    -r, --rotation
        Rotate the window's contents (0, 90, 180, 270).
    -s, --save
        Save current Kivy configuration.
    --size=640x480
        Size of window geometry.
    --dpi=96
        Manually overload the Window DPI (for testing only.)
    ```
  函数 _patch_mod_deps_win(dep_mod: , mod_name: )
  分析文件: config.py
  类 ConfigParser:
    ```
    Enhanced ConfigParser class that supports the addition of default
    sections and default values.
    
    By default, the kivy ConfigParser instance, :attr:`~kivy.config.Config`,
    is named `'kivy'` and the ConfigParser instance used by the
    :meth:`App.build_settings <~kivy.app.App.build_settings>` method is named
    `'app'`.
    
    :Parameters:
        `name`: string
            The name of the instance. See :attr:`name`. Defaults to `''`.
    
    .. versionchanged:: 1.9.0
        Each ConfigParser can now be :attr:`named <name>`. You can get the
        ConfigParser associated with a name using :meth:`get_configparser`.
        In addition, you can now control the config values with
        :class:`~kivy.properties.ConfigParserProperty`.
    
    .. versionadded:: 1.0.7
    ```
    基类: Name(id='PythonConfigParser', ctx=Load())
    基类: Name(id='object', ctx=Load())
    函数 __init__(self: , name: )
    函数 add_callback(self: , callback: , section: , key: )
      ```
      Add a callback to be called when a specific section or key has
      changed. If you don't specify a section or key, it will call the
      callback for all section/key changes.
      
      Callbacks will receive 3 arguments: the section, key and value.
      
      .. versionadded:: 1.4.1
      ```
    函数 remove_callback(self: , callback: , section: , key: )
      ```
      Removes a callback added with :meth:`add_callback`.
      :meth:`remove_callback` must be called with the same parameters as
      :meth:`add_callback`.
      
      Raises a `ValueError` if not found.
      
      .. versionadded:: 1.9.0
      ```
    函数 _do_callbacks(self: , section: , key: , value: )
    函数 read(self: , filename: )
      ```
      Read only one filename. In contrast to the original ConfigParser of
      Python, this one is able to read only one file at a time. The last
      read file will be used for the :meth:`write` method.
      
      .. versionchanged:: 1.9.0
          :meth:`read` now calls the callbacks if read changed any values.
      ```
    函数 set(self: , section: , option: , value: )
      ```
      Functions similarly to PythonConfigParser's set method, except that
      the value is implicitly converted to a string.
      ```
    函数 setall(self: , section: , keyvalues: )
      ```
      Sets multiple key-value pairs in a section. keyvalues should be a
      dictionary containing the key-value pairs to be set.
      ```
    函数 get(self: , section: , option: )
    函数 setdefaults(self: , section: , keyvalues: )
      ```
      Set multiple key-value defaults in a section. keyvalues should be
      a dictionary containing the new key-value defaults.
      ```
    函数 setdefault(self: , section: , option: , value: )
      ```
      Set the default value for an option in the specified section.
              
      ```
    函数 getdefault(self: , section: , option: , defaultvalue: )
      ```
      Get the value of an option in the specified section. If not found,
      it will return the default value.
      ```
    函数 getdefaultint(self: , section: , option: , defaultvalue: )
      ```
      Get the value of an option in the specified section. If not found,
      it will return the default value. The value will always be
      returned as an integer.
      
      .. versionadded:: 1.6.0
      ```
    函数 adddefaultsection(self: , section: )
      ```
      Add a section if the section is missing.
              
      ```
    函数 write(self: )
      ```
      Write the configuration to the last file opened using the
      :meth:`read` method.
      
      Return True if the write finished successfully, False otherwise.
      ```
    函数 update_config(self: , filename: , overwrite: )
      ```
      Upgrade the configuration based on a new default config file.
      Overwrite any existing values if overwrite is True.
      ```
    函数 _register_named_property(name: , widget_ref: )
      ```
      Called by the ConfigParserProperty to register a property which
      was created with a config name instead of a config object.
      
      When a ConfigParser with this name is later created, the properties
      are then notified that this parser now exists so they can use it.
      If the parser already exists, the property is notified here. See
      :meth:`~kivy.properties.ConfigParserProperty.set_config`.
      
      :Parameters:
          `name`: a non-empty string
              The name of the ConfigParser that is associated with the
              property. See :attr:`name`.
          `widget_ref`: 2-tuple.
              The first element is a reference to the widget containing the
              property, the second element is the name of the property. E.g.:
      
                  class House(Widget):
                      address = ConfigParserProperty('', 'info', 'street',
                          'directory')
      
              Then, the first element is a ref to a House instance, and the
              second is `'address'`.
      ```
    函数 get_configparser(name: )
      ```
      Returns the :class:`ConfigParser` instance whose name is `name`, or
      None if not found.
      
      :Parameters:
          `name`: string
              The name of the :class:`ConfigParser` instance to return.
      ```
    函数 name(self: )
      ```
      The name associated with this ConfigParser instance, if not `''`.
      Defaults to `''`. It can be safely changed dynamically or set to `''`.
      
      When a ConfigParser is given a name, that config object can be
      retrieved using :meth:`get_configparser`. In addition, that config
      instance can also be used with a
      :class:`~kivy.properties.ConfigParserProperty` instance that set its
      `config` value to this name.
      
      Setting more than one ConfigParser with the same name will raise a
      `ValueError`.
      ```
  分析文件: factory.py
  类 FactoryException:
    基类: Name(id='Exception', ctx=Load())
  类 FactoryBase:
    基类: Name(id='object', ctx=Load())
    函数 __init__(self: )
    函数 create_from(cls: , factory: )
      ```
      Creates a instance of the class, and initializes to the state of
      ``factory``.
      
      :param factory: The factory to initialize from.
      :return: A new instance of this class.
      ```
    函数 is_template(self: , classname: )
      ```
      Return True if the classname is a template from the
      :class:`~kivy.lang.Builder`.
      
      .. versionadded:: 1.0.5
      ```
    函数 register(self: , classname: , cls: , module: , is_template: , baseclasses: , filename: , warn: )
      ```
      Register a new classname referring to a real class or
      class definition in a module. Warn, if True will emit a warning message
      when a class is re-declared.
      
      .. versionchanged:: 1.9.0
          `warn` was added.
      
      .. versionchanged:: 1.7.0
          :attr:`baseclasses` and :attr:`filename` added
      
      .. versionchanged:: 1.0.5
          :attr:`is_template` has been added in 1.0.5.
      ```
    函数 unregister(self: )
      ```
      Unregisters the classnames previously registered via the
      register method. This allows the same classnames to be re-used in
      different contexts.
      
      .. versionadded:: 1.7.1
      ```
    函数 unregister_from_filename(self: , filename: )
      ```
      Unregister all the factory objects related to the filename passed in
      the parameter.
      
      .. versionadded:: 1.7.0
      ```
    函数 __getattr__(self: , name: )
